
## Σημειώσεις για όλες τις ασκήσεις
* **ΑΠΑΓΟΡΕΥΕΤΑΙ** να κάνετε: ```a = input("...")``` (και γενικότερα μην το κάνετε ποτέ αυτό..)
* Όταν η εκφώνηση λέει ότι πρέπει να φτιάξετε συνάρτηση.. πρέπει να φτιάξετε συνάρτηση!
* Αν η εκφώνηση λέει ότι η συνάρτηση πρέπει να επιστρέφει κάτι.. τότε μέσα στη συνάρτησή σας πρέπει κάπου να κάνετε ```return```.
* Διαβάστε αυτή τη [λίστα με το κοινά λάθη](common_errors.md) που κάνουν συνήθως αρχάριοι στη python και στον προγραμματισμό.  
* **ΠΡΟΣΟΧΗ! Μην**  κάνετε: ```return True```  ή ```return False```  μετά από if


Για παράδειγμα, έστω ότι η άσκηση λέει: 

Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν αριθμό. Η συνάρτηση θα πρέπει να επιστρέφει:
* ```True``` αν ο αριθμός είναι μονός
* ```False``` αν ο αριθμός είναι ζυγός (άρτιος).

Τι να **ΜΗΝ** κάνετε:
```python
def f(n):
    if n%2 == 1:
        return True
    else:
        return False

```

Τι να κάνετε:
```python
def f(n):
    return n%2 == 1
```

Μπορείτε φυσικά να κάνετε `return True` ή `return False`, αν δεν μπορείτε να το απλοποιήσετε όπως παραπάνω.

* **ΑΠΑΓΟΡΕΥΕΤΑΙ** Να χρησιμοποιήσετε τα εξής **ονόματα μεταβλητών**: `str`, `id`, `int`, `list`, `tuple`, `dict`, `max`, `min`, `sum`. Αυτά είναι ονόματα συναρτήσεων της python. Η python σας αφήνει να τα χρησιμοποιήσετε με το "κόστος" ότι χάνεται η αρχική τους χρήση. π.χ:

```python
print (str(55))

str = 'Mitsos'
print (str(55))
```  

* Πάντα να βάζετε ένα σχόλιο πριν από την υλοποίηση με τον αριθμό της άσκησης που λύνεται. Για παράδειγμα:
```python

# άσκηση 42
def f(x):
    return x+1
```
* Θα παρατηρήσετε ότι οι περισσότερες συναρτήσεις σας ζητάνε να φτιάξετε μία συνάρτηση με συγκεκριμμένους παράμετρους. Εκτός αν το ζητάει η άσκηση, δεν χρειάζεται να ελέξετε αν οι τύποι των παραμέτρων είναι αυτός που ζητείται. Για παράδειγμα: 

> Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 2 ακέραιους αριθμούς...

Εσεις δεν χρειάζεται να ελέγξετε ότι όντως είναι ακέραιοι οι παράμετροι της συνάρτησης. 

* Μην κάνετε import βιβλιοθήκες, εκτός αν το ζητάει η άσκηση.


## Λίστα με τις ασκήσεις

### Άσκηση 1
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 2 αριθμούς. Η συνάρτηση θα επιστρέφει τον μέσο όρο των δύο αριθμών. Για παράδειγμα θα πρέπει:

```python

print (f(3,7)) # Τυπώνει: 5 
```

### Άσκηση 2
Φτιάξτε μία συνάρτηση η οποία θα παίρει σαν παράμετρο 3 αριθμούς. Η συνάρτηση θα επιστρέφει τον μέσο όρο των τριών αριθμών. Είναι υποχρεωτικό να χρησιμοποιήσετε τη συνάρτηση που φτιάξατε στη 1η άσκηση. Για παράδειγμα θα πρέπει:

```python
print (f(3,7,2)) # Τυπώνει 4  (δηλαδή (3+7+2)/3)  
```

Hint: αν `μ` είναι ο μέσος όρος των `α`,`β`. Τότε ο μέσος όρος των α,β,γ είναι: ((m\*2) + γ)/3 

### Άσκηση 3
Φιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 5 αριθμούς. Η συνάρτηση θα επιστρέφει τον μέσο όρο των 5 αριθμών. Είναι υποχρεωτικό να χρησιμοποιήσετε τη συνάρτηση της άσκησης 2 και τη συνάρτηση της άσκησης 1. Για παράδειγμα θα πρέπει:

```python
print (f(4,6,8,11,2)) # Τυπώνει 6.2 (δηλαδή: (4+6+8+11+2)/5)
```

Hint: αν `μ` είναι ο μέσoς όρος των `α`,`β` και `ν` είναι ο μέσος όρος των `γ`,`δ`,`ε`. Τότε ο μέσος όρος των `α`,`β`,`γ`,`δ`,`ε` είναι: ((μ\*2) + (ν\*3))/5.

### Άσκηση 4
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 2 αριθμούς. H συνάρτηση θα υπολογίζει το [Heronian Mean](https://en.wikipedia.org/wiki/Heronian_mean) αυτών των 2 αριθμών. Είναι υποχρεωτικό να χρησιμοποιήσετε τη συνάρτηση της 2ης άσκησης. Για παράδειγμα θα πρέπει:

```python
print (f(3,7)) # Τυπώνει 4.860858564985279 
```

Hint: H τετραγωνική ρίζα ενός αριθμού υπολογίζεται με: ```x**0.5``` . π.χ. `print(16**0.5)`, τυπώνει 4.


### Άσκηση 5
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 3 αριθμούς α,β,γ. Η συνάρτηση θα επιστρέφει: 

* `True` αν ο αριθμός β είναι μεγαλύτερος από το α και μικρότερος από το γ.
* `False` διαφορετικά 

Για παράδειγμα:

```python
print (f(1,3,5)) # Τυπώνει True
print (f(1,6,5)) # Τυπώνει False
```

* Σημείωση 1: Απαγορεύεται να χρησιμοποιήσετε την if. 
* Σημείωση 2: Η συνάρτηση θα επιστρέφει μία λογική τιμή, όχι αλφαριθμητικό. Για παράδειγμα μη μπερδέψετε το `True` με το  `'True'`

### Άσκηση 6
Φτιάξτε μία συνάρτηση η οποία θα παίρνει για παράμετρο 4 αριθμούς α,β,γ,δ . Η συνάρτηση θα επιστρέφει:

* `True` , αν το α είναι μικρότερο του β και το β μικρότερο του γ και το γ μικρότερο του δ.
* `False`, αν δεν ισχύει το παραπάνω.

 Για παράδειγμα θα πρέπει:

```python
print (f(1,2,3,4,)) # Τυπώνει True
print (f(1,2,4,3,)) # Τυπώνει False
print (f(2,1,3,4,)) # Τυπώνει False
```

* Σημείωση 1: Απαγορεύεται να χρησιμοποιήσετε την if. 
* Σημείωση 2: Είναι υποχρεωτικό να χρησιμοποιήσετε την συνάρτηση της άσκησης 5

### Άσκηση 7
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 4 αριθμούς α,β,γ,δ. Η συνάρτηση θα πρέπει να επιστρέφει:

* `False`, αν δεν είναι όλοι διαφορετικοί
* `True`, αν οι 4 αριθμοί είναι ταξινομημένοι από τον μεγαλύτερο στον μικρότερο (δηλαδή α>β>γ>δ).
* `False`, αν δεν είναι ταξινομημένοι από τον μεγαλύτερο στον μικρότερο.

Δηλαδή θα πρέπει:

```python
print (f(1,2,3,3)) # Τυπώνει False
print (f(1,2,3,1)) # Τυπώνει False
print (f(1,2,3,4)) # Τυπώνει False
print (f(7,5,3,1)) # Τυπώνει True
print (f(7,5,1,3)) # Τυπώνει False
print (f(7,1,5,3)) # Τυπώνει False
print (f(1,7,5,3)) # Τυπώνει False
```

* Σημείωση 1: είναι υποχεωτικό να χρησιμοποιήσετε τη συνάρτηση της άσκησης 6.
* Σημείωση 2: Απαγορεύεται να χρησιμοποιήσετε την if. 

### Άσκηση 8
Δύο γονίδια Α και Β είναι μεταγραφικοί παράγοντες σε ένα τρίτο γονίδιο Γ. Αν και τα δύο γονίδια Α και Β είναι ανενεργά τότε το Γ είναι ενεργό. Αν ένα από τα Α και Β είναι ενεργό, τότε το Γ είναι ενεργό. Αν όμως τα γονίδια Α και Β είναι και τα δύο ενεργά, τότε αλληλοεπιδρούν και φτιάχνουν μία πρωτεΐνη η οποία εξουδετερώνει τη δράση του Γ, οπότε το γονίδιο Γ δεν ενεργοποιείται.

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 2 λογικές τιμές την Α και Β. Η συνάρτηση θα επιτρέφει:

* `True`, αν οι τιμές των Α και Β είναι τέτοιες που να ενεργοποιούν το γονίδιο Γ.
* `False`, αν οι τιμές των Α και Β είναι τέτοιες που να απενεργοποιούν το γονίδιο Γ.

Δηλαδή θα πρέπει:

```python
print(f(True, True)) # Τυπώνει False
print(f(True, False)) # Τυπώνει True
print(f(False, True)) # Τυπώνει True
print(f(False, False)) # Τυπώνει True
```

Η υλοποίησή σας θα πρέπει να συμπληρώνει τις τελίστες στη παρακάτω συνάρτηση:

```python
def f(A,B):
    return ............
```

### Άσκηση 9
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 2 παράμετρους α και β οι οποίες θα είναι αλφαριθμητικά. Η συνάρτηση θα επιστρέφει:

* `True` αν το αντίστροφο του α υπάρχει στο τέλος του β
* `False` αν δεν ισχύει το παραπάνω

Για παράδειγμα θα πρέπει:

```python
print (f('si', 'Alexis')) # Τυπώνει True ( το αντίστροφο του si είναι το is το οποίο υπάρχει στο τέλος του Alexis)
print (f('is', 'Alexis')) # Τυπώνει False

```

Σημείωση: Απαγορεύεται να χρησιμοποιήσετε την if. 

### Άσκηση 10
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα αλφσαριθμητικό το οποίο θα είναι μία ακολουθία DNA. Η συνάρτηση θα επιστρέφει ένα string το οποίο θα περιέχει το 2ο νουκλεοτίδιο κάθε codon. Για παράδειγμα θα πρέπει:

```python
print (f('ACGTGAAAGGTT')) # Τυπώνει `CGAT`
```

Επεξήγηση:
```
ACGTGAAAGGTT  --> Σε codons:

ACG | TGA | AAG| GTT  -> το 2ο γράμμα κάθε codon είναι:
 |     |     |    |
 C     G     A    T

```

### Άσκηση 11
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο το ύψος και το βάρος ενός ανθρώπου. Η συνάρτηση θα πρέπει:
* Αν το ύψος είναι μεγαλύτερο από 2.30 ή μικρότερο από 1 μέτρο, να επιστρέφει "λάθος τιμές για ύψος"
* Αν το βάρος είναι μεγαλύτερο από 200 ή μικρότερο από 30, να επιστρέφει "λάθος τιμές για βάρος"
* Υπολογίζει το BMI (βάρος/(ύψος<sup>2</sup>))
* Αν το BMI είναι μικρότερο από 19 επιστρέφει "αδύνατο"
* Αν το BMI είναι ίσο με 19 και μικρότερο από 25 επιστρέφει "φυσιολογικό"
* Αν το BMI είναι ίσο με 25 και μικρότερο από 30 επιστρέφει "υπέρβαρο"
* Αν το BMI είναι ίσο με 30 ή μεγαλύτερο επιστρέφει "παχύσαρκο"


### Άσκηση 12
Υλοποιήστε την άσκηση 8 με if

### Άσκηση 13
Η ενεργοποίηση του [Lac operon](https://en.wikipedia.org/wiki/Lac_operon) στα βακτήρια απαιτεί ένα αρκετό πολύπλοκο σύστημα από πρωτεϊνικές αλληλεπιδράσεις. Αν το απλοποιήσουμε λίγο μπορούμε να πούμε ότι:

* Το lac operon δεν είναι ενεργοποιημένο αν δεν υπάρχει λακτόζη.
* Αν υπάρχει λακτόζη αλλά υπάρχει και γλυκόζη, τότε πάλι το lac operon είναι απενεργοποιημένο
* Αν υπάρχει λακτόζη αλλά δεν υπάρχει γλυκόζη τότε η ενεργοποίηση του lac operon εξαρτάται από τη συγκέντρωση του [cAMP](https://en.wikipedia.org/wiki/Cyclic_adenosine_monophosphate). Αν η συγκέτρωση είναι πάνω από 0.2 τότε το lac operon ενεργοποιείται, αλλιως δεν ενεργοποιείται. 

Φτιάξτε μία συνάρτηση η οποία θα παίρνει 3 παραμέτρους, lactose_present, glucose_present και cAMP_concentration. Οι πρώτες δύο θα είναι λογικές μεταβλητές και η τρίτη (cAMP_concentration) θα είναι αριθμητική. Η συνάρτηση θα πρέπει να επιστρέφει True ή False ανάλογα με το αν οι τιμές των παραμέτρων είναι κατάλληλες για να ενεργοποιηθεί το Lac operon 

Για παράδειγμα θα πρέπει:

```python
print (f(False, False, 0.5)) # Τυπώνει False
print (f(False, True, 0.1)) # Τυπώνει False
print (f(True, True, 0.1)) # Τυπώνει False
print (f(True, True, 0.5)) # Τυπώνει False
print (f(True, False, 0.5)) # Τυπώνει True
print (f(True, False, 0.1)) # Τυπώνει False
```


### Άσκηση 14
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 4 αριθμητικούς παραμέτρους α,β,γ,δ. Η συνάρτηση θα πρέπει να επιτρέφει True αν το διάστημα [α,β] έχει κάποια τομή με το διάστημα [γ,δ]. Αν δεν υπάρχει κάποια τομή μεταξύ τους, επιστρέφει False.  Αν το [α,β] είναι "μέσα" στο [γ,δ] ή το [γ,δ] μέσα στο [α,β] τότε πάλι επιστρέφει False. Για παράδειγμα θα πρέπει:

```python
print (f(1,3,5,7)) # Τυπώνει False: το διάστημα [1,3] δεν έχει τομή με το διάστημα [5,7]
print (f(1,3,2,5)) # Τυπώνει True: το [1,3] έχει τομή με το [2,7]
print (f(2,5,1,3)) # Τυπώνει True: το [2,5] έχει τομή με το [1,3]
print (f(1,3,0,4)) # Τυπώνει False: το [1,3] είναι όλο μέσα στο [0,4]
print (f(2,8,3,5)) # Τυπώνει False: το [3,5] είναι όλο μέσα στο [2,8] 
```

* Σημείωση 1: απαγορεύετσαι να χρησιμοποιήσετε for (ή κάποια άλλη επανάληψη). Θα πρέπει να το υλοποιήσετε μόνο με if
* Σημείωση 2: Στην άσκηση αυτή θεωρούμε ότι τα διαστήματα είναι ανοιχτά. Δηλαδή το διάστημα [1,2] δεν έχει κοινό με το διάστημα [2,3]. 

### Άσκηση 15
Φτιάξτε μία συνάρτηση η οποία θα παίρνει τους εξής παραμέτρους: credit_score (αριθμητική), income (αριθμητική), employment_status (string), current_debt (αριθμητική), loan_amount (αριθμητική). Υποθέτουμε ότι μία τράπεζα δίνει ένα δάνεια αν ([και μόνο αν](https://el.wikipedia.org/wiki/%CE%91%CE%BD_%CE%BA%CE%B1%CE%B9_%CE%BC%CF%8C%CE%BD%CE%BF_%CE%B1%CE%BD)) συντρέχουν όλοι οι παρακάτω όροι:

1. To `credit_score` είναι πάνω από 600
2. Το `income` είναι πάνω από 20000
3. To `employment_status` είναι είτε `"full_time"` είτε `"part_time"`
4. To `debt_to_income_ratio` το οποίο είναι ο λόγος του `current_debt` με το `income` είναι μικρότερο από 0.5
5. το `loan_amount` είναι μικρότερο από το 25% του `income`

Η συνάρτηση θα επιστρέφει True αν μπορεί ένας πελάτης να πάρει δάνειο ή False διαφορετικά. 

Σημείωση: είναι υποχρεωτικό να χρησιμοποιείσετε την elif

### Άσκηση 16
Υλοποιήσετε την άσκηση 15 χωρίς να χρησιμοποιείσετε την elif

### Άσκηση 17
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 3 παραμέτρους: `exercises`, `project`, `final`. Οι παράμετροι αυτοί εκπροσωπούν τους βαθμούς (από 0 μέχρι και 10, δεν χρειάζεται να το ελέγξετε αυτό), που πήρε κάποιος φοιτητής στις ασκήσεις, στο project και στο τελικό διαγώνισμα ενός μαθήματος αντίστοιχα. Η συνάρτηση θα πρέπει να επιστρέφει True αν περνάει το μάθημα και False διαφορετικά. Οι κανόνες για να περάσει κάποιος το μάθημα είναι:

1. Υπολογίζεται ο συνολικός βαθμός του μαθήματος ο οποίος απότελείται από το 33% του βαθμού των ασκήσεων, το 33% του βαθμού του project, και το 34% του βαθμού του τελικού.
2. Αν ο τελικός βαθμός είναι μεγαλύτερος ή ίσος από 5 τότε περνάει (επιστρέφει True) διαφορετικά δεν περνάει
3. Ο κανόνας 2 έχει μία εξαίρεση: Αν ο φοιτητής έχει βαθμό project ή βαθμό ασκήσεων μικρότερο από 4 τότε δεν περνάει, ανεξάρτητα από τον βαθμό του τελικού.
4. Οι κανόνες 2 και 3 έχουν μία εξαίρεση: Αν ο βαθμός στο τελικό είναι μεγαλύτερος ή ίσος με 9, τότε περνάει.

Δίνονται μετικά παραδείγματα:
```python
print (f(8,8,8)) # Τυπώνει True, Μέσος όρος 8, περνάει 
print (f(5,5,4)) # Τυπώνει False, Μέσος όρος <5.0
print (f(3,8,8)) # Τυπώνει False, Μέσος όρος >5.0, αλλά έχει γράψει στις ασκήσεις <4  
print (f(8,3,8)) # Τυπώνει False, Μέσος όρος >5.0, αλλά έχει γράψει στο project < 4 
print (f(8,3,9)) # Τυπώνει True, έχει γράψει στο project < 4 αλλά έχει γράψει >= 9 στο τελικό
print (f(3,8,9)) # Τυπώνει True, έχει πάρει στις ασκήσεις < 4 αλλά έχει γράψει >= 9 στο τελικό 
print (f(1,1,10)) # Τυπώνει True, έχει μέσο όρο < 5, έχει γράψει <4 σε ασκήσεις και projects αλλά έχει γράψει >= 9 στο τελικό
```

### Άσκηση 18
Οι ακολουθίες του DNA οι οποίες μπορούν να μεταφραστούν ως ένα [stop codon](https://en.wikipedia.org/wiki/Stop_codon) είναι: `TAG`, `TAA`, `TGA`. Φτιάξτε μία συνάρτηση η οποία παίρνει τις εξής παραμέτρους (όλοι είναι λογικοί παράμετροι):
* `Τ_1` : είναι True, αν το 1ο νουκλεοτίδιο του codon είναι T, αλλίως False
* `A_2` : είναι True, αν το 2ο νουκλεοτίδιο του codon είναι A, αλλίως False
* `G_2` : είναι True, αν το 2ο νουκλεοτίδιο του codon είναι G, αλλίως False
* `G_3` : είναι True, αν το 3ο νουκλεοτίδιο του codon είναι G, αλλίως False
* `Α_3` : είναι True, αν το 3ο νουκλεοτίδιο του codon είναι A, αλλίως False

* Αν και το Α_2 και το G_2 είναι True θα πρέπει να επιστρέφει το string: `impossible`
* Αν και το G_3 και το A_3 είναι True θα πρέπει να επιστρέφει το string: `impossible`

Διαφορετικά:

Η συνάρτηση θα πρέπει να επιστρέφει True αν οι παραμέτροι είναι τέτοιοι που να σχηματίζεται ένα stop codon αλλιώς να επιστρέφει False. Για παράδειγμα θα πρέπει:

```python
print (f(T_1=True, A_2=True, G_2=True, G_3=True, A_3=False)) # Τυπώνει "impossible"
print (f(T_1=True, A_2=True, G_2=False, G_3=True, A_3=False)) # (TAG) Τυπώνει True 
print (f(T_1=True, A_2=True, G_2=False, G_3=False, A_3=True)) # (TAA) Τυπώνει True
print (f(T_1=True, A_2=False, G_2=True, G_3=False, A_3=True)) # (TGA) Τυπώνει True
print (f(T_1=False, A_2=False, G_2=True, G_3=False, A_3=True)) #  Τυπώνει False
print (f(T_1=True, A_2=False, G_2=True, G_3=True, A_3=False)) # (TGG) Τυπώνει False
```

Σημείωση: Απαγορεύεται να χρησιμοποιήσετε οποιοδήποτε τελεστή! (==, !=, or, and, ...)

Hint:

Αυτό:

```python
if T_1 == True:
    print ('Το πρώτο νουκλεοτίδιο είναι Τ')
```

Είναι το ίδιο με αυτό:

```python
if T_1:
    print ('Το πρώτο νουκλεοτίδιο είναι Τ')
```

Προσέξτε ότι βγάλαμε τον τελεστή `==`

### Άσκηση 19
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα string με 3 γράμματα (δεν χρειάζεται να το ελέξετε αυτό). Η συνάρτηση θα επιστρέφει:

* `True`: αν το string μπορεί να μεταφραστεί σε stop codon
* `False`: αν το string δεν μπορεί να μεταφραστεί σε stop codon

Για παράδειγμα θα πρέπει:

```python
print (f('TAG')) # Τυπώνει "True"
print (f('TAA')) # Τυπώνει "True"
print (f('TGA')) # Τυπώνει "True"
print (f('AGA')) # Τυπώνει "False"
print (f('TGG')) # Τυπώνει "False"
```

Σημείωση: είναι υποχρεωτικό να χρησιμοποιήσετε τη συνάρτηση της άσκησης 18.

### Άσκηση 20
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα string. Η συνάρτηση αυτή θα ελέγχει αν το string έχει όλες τις προδιαγραφές για να χρησιμοποιηθεί ως το password ενός χρήστη (password validation). Οι προδιαγραφές είναι:

* Πρέπει να είναι πάνω από 6 χαρακτήρες
* Πρέπει να περιέχει τους χαρακτήρες "!" και "@" σε απόσταση 3 ή περίσσότερο μεταξύ τους. 
* Πρέπει να ξεκινάει με ένα κεφαλαίο γράμμα και να τελειώνει με ένα μικρό ή το αντίθετο (να ξεκινάει με μικρό και να τελειώνει με κεφαλαίο)

([ναι.. οι κανόνες δεν χρειάζεται να βγάζουν νόημα](https://dumbpasswordrules.com/))

Αν ισχύουν όλοι οι κανόνες θα επιστρέφει True αλλίως θα επιστρέφει False

### Άσκηση 21 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρεις παράμετρους. Η πρώτη θα είναι μία λίστα με αριθμούς (π.x l) η δεύτερη ένας αριθμός (π.χ. α) και η τρίτη ένας αριθμός π.χ. β. Η συνάρτηση θα επιστρέφει το **άθροισμα** των αριθμών της λίστας οι οποίοι είναι μεγαλύτεροι από α και μικρότεροι από β. Για παράδειγμα θα πρέπει:

```python
print (f([8,3,10, 11,9,8,5], 5, 10)) # Τυπώνει:  25 (δηλαδή 8+8+9, οι αριθμοί που είναι μεγαλύτεροι από 5 και μικρότεροι από 10) 
```

* Σημείωση 1: είναι υποχρεωτικό να χρησιμοποιήσετε for (όχι list comprehension)
* Σημείωση 2: Απαγορεύεται να χρησιμοποιήσετε continue

### Άσκηση 22 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρεις παράμετρους. Η πρώτη θα είναι μία λίστα με αριθμούς (π.x l) η δεύτερη ένας αριθμός (π.χ. α) και η τρίτη ένας αριθμός π.χ. β. Η συνάρτηση θα επιστρέφει το **πλήθος** των αριθμών της λίστας οι οποίοι είναι μεγαλύτεροι από α και μικρότεροι από β. Για παράδειγμα θα πρέπει:

```python
print (f([8,3,10, 11,9,8,5], 5, 10)) # Τυπώνει: 3  
```

* Σημείωση 1: είναι υποχρεωτικό να χρησιμοποιήσετε for (όχι list comprehension)
* Σημείωση 2: Απαγορεύεται να χρησιμοποιήσετε continue

### Άσκηση 23
Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρεις παράμετρους. Η πρώτη θα είναι μία λίστα με αριθμούς (π.x l) η δεύτερη ένας αριθμός (π.χ. α) και η τρίτη ένας αριθμός π.χ. β. Η συνάρτηση θα επιστρέφει τον μεγαλύτερι αριθμό της λίστας ο οποίος είναι μεγαλύτερος από α και μικρότερος από β. Για παράδειγμα θα πρέπει:

```python
print (f([8,3,10, 11,9,8,5], 5, 10)) # Τυπώνει: 9  
```

* Σημείωση 1: είναι υποχρεωτικό να χρησιμοποιήσετε for (όχι list comprehension)
* Σημείωση 2: Απαγορεύεται να χρησιμοποιήσετε continue

### Άσκηση 24
Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρεις παράμετρους. Η πρώτη θα είναι μία λίστα με αριθμούς (π.x l) η δεύτερη ένας αριθμός (π.χ. α) και η τρίτη ένας αριθμός π.χ. β. Η συνάρτηση θα επιστρέφει `True` αν υπάρχει έστω ένας αριθμός ο οποίος να είναι μεγαλύτερος από α και μικρότερος από β ή `False` αν δεν υπάρχει κανένας τέτοιος αριθμός . Για παράδειγμα θα πρέπει:

```python
print (f([8,3,10, 11,9,8,5], 5, 10)) # Τυπώνει: True  
print (f([-8,3,10, 11,-9,-8,5], 5, 10)) # Τυπώνει: False  
```

* Σημείωση 1: είναι υποχρεωτικό να χρησιμοποιήσετε for (όχι list comprehension)
* Σημείωση 2: Απαγορεύεται να χρησιμοποιήσετε break ή continue.

### Άσκηση 25
Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρεις παράμετρους. Η πρώτη θα είναι μία λίστα με αριθμούς (π.x l) η δεύτερη ένας αριθμός (π.χ. α) και η τρίτη ένας αριθμός π.χ. β. Η συνάρτηση θα επιστρέφει `True` αν υπάρχει έστω ένας αριθμός ο οποίος να είναι μεγαλύτερος από α και μικρότερος από β ή `False` αν δεν υπάρχει κανένας τέτοιος αριθμός . Για παράδειγμα θα πρέπει:

```python
print (f([8,3,10, 11,9,8,5], 5, 10) # Τυπώνει: True  
print (f([-8,3,10, 11,-9,-8,5], 5, 10) # Τυπώνει: False  
```

* Σημείωση 1: είναι υποχρεωτικό να χρησιμοποιήσετε for (όχι list comprehension)
* Σημείωση 2: είναι υποχρεωτικό να χρησιμοποιήσετε break και continue (και τα 2!). To continue δεν μπορεί να είναι στο τέλος της for. Για παράδειγμα:

```python
for x in [1,2,3]:
    print (x)
    continue # <-- Δεν έχει νόημα αυτό
```

### Άσκηση 26 
Υλοποιήστε την άσκηση 21

* Σημείωση 1: είναι υποχρεωτικό να χρησιμοποιήσετε for (όχι list comprehension)
* Σημείωση 2: είναι υποχρεωτικό να χρησιμοποιήσετε continue. To continue δεν μπορεί να είναι στο τέλος της for.

### Άσκηση 27
Υπάρχει μόνο ένα ζευγάρι τιμών χ,y τέτοια ώστε:
* Τα χ,y είναι ακέραιοι από το 1 μέχρι και το 100
* Η έκφραση `x*y+23*x-7*y` διαιρείται ακριβώς με το 1000.

Ποιο είναι το άθροισμα των χ,y που έχει αυτή την ιδιότητα; Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα επιστρέφει την απάντηση σε αυτή την ερώτηση. Δίνεται τι θα επιστρέφει η συνάρτηση:

```python
print (f()) # Τυπώνει 168
```

Δίνεται πως ελέγχουμε αν ένας αριθμός διαιρείται με το 1000. Απλά τσεκάρουμε αν το υπόλοιπο της διαίρεσης με το 1000 είναι 0:

```python
print ( 1234 % 1000 == 0 ) # Τυπώνει False. το 1234 δεν διαρείται με το 1000
print ( 3000 % 1000 == 0 ) # Τυπώνει True. το 3000 διαρείται με το 1000
```

### Άσκηση 28
Φτιάξτε μία συνάρτηση η οποία δεν παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει ένα string το οποίο θα περιέχει όλα τα 64 codons ακριβώς μία φορά. Δηλαδή θα πρέπει:

```python
print (f()) # Τυπώνει: AAAAACAAGAATACAACCACGACTAGAAGCAGGAGTATAATCATGATTCAACACCAGCATCCACCCCCGCCTCGACGCCGGCGTCTACTCCTGCTTGAAGACGAGGATGCAGCCGCGGCTGGAGGCGGGGGTGTAGTCGTGGTTTAATACTAGTATTCATCCTCGTCTTGATGCTGGTGTTTATTCTTGTTT
```

Εξήγηση: Όλα τα codons είναι: `AAA`, `AAC`, `AAG`, `AAT`, `ACA`, `ACC`, `ACG`, `ACT`, `AGA`, ... H σειρά δεν έχει σημασία αρκεί να είναι και τα 64 (`4*4*4`) ακριβώς μία φορά το κάθε ένα. Είναι υποχρεωτικό να χρησιμοποιήσετε for και να μην κάνετε import τίποτα.

### Άσκηση 29
Φτιάξτε μία συνάρτηση η οποία θα τυπώνει χαριτωμένα σχεδιάκια με αστεράκια με τον εξής τρόπο:

```python
print f(1)
```
Τυπώνει:
```
*
```


```python
print f(2)
```
Τυπώνει:
```
**
*
```

```python
print f(3)
```
Τυπώνει:
```
***
**
*
```

```python
print f(4)
```
Τυπώνει:
```
****
***
**
*
```

κτλ..

### Άσκηση 30
Μία ακολουθία DNA λέγεται συμμετρική αν διαβάζεται το ίδιο από την αρχή και από το τέλος. Μερικά παραδείγματα είναι: `ACCA`, `ACGCA`, `GGG`, `TT`. Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία ακολουθία DNA. Η συνάρτηση θα επιστρέφει True αν υπάρχει έστω και μία υπο-ακολουθία η οποία να είναι συμμετρική ή False διαφορετικά. Για παράδειγμα θα πρέπει:

```python 
print (f('ACGACTAG')) # Τυπώνει False, δεν περιέχει συμμετρική ακολουθία
print (f('ACGAATAG')) # Τυπώνει True, υπάρχει η ΑΑ
print (f('ACGAGCAG')) # Τυπώνει True, υπάρχει η CGAGC
```

### Άσκηση 31
Ποιο είναι το άθροισμα όλων των αριθμών από το 1 μέχρι και το 1000 αν δεν μετρήσουμε τους αριθμούς που έχουν μέσα το "3"; Δηλαδή δεν μετράμε το 3, το 13, το 23, ..., 103, ... 134, ... 

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα πρέπει να επιστρέφει την απάντηση στην παραπάνω ερώτηση.

Σημείωση: Αν χρησιμοποιήσετε τη `str` θα χάσετε 2 πόντους! Δηλαδή θα βαθμολογηθείτε με άριστα το 8/10. Προσπαθήστε να την υλοποιήσετε χωρίς τη `str`

### Άσκηση 32
Ποιο είναι το άθροισμα όλων των αριθμών από το 1 μέχρι και το 10.000 αν δεν μετρήσουμε τους αριθμούς που έχουν μέσα το "3" μόνο μία φορά; Δηλαδή δεν μετράμε το 3, το 13, το 23, ..., 103, ... 134, ..., 305, 2003. Αλλά μετράμε το 33, 331, 333, 1033, 1303,  

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα πρέπει να επιστρέφει την απάντηση στην παραπάνω ερώτηση.

Σημείωση: Αν χρησιμοποιήσετε τη `str` θα χάσετε 2 πόντους! Δηλαδή θα βαθμολογηθείτε με άριστα το 8/10. Προσπαθήστε να την υλοποιήσετε χωρίς τη `str`

### Άσκηση 33
[Γνωρίζουμε από τα μαθηματικά](https://en.wikipedia.org/wiki/1/2_%2B_1/4_%2B_1/8_%2B_1/16_%2B_%E2%8B%AF) ότι: 1/2 + 1/4 + 1/8 + 1/16 + ... = 1. Πόσους όρους αυτής της ακολουθίας πρέπει να προσθέσουμε ώστε η διαφορά του αθροίσματός τους με το 1 να γίνει μικρότερη από 0.000001 ;

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα πρέπει να επιστρέφει την απάντηση στην παραπάνω ερώτηση.

### Άσκηση 34
[Γωνρίζουμε από τα μαθηματικά](https://en.wikipedia.org/wiki/1/2_%E2%88%92_1/4_%2B_1/8_%E2%88%92_1/16_%2B_%E2%8B%AF) ότι: 1/2 - 1/4 + 1/8 - 1/16 + ... = 1/3. Πόσους όρους αυτής της ακολουθίας πρέπει να προσθέσουμε ώστε η απόλυτη διαφορά (`abs(s-1/3)`) του αθροίσματός τους με το 1/3 να γίνει μικρότερη από το  0.000001 ;

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα πρέπει να επιστρέφει την απάντηση στην παραπάνω ερώτηση.

Σημείωση: Μπορείτε να χρησιμοποιήσετε τη συνάρτηση `abs` της python η οποία επιστρέφει την απόλυτη τιμή μίας έκφρασης.  

### Άσκηση 35
[Γνωρίζουμε από τα μαθηματικά](https://en.wikipedia.org/wiki/Pi#Rate_of_convergence) ότι: 

![img](https://wikimedia.org/api/rest_v1/media/math/render/svg/fdafa8bd24ce2b6fd518a3cf253ad1ef409388a6)

Πόσους όρους αυτής της ακολουθίας πρέπει να προσθέσουμε ώστε το η απόλυτη διάφορά του αθροίσματός τους με το π να γίνει μικρότερη από το 0.0001 ;

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα πρέπει να επιστρέφει την απάντηση στην παραπάνω ερώτηση.


Δίνεται ότι η τιμή του π (pi) είναι:

```python
import math
print (math.pi)
```


### Άσκηση 36 
To [παραγοντικό ενός αριθμού](https://en.wikipedia.org/wiki/Factorial) n συμβολίζεται με n! και ισούται με το γινόμενο όλων των ακέραιων αριθμών από 1 μέχρι και το n. Για παράδειγμα το παραγοντικό του 4 είναι 24 (1\*2\*3\*4). Ορίζουμε επίσης ότι το παραγοντικό του 0 είναι 1, δηλαδή 0! = 1. Εννοείται ότι όλοι γνωρίζουμε από τα μαθηματικά ότι το ([e, δηλαδή η βάση των φυσικών λογαρίθμων](https://en.wikipedia.org/wiki/E_%28mathematical_constant%29)) είναι ίσο με:

e = 1/(0!) + 1/(1!) + 1/(2!) + 1/(3!) + 1/(4!) + ...

ή αλλιώς:

e = 1/1 + 1/1 + 1/(1\*2) + 1/(1\*2\*3) + 1/(1\*2\*3\#4) + ...

ή αλλιώς:

![img](https://wikimedia.org/api/rest_v1/media/math/render/svg/2f9a1f86072b07e1f69d5e21571c207d52680d8f)


Πόσους όρους αυτής της ακολουθίας πρέπει να προσθέσουμε ώστε η διαφορά του αθροίσματός τους με το e να γίνει μικρότερη από το 0.0001 ;

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα επιστρέφει την απάντηση στη παραπάνω ερώτηση.

To e μπορείτε να το "πάρετε" με τον εξής τρόπο:

```python
import math

print (math.e)

```

* Σημείωση 1: Απαγορεύεται να κάνε import κάποια βιβλιοθήκη εκτός από την import για να πάρετε το e (αν δεν ξέρετε τι είναι αυτό, τόσο το καλύτερο!)
* Σημείωση 2: Θα πρέπει να φτιάξετε μία και μόνο μία συνάρτηση (μην φτιάξετε συνάρτηση η οποία υπολογίζει το παραγοντικό)

### Άσκηση 37

Ο Lothar Collatz, είπε [ένα θεώρημα](https://en.wikipedia.org/wiki/Collatz_conjecture) το οποίο μέχρι σήμερα είναι αναπόδεικτο! Συγκεκριμένα είπε ότι αν πάρουμε οποιοδήποτε ακέραιο αριθμό μεγαλύτερο από 1 και εφαρμόσουμε την εξής διαδικασία:

* Αν είναι ζυγός τον διαιρούμε με το 2
* Αν είναι μονός το πολλαπλασιάζουμε με το 3 και προσθέτουμε το 1
* Εφαρμόζουμε τους παραπάνω δύο κανόνες στον νέο αριθμό που βρήκαμε

Τότε ο αριθμός που θα καταλήξουμε θα είναι πάντα ο 1 !!! Για παράδειγμα έστω ότι έχουμε τον αριθμό 45:
* Το 45 είναι μονός άρα πάμε στον 45\*3 + 1 = 136
* Το 136 είναι ζυγός άρα πάμε στον 136/2 = 68
* Το 68 είναι ζυγός άρα πάμε στον 68/2 = 34
* Το 34 είναι ζυγός άρα πάμε στον 34/2 = 17
* Το 17 είναι μονός άρα πάμε στον 17\*3 + 1 = 52
* Το 52 είναι ζυγός άρα πάμε στον 52/2 = 26
* Το 26 είναι ζυγός άρα πάμε στον 26/2 = 13
* Το 13 είναι μονός άρα πάμε στον 13\*3 + 1 = 40
* Το 40 είναι ζυγός άρα πάμε στον 40/2 = 20
* Το 20 είναι ζυγός άρα πάμε στον 20/2 = 10
* Το 10 είναι ζυγός άρα πάμε στον 10/2 = 5
* Το 5 είναι μονός άρα πάμε στον 5\*3 +  1 = 16
* Το 16 είναι ζυγός άρα πάμε στον 16/2 = 8
* Το 8 είναι ζυγός άρα πάμε στον 8/2 = 4
* Το 4 είναι ζυγός άρα πάμε στον 4/2 = 2
* Το 2 είναι ζυγός άρα πάμε στον 2/2 = 1 !!! 


Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο έναν αριθμό n. Η συνάρτηση θα επιστρέφει μία λίστα με όλους τους αριθμούς που παίρνουμε με βάση την παραπάνω διαδικασία για να καταλήξουμε στο 1. Δηλαδή θα πρέπει:


```python
print (f(45)) # Τυπώνει [136, 68, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
```
 

### Άσκηση 38
Όπως είπαμε και στο μάθημα το [πρόβλημα της παραγοντοποίησης](https://en.wikipedia.org/wiki/Integer_factorization) είναι ένα από τα πιο δύσκολα στην επιστήμη των υπολογιστών. Ευτυχώς για μικρούς αριθμούς το πρόβλημα δεν είναι καθόλου δύσκολο. Η παραγοντοποίηση λοιπόν ενός ακέραιου θετικού αριθμού ορίζεται ώς το σύνολο από πρώτους αριθμούς τους οποίους αν τους πολλαπλασιάσεις θα πάρεις τον αρχικό αριθμό. Δίνονται μερικά παραδειγματα:

```
100 = 2 * 2 * 5 * 5
99 = 3 * 3 * 11
98 = 2 * 7 * 7
96 = 2 * 2 * 2 * 2 * 2 * 3
```


Φτιάξτε μία συνάρτηση η οποία θα παίρνει έναν αριθμό και θα επιστρέφει το πλήθος από παράγοντες που έχει. Θα πρέπει δηλαδή:

```python
print (f(100)) # Τυπώνει: 4
print (f(99)) # Τυπώνει: 3
print (f(98)) # Τυπώνει: 3
print (f(96)) # Τυπώνει: 6
```

* Σημείωση: Δεχόμαστε σαν σύμβαση ότι το 1 έχει 0 παράγοντες (δες και επόμενη άσκηση). Δηλαδή:

```python
print (f(1)) # Τυπώνει 0
```

### Άσκηση 39
(Συνέχεια της άσκησης 38)

Παρατηρούμε τώρα ότι κάποιοι αριθμοί όπως το 100 και το 96 έχουν ζυγό αριθμό από παράγοντες (το 100 έχει 4 και το 96 έχει 6), ενώ κάποιοι άλλοι όπως το 99 και το 98 έχουν μονό αριθμό από παράγοντες (και οι 2 έχουν 3 παράγοντες). Αν πάρουμε έναν αριθμό έστω n και πάρουμε όλους τους αριθμούς από το 1 μέχρι και το n, τότε αυτοί οι αριθμοί μπορούν να χωριστούν σε δύο κατηγορίες: αυτοί που έχουν ζυγό αριθμό από παράγοντες και μονό αριθμό από παράγοντες. Ποιος είναι ο λόγος των αριθμών από το 1 μέχρι και το n που έχουν μονό αριθμό από παράγοντες; Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο έναν αριθμό n. Η συνάρτηση θα επιστρέφει έναν αριθμό ο οποίος θα είναι ο αυτός ο λόγος (λόγος = [ratio](https://en.wikipedia.org/wiki/Ratio),  δηλαδή ένας αριθμός από 0 μέχρι και 1). 

Για παράδειγμα ας πάρουμε τον αριθμό 10. Όλοι οι αριθμοί από 1 μέχρι και το 10 μαζί με τους παράγοντες τους, το πλήθος των παραγόντων και αν είναι μονός ή ζυγός αριθμός αυτό το πλήθος είναι: 

| αριθμός  | παράγοντες    |  πλήθος παραγόντων  |  μονό πλήθος ή ζυγό πλήθος      |
|----------|---------------|---------------------|---------------------------------|
| 1  | []      | 0  | ζυγός |
| 2  | [2]     | 1  | μονός |
| 3  | [3]     | 1  | μονός |
| 4  | [2,2]   | 2  | ζυγός |
| 5  | [5]     | 1  | μονός |
| 6  | [2,3]   | 2  | ζυγός |
| 7  | [7]     | 1  | μονός |     
| 8  | [2,2,2] | 3  | μονός |
| 9  | [3,3]   | 2  | ζυγός |
| 10 | [2,5]   | 2  | ζυγός |


Αν μετρήσουμε τώρα το πλήθος από αριθμούς με μονό πλήθος παραγόντων, θα δούμε ότι είναι 5 (το 2, το 3, το 5, το 7 και το 8). Άρα 5 από τους 10 αριθμούς έχουν μονό πλήθος από παράγοντες, άρα ο ζητούμενος λόγος είναι: 5/10 = 0.5. Συνεπώς θα πρέπει:

```python
print (f(10)) # Τυπώνει 0.5  
```

Σημείωση: Θεωρούμε ότι το 0 είναι ζυγός αριθμός.

### Άσκηση 40
(Συνέχεια της άσκησης 39)

Ποιος είναι ο μικρότερος αριθμός ο οποίος να είναι μεγαλύτερος από 100 για τον οποίο η συνάρτηση της άσκησης 39 επιστρέφει 0.5 ; 

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει την απάντηση στο παραπάνω ερώτημα. 

Σημείωση (εγκυκλοπαιδική): Προφανώς θα αναρωτιέστε, ποιος και γιατί ασχολείται με αυτά τα "ερωτήματα". Το ερώτημα του μονού/ζυγού πλήθους από παράγοντες απασχολεί τους μεγαλύτερους μαθηματικούς εδώ και πολλά χρόνια. Ο George Pólya το 1919 [είπε](https://en.wikipedia.org/wiki/P%C3%B3lya_conjecture) ότι αυτός ο λόγος είνα μεγαλύτερος ή ίσος με το 0.5 για όλους τους θετικούς ακέραιους αριθμούς. Για 40 χρόνια κανείς δεν τον αμφισβήτησε, ώσπου τι 1958 ο C. Brian Haselgrove απέδειξε ότι ο λόγος αυτός είναι μικρότερος από 0.5 για έναν αριθμό "κοντά" στο 1.845 × 10<sup>361</sup>. Το 1980 βρέθηκε ο μικρότερος αριθμός τέτοιος ώστε η συνάρτηση της άσκησης 39 να επιστρέφει αριθμό μικρότερο του 0.5. Ο αριθμός αυτός είναι ο 906,150,257. Όσον αφορά το "γιατί" σκεφτείτε ότι αν θεωρήσουμε ότι η κατανομή των παραγόντων είναι τυχαία, τότε ο λόγος αυτός θα είναι 0.5 για πολύυυ μεγάλους αριθμούς. Αν δεν είναι 0.5  σημαίνει ότι για "κάποιο λόγο" υπάρχουν περισσότεροι αριθμοί με μονό πλήθος από παράγοντες από ότι με ζυγούς (ή το αντίθετο). Άρα υπάρχει κάποια "αιτία" για αυτή την ανισοκατανομή. Μία συνέπεια αυτής της αιτίας θα είναι ότι επηρεάζει τη κατανομή των πρώτων αριθμών. Αν βρεθεί αυτή η αιτία σημαίνει ότι μπορούμε "εύκολα" να κατασκευάσουμε μεγάλους πρώτους αριθμούς, κάτι που [προς το παρών δεν μπορεί να γίνει](https://en.wikipedia.org/wiki/Generation_of_primes) και θα έχει τεράστιες συνέπεις στη κρυπτογραφεία.


### Άσκηση 41
Έστω το παρακάτω dictionary:

```python
d = {
 'DTO1E': [7, 13, 10, 5, 5, 8, 6, 8, 9, 12, 5, 5, 14, 15, 15, 5, 13, 6, 5, 8],
 'ZFT5Q': [8, 13, 9, 14, 12, 11, 9, 14, 12, 5, 9, 15, 6, 9],
 '53SDW': [5, 9, 13, 9, 5, 13, 14, 13, 14, 12, 12, 5, 14, 14, 11, 14],
 'GOFAD': [6, 7, 8, 8, 11, 5, 12, 8, 11, 5, 15],
 '8H65O': [14, 6, 10, 15, 9, 7, 12, 10, 9, 11, 6, 6, 6, 11, 10, 5, 11, 12],
 'P86CG': [7, 15, 12, 15, 13, 11, 15, 7, 15, 7, 14, 8, 10, 10, 8, 11, 8, 14, 11],
 '7A1EH': [5, 11, 9, 13, 14, 8, 15, 5, 10, 15, 12, 10, 8, 11, 8, 14, 11],
 'KR7FS': [7, 8, 11, 11, 14, 13, 15, 14, 9, 15, 9, 9, 10, 6, 15],
 '7L5J0': [12, 7, 14, 5, 8, 6, 11, 13, 14, 15, 5, 15, 12, 7, 11, 8],
 'M3JQ7': [10, 12, 15, 13, 13, 14, 6, 9, 13, 11, 5, 8, 10, 10, 5, 5],
 'UI0FX': [8, 9, 7, 9, 11, 7, 12, 11, 15, 9, 7, 5, 14, 9, 10, 10, 13, 7, 13],
 '2UDZT': [6, 8, 6, 6, 14, 6, 11, 9, 11, 9, 6, 6, 10, 14],
 'GM5ED': [6, 15, 10, 6, 6, 6, 15, 7, 11, 12],
 'E4WQO': [6, 5, 10, 7, 5, 13, 14, 5, 10, 12, 8, 13, 10],
 'D4XJ8': [9, 8, 7, 11, 15, 11, 12, 10, 11, 13, 8, 15, 6, 9, 14, 13, 14, 13],
 'YTKP3': [8, 12, 11, 15, 9, 10, 15, 13, 14, 5, 8, 9, 10, 13, 11, 10, 5, 5],
 'Q32C8': [14, 7, 11, 12, 11, 8, 7, 10, 15, 8, 12, 9, 11],
 '3F9AK': [5, 14, 6, 5, 14, 15, 14, 15, 13, 9, 7, 11, 5],
 'PMJ7T': [5, 5, 6, 13, 8, 8, 5, 8, 10, 7],
 '40ZOG': [5, 11, 5, 9, 13, 14, 6, 13, 8, 13, 14, 11, 9],
}
```

Σε αυτό το dictionary τα κλειδιά είναι strings τα οποία αναπαριστούν ονόματα γονιδίων (τυχαία) και οι τιμές είναι λίστες που αναπαριστούν πόσες μεταλλάξεις έχει το κάθε exon του γονιδίου (επίσης τυχαίοι αριθμοί). Για παράδειγμα:

Το 5ο exon του γονιδίου `M3JQ7` έχει 13 μεταλλάξεις:

```python
print (d['M3JQ7'][4]) # Τυπώνει 13
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary με την ίδια δομή όπως το d. Η συνάρτηση θα πρέπει να επιστρέφει το γονίδιο που έχει τα περισσότερα exons. Δηλαδή θα πρέπει:

```python
print (f(d)) # Τυπώνει ένα string με την απάντηση
```

### Άσκηση 42

Θεωρείστε το ίδιο dictionary με την άσκηση 41. 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary με την ίδια δομή όπως το d. Η συνάρτηση θα πρέπει να επιστρέφει το γονίδιο που έχει τις λιγότερες μεταλλάξεις (**προσοχή!** όχι τα λιγότερα exons). Δηλαδή θα πρέπει:

```python
print (f(d)) # Τυπώνει ένα string με την απάντηση
```

### Άσκηση 43
Θεωρείστε το ίδιο dictionary με την άσκηση 41. 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary με την ίδια δομή όπως το d. Η συνάρτηση θα πρέπει να επιστρέφει μία λίστα η οποία περιέχει τα γονίδια ταξινομημένα με βάση το πλήθος των exon που έχουν. Η ταξινόμηση θα ξεκινάει από το γονίδιο με το μικρότερο πλήθος από exons προς το γονίδιο με το μεγαλύτερο πλήθος από exons. Δηλαδή θα πρέπει:

```python
print (f(d)) # Τυπώνει μία λίστα με την απάντηση
```

### Άσκηση 44
Θεωρείστε το ίδιο dictionary με την άσκηση 41. 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary με την ίδια δομή όπως το d. Η συνάρτηση θα πρέπει να επιστρέφει μία λίστα η οποία περιέχει τα γονίδια ταξινομημένα με βάση το πλήθος των μεταλλάξεων που έχουν. Η ταξινόμηση θα ξεκινάει από το γονίδιο με το μεγαλύτερο πλήθος από μεταλλάξεις προς το γονίδιο με το μικρότερο πλήθος από μεταλλάξεις. Δηλαδή θα πρέπει:

```python
print (f(d)) # Τυπώνει μία λίστα με την απάντηση
```

### Άσκηση 45

Θεωρείστε το ίδιο dictionary με την άσκηση 41. 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary με την ίδια δομή όπως το d. Η συνάρτηση θα πρέπει να επιστρέφει το πλήθος από γονίδια των οποίων το πλήθος από μεταλλάξεις είναι μικρότερο από 100. Δηλαδή η συνάρτησή σας θα πρέπει να επιστρέφει έναν αριθμό:

```python
print (f(d)) # Τυπώνει έναν αριθμό με την απάντηση 
```

### Άσκηση 46

Θεωρείστε το ίδιο dictionary με την άσκηση 41. 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary με την ίδια δομή όπως το d. Η συνάρτηση θα πρέπει να επιστρέφει το άθροισμα όλων των exons τα οποία έχουν 5,6 ή 7 μεταλλάξεις. Δηλαδή η συνάρτησή σας θα πρέπει να επιστρέφει έναν αριθμό:

```python
print (f(d)) # Τυπώνει έναν αριθμό με την απάντηση 
```

### Άσκηση 47
Θεωρείστε το ίδιο dictionary με την άσκηση 41. 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary με την ίδια δομή όπως το d. Η συνάρτηση θα πρέπει να επιστρέφει το γονίδιο που έχει το δεύτερο μεγαλύτερο άθροισμα μεταλλάξεων. Δηλαδή θα πρέπει:

```python
print (f(d)) # Τυπώνει ένα string με την απάντηση
```

### Άσκηση 48
Θεωρείστε το ίδιο dictionary με την άσκηση 41. 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary με την ίδια δομή όπως το d. Η συνάρτηση θα πρέπει να επιστρέφει ένα dictionary όπου τα κλεδιά θα είναι τα ονόματα των γονιδίων και οι τιμές θα είναι ο μέσος όρος των μεταλλάξεων που έχουν όλα τα exons του. 

Για παράδειγμα αν ένα γονίδιο έχει τις εξής μεταλλάξεις στα exons του: `[1,5,8]`. Τότε ο μέσος όρος είναι `(1+5+8)/3 = 14/3`. Δηλαδή θα πρέπει:

```python
print (f(d)) # Τυπώνει ένα dictionary με την απάντηση 
```

### Άσκηση 49
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει ένα dictionary όπου σαν κλειδιά θα έχει όλους τους αριθμούς από το 100 μέχρι και το 200. Οι τιμές του κάθε κλειδιού θα είναι μία λίστα με τους παράγοντές του. Ο παράγοντας ενός αριθμού Ν είναι όλοι οι αριθμοί που τον διαιρούν ακριβώς, εκτός από το 1 και τον εαυτό του. Για παράδειγμα όλοι οι παράγοντες του 120 είναι: `[2, 3, 4, 5, 6, 8, 10, 12, 15, 20, 24, 30, 40, 60,]`

Δηλαδή θα πρέπει:
```python
print (f()) # Τυπώνει ένα dictionary
```

### Άσκηση 50

Συμπληρώστε τις τελίτσες παρακάτω:

```python
f = lambda ....
```

Έτσι ώστε όταν κάνω:

```python
print ( f(d) )
```

Να τυπώνει αυτό που ζητάει η άσκηση 42. 

Σημείωση: Απαγορεύεται να χρησιμοποιήσετε τη συνάρτηση της άσκησης 42 (ή οποιαδήποτε άλλη συνάρτηση πέρα από αυτές της python). Αυτό γιατί μία προφανής λύση θα ήταν: `f = lambda d : f_42(d)`

### Άσκηση 51
Μέσα από την εφαρμογή notepad (ή κάτι παρόμοιο) δημιουργήστε ένα αρχείο με το όνομα `ask_51.txt` με το εξής περιεχόμενο:

```text
gene_1=1,4,5,6,7,8,4
gene_2=7,6,3,4,9,8,5,4
gene_3=8,7,3,4,7,8,9,1
gene_4=1,7,6,5,9,8,7
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο το όνομα ενός αρχείου. Το αρχείο θα πρέπει να έχει την ίδια δομή όπως το `ask_51.txt` (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα πρέπει να επιστρέφει ένα dictionary όπου τα κλειδιά θα είναι τα ονόματα των γονιδίων και οι τιμές μία λίστα με τις τιμές. Για παράδειγμα θα πρέπει:

```python
print (f('ask_51.txt'))
```


Θα τυπώνει το εξής dictionary:

```python
{
    'gene_1' : [1,4,5,6,7,8,4],
    'gene_2' : [7,6,3,4,9,8,5,4],
    'gene_3' : [8,7,3,4,7,8,9,1],
    'gene_4' : [1,7,6,5,9,8,7],
}

```


### Άσκηση 52
Μέσα από την εφαρμογή notepad (ή κάτι παρόμοιο) δημιουργήστε ένα αρχείο με το όνομα `ask_52.txt` με το εξής περιεχόμενο:

```text
gene_1:exons=7,mutations=10
gene_2:exons=3,mutations=6
gene_3:exons=3,mutations=9
gene_4:exons=9,mutations=13
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο το όνομα ενός αρχείου. Το αρχείο θα πρέπει να έχει την ίδια δομή όπως το `ask_52.txt` (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα πρέπει να επιστρέφει ένα dictionary όπου τα κλειδιά θα είναι τα ονόματα των γονιδίων και οι τιμές θα είναι dictionaries με κλειδιά τα `exons`, `mutations` και τιμές οι αντίστοιχες τιμές του αρχείου. Για παράδειγμα θα πρέπει:

```python
print (f('ask_52.txt'))
```


Θα τυπώνει το εξής dictionary:

```python
{
    'gene_1' : {'exons': 7, 'mutations': 10},
    'gene_2' : {'exons': 3, 'mutations': 6},
    'gene_3' : {'exons': 3, 'mutations': 9},
    'gene_4' : {'exons': 9, 'mutations': 13},
}
```


### Άσκηση 53
Μέσα από την εφαρμογή notepad (ή κάτι παρόμοιο) δημιουργήστε ένα αρχείο με το όνομα `ask_53.txt` με το εξής περιεχόμενο:

```text
gene_1:exons=7|4|1,mutations=10
gene_2:exons=8|6|2,mutations=6
gene_3:exons=9|10|3,mutations=9
gene_4:exons=1|5|1,mutations=13
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο το όνομα ενός αρχείου. Το αρχείο θα πρέπει να έχει την ίδια δομή όπως το `ask_53.txt` (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα πρέπει να επιστρέφει ένα dictionary όπου τα κλειδιά θα είναι τα ονόματα των γονιδίων και οι τιμές θα είναι dictionaries με κλειδιά τα `exons` και `mutations`. Για το `exons` οι τιμές πρέπει να είναι λίστες. Για παράδειγμα θα πρέπει:

```python
print (f('ask_53.txt'))
```


Θα τυπώνει το εξής dictionary:

```python
{
    'gene_1' : {'exons': [7,4,1], 'mutations': 10},
    'gene_2' : {'exons': [8,6,2], 'mutations': 6},
    'gene_3' : {'exons': [9,10,3], 'mutations': 9},
    'gene_4' : {'exons': [1,5,1], 'mutations': 13},
}
```



### Άσκηση 54
Μέσα από την εφαρμογή notepad (ή κάτι παρόμοιο) δημιουργήστε ένα αρχείο με το όνομα `ask_54.txt` με το εξής περιεχόμενο:

```text
gene_1:disease_8,disease_5,disease_1,disease_3
gene_2:disease_6,disease_1,disease_9
gene_3:disease_1,disease_4,disease_10,disease_2
gene_4:disease_3,disease_2
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο το όνομα ενός αρχείου. Το αρχείο θα πρέπει να έχει την ίδια δομή όπως το `ask_54.txt` (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα πρέπει να επιστρέφει ένα dictionary όπου τα κλειδιά θα είναι τα ονόματα των ασθενειών (disease_XXX) και οι τιμές θα είναι λίστες με όλα τα ονόματα γονίδιων (gene_XXX) οι οποίες έχουν συσχετιστεί με αυτές. Για παράδειγμα θα πρέπει:

```python
print (f('ask_54.txt'))
```


Θα τυπώνει το εξής dictionary:

```python
{
    'disease_1' : ['gene_1', 'gene_2', 'gene_3'],
    'disease_2' : ['gene_3', 'gene_4'],
    'disease_3' : ['gene_1', 'gene_4'],
    'disease_4' : ['gene_3']
    'disease_5' : ['gene_1'],
    'disease_6' : ['gene_2'],
    'disease_8' : ['gene_1', 'gene_2', 'gene_3'],
    'disease_9' : ['gene_2'],
    'disease_10' : ['gene_3'],
}
```



### Άσκηση 55
Μέσα από την εφαρμογή notepad (ή κάτι παρόμοιο) δημιουργήστε ένα αρχείο με το όνομα `ask_55.txt` με το εξής περιεχόμενο:


```
|========|============|============|============|============|============|
|  DATA  | Species_KL | Species_LM | Species_MN | Species_NO | Species_OP |
|========|============|============|============|============|============|
| Env_7  |       0    |     1      |     1      |     2      |     1      |
| Env_8  |       1    |     0      |     2      |     0      |     1      |
| Env_17 |       3    |     0      |     1      |     1      |     1      |
| Env_62 |       0    |     2      |     1      |     0      |     0      |
| Env_19 |       1    |     2      |     3      |     1      |     0      |
| Env_51 |       2    |     1      |     2      |     1      |     2      |
| Env_81 |       1    |     0      |     0      |     1      |     1      |
| Env_18 |       0    |     0      |     3      |     1      |     0      |
|========|============|============|============|============|============|
```

Το αρχείο αυτό περιέχει τη καταμέτρηση του πλήθους 5 διαφορετικών ειδών (Species...) σε 8 διαφορετικά περιβάλλονα (Env....). Για παράδειγμα υπάρχουν 2 `Species_MN` στο περιβάλλον `Env_51`. Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο το όνομα ενός αρχείου το οποίο θα έχει την ίδια δομή όπως το `ask_55.txt` (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα επιστρέφει το περιβάλλον το οποίο έχει το μεγαλύτερο άθροισμα από όλα τα είδη. Για παράδειγμα θα πρέπει:

```python
print (f('ask_55.txt')) # Τυπώνει: Env_51  (To Env_51 έχει συνολικά 8 είδη, κανένα άλλο περιβάλλον δεν έχει μεγαλύτερο άθροισμα από είδη)
```



### Άσκηση 56
Μέσα από την εφαρμογή notepad (ή κάτι παρόμοιο) δημιουργήστε ένα αρχείο με το όνομα `ask_56.txt` με το εξής περιεχόμενο:


```
|========|============|============|============|============|============|
|  DATA  | Species_KL | Species_LM | Species_MN | Species_NO | Species_OP |
|========|============|============|============|============|============|
| Env_7  |       0    |     1      |     1      |     2      |     1      |
| Env_8  |       1    |     0      |     2      |     0      |     1      |
| Env_17 |       3    |     0      |     1      |     1      |     1      |
| Env_62 |       0    |     2      |     1      |     0      |     0      |
| Env_19 |       1    |     2      |     3      |     1      |     0      |
| Env_51 |       2    |     1      |     2      |     1      |     2      |
| Env_81 |       1    |     0      |     0      |     1      |     1      |
| Env_18 |       0    |     0      |     3      |     1      |     0      |
|========|============|============|============|============|============|
```

Το αρχείο αυτό περιέχει τη καταμέτρηση του πλήθους 5 διαφορετικών ειδών (Species...) σε 8 διαφορετικά περιβάλλονα (Env....). Για παράδειγμα υπάρχουν 2 `Species_MN` στο περιβάλλον `Env_51`. Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο το όνομα ενός αρχείου το οποίο θα έχει την ίδια δομή όπως το `ask_56.txt` (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα επιστρέφει το είδος το οποίο έχει το μεγαλύτερο άθροισμα σε όλα τα περιβάλλοντα. Για παράδειγμα θα πρέπει:

```python
print (f('ask_56.txt')) # Τυπώνει: Species_MN  (υπάρχουν συνολικό 13 Species_MN σε όλα τα περιβάλλοντα και κανένα άλλο είδος δεν έχει μεγαλύτερο άθροισμα)
```



### Άσκηση 57

Μέσα από την εφαρμογή notepad (ή κάτι παρόμοιο) δημιουργήστε ένα αρχείο με το όνομα `ask_57.txt` με το εξής περιεχόμενο:

```text
gene_1:exons=7,mutations=10
gene_2:exons=3,mutations=6
gene_3:exons=3,mutations=9
gene_4:exons=9,mutations=13
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 παράμετρους. Η πρώτη θα είναι το όνομα ενός αρχείο με την ίδια δομή όπως το `ask_57.txt` (δεν χρειάζεται να το ελέγξετε αυτό). Η δεύτερη θα είναι το όνομα ενός αρχείο το οποίο δεν θα υπάρχει (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση διαβάζει το αρχείο της πρώτης παραμέτρου και θα πρέπει να φτιάχνει ένα αρχείο με το όνομα της δεύτερης παραμέτρου. Το αρχείο αυτό θα έχει την ίδια πληροφορία αλλά δομημένη με τον παρακάτω τρόπο:

```text
genes:gene_1,gene_2,gene_3,gene_4
exons:7,3,3,9
mutations:10,6,9,13
```

Για παράδειγμα θα πρέπει:

```python

f('ask_57.txt', 'ask_57_new.txt')

with open('ask_57_new.txt') as f:
    for l in f:
        print (l.strip())

```

Τυπώνει:

```text
genes:gene_1,gene_2,gene_3,gene_4
exons:7,3,3,9
mutations:10,6,9,3
```

Σημείωση: Εννοείται ότι για να ελέγξω την υλοποίησή σας εγώ θα βάλω διαφορετικό αρχείο στη 1η παράμετρο, αλλά με την ίδια δομή. Το αρχείο μπορεί να έχει περισσότερα (ή λιγότερα) από 4 γονίδια, αλλά πάντα θα έχει exons και mutations για το κάθε γονίδιο.


### Άσκηση 58
(το αντίθετο της άσκησης 57)

Μέσα από την εφαρμογή notepad (ή κάτι παρόμοιο) δημιουργήστε ένα αρχείο με το όνομα `ask_58.txt` με το εξής περιεχόμενο:

```text
genes:gene_1,gene_2,gene_3,gene_4
exons:7,3,3,9
mutations:10,6,9,13
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 παράμετρους. Η πρώτη θα είναι το όνομα ενός αρχείο με την ίδια δομή όπως το `ask_58.txt`. Η δεύτερη θα είναι το όνομα ενός αρχείο το οποίο δεν θα υπάρχει (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα διαβάζει το αρχείο της πρώτης παραμέτρου και θα πρέπει να φτιάχνει ένα αρχείο με το όνομα της δεύτερης παραμέτρου. Το αρχείο αυτό θα έχει την ίδια πληροφορία αλλά δομημένη με τον παρακάτω τρόπο:


```text
gene_1:exons=7,mutations=10
gene_2:exons=3,mutations=6
gene_3:exons=3,mutations=9
gene_4:exons=9,mutations=13
```


Για παράδειγμα θα πρέπει:

```python

f('ask_58.txt', 'ask_58_new.txt')

with open('ask_58_new.txt') as f:
    for l in f:
        print (l.strip())

```

Τυπώνει:

```text
gene_1:exons=7,mutations=10
gene_2:exons=3,mutations=6
gene_3:exons=3,mutations=9
gene_4:exons=9,mutations=13
```

Σημείωση: Εννοείται ότι για να ελέγξω την υλοποίησή σας εγώ θα βάλω διαφορετικό αρχείο στη 1η παράμεοτρο, αλλά με την ίδια δομή. Το αρχείο μπορεί να έχει περισσότερα (ή λιγότερα) από 4 γονίδια, αλλά πάντα θα έχει exons και mutations για το κάθε γονίδιο.



### Άσκηση 59
Σε αυτό το link: https://www.dropbox.com/s/s4gf6lijg508yuy/variant_associations.tsv?dl=1 υπάρχει ένα αρχείο με διάφορες πληροφορίες για μεταλλάξεις οι οποίες έχουν συσχετιστεί με ασθένεις. Το αρχείο προέρχεται από τη βάση δεδομένων [DisGenNET](https://www.disgenet.org/). Οι πρώτες 5 γραμμές του αρχείου είναι:

```text
snpId   class   chromosome  position    most_severe_consequence DSI DPI NofDiseases NofPmids
rs1000005   snv 21   33060745   intron variant          1   1
rs10000770  snv 4   142693109   intron variant  1   0.04    1   1
rs1000091588    snv 11   68935374   stop gained 1   0.12    1   1
rs1000096   snv 4    38691214   intron variant          1   1
```

Όπως παρατηρούμε η πρώτη γραμμή περιέχει μία επικεφαλίδα με τους τίτλους της κάθε στήλης. Οι στήλες χωρίζονται με τον χαρακτήρα tab (`\t`), οπότε θα χρειαατεί να κάνετε `line.split('\t')` για να πάρετε μία λίστα με όλα τα πεδία κάθε γραμμής. Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο τη τοποθεσία (path) του αρχείου. Η συνάρτηση θα επιστρέφει το πλήθος των μεταλλάξεων (ή αλλιώς των γραμμών) για τις οποίες η τιμη της στήλης `most_severe_consequence` είναι `3 prime UTR variant`. 


Για παράδειγμα θα πρέπει:

```python
print (f('variant_associations.tsv')) # Τυπώνει έναν αριθμό
```

* Σημείωση 1: απαγορεύεται να κάνετε import κάτι (p.x. `import csv`)
* Σημείωση 2: απαγορεύεται να κάνετε `f.read()` ή `f.readlines()`, δηλαδή απαγορεύεται να διαβάσετε όλο το αρχείο απευθείας στη μνήμη. Θα πρέπει να το διαβάσετε γραμμή-γραμμή.

### Άσκηση 60
Θωρήστε το ίδιο αρχείο με την άσκηση 59. Φτιάξτε μία συνάρτηση η οποία θα παίρνει δύο παράμετρους. Η πρώτη θα είναι το όνομα του αρχείου της άσκησης 59 και η δεύτερη θα είναι το όνομα ενός αρχείου το οποίο δεν θα υπάρχει (δεν χρειάζεται να τα ελέγξετε αυτά). Η συνάρτηση θα φτιάχνει ένα αρχείο με το όνομα της 2ης παραμέτρου το οποίο θα έχει 26 γραμμές. Η πρώτη θα είναι μία επικεφαλίδα και θα ακολουθουν 25 γραμμές όσες και το πλήθος των χρωμοσωμάτων + το μιτοχονδριακό DNA (δηλαδή 1-22, Χ,Υ, ΜΤ). Κάθε γραμμή θα πρέπει να περιέχει το όνομα του χρωμοσώματος (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,Χ,Υ,ΜΤ) και το πλήθος από μεταλάξεις που έχει για τις οποίες η στήλη `most_severe_consequence` του αρχείου της 1ης παραμέτρου έχει τιμή: `3 prime UTR variant`. Το φορμάτ του αρχείου μπορεί να είναι όπως θέλετε εσείς αρκεί να υπάρχει η παραπάνω πληροφορία για κάθε γραμμή. Για παράδειγμα θα πρέπει:

```python
f('variant_associations.tsv'. 'ask_60_new.txt')

with open('ask_60_new.txt') as f:
    for l in f:
        print (l.strip())

```

Τυπώνει (προσοχή το 100 το έχω βάλει εδώ τυχαία, εσείς θα πρέπει να βάλετε τη σωστή τιμή για κάθε χρωμόσωμα):

```
Chromosome,3 prime UTR variants
1,100
2,100
3,100
4,100
5,100
6,100
7,100
8,100
9,100
10,100
11,100
12,100
13,100
14,100
15,100
16,100
17,100
18,100
19,100
20,100
21,100
22,100
X,100
Y,100
MT,100
```

* Σημείωση 1: απαγορεύεται να κάνετε import κάτι (p.x. `import csv`)
* Σημείωση 2: απαγορεύεται να κάνετε `f.read()` ή `f.readlines()`, δηλαδή απαγορεύεται να διαβάσετε όλο το αρχείο απευθείας στη μνήμη. Θα πρέπει να το διαβάσετε γραμμή-γραμμή.

### Άσκηση 61
Ας υποθέσουμε ότι τα κλειδιά στο παρακάτω dictionary περιέχουν τα ονόματα κάποιων ασθενειών και οι τιμές είναι σύνολα με τα μονοπάτια (pathways) με τα οποία οι ασθένειες έχουν συσχετιστεί. 

```python
diseases = {
 'disease_1':  {'pathway_4', 'pathway_1', 'pathway_5', 'pathway_6'},
 'disease_2':  {'pathway_2', 'pathway_8'},
 'disease_3':  {'pathway_10', 'pathway_5', 'pathway_6', 'pathway_8','pathway_9'},
 'disease_4':  {'pathway_10'},
 'disease_5':  {'pathway_2', 'pathway_1', 'pathway_8'},
 'disease_6':  {'pathway_9', 'pathway_1', 'pathway_8'},
 'disease_7':  {'pathway_9', 'pathway_5'},
 'disease_8':  {'pathway_9', 'pathway_5', 'pathway_3', 'pathway_10'},
 'disease_9':  {'pathway_9', 'pathway_1', 'pathway_4'},
 'disease_10': {'pathway_4', 'pathway_10'},
}

```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει δύο παράμετρους: ένα dictionary με την ίδια δομή όπως τα diseases (δεν χρειάζεται να το ελέγξετε αυτό) και το όνομα ενός pathway. H συνάρτηση θα πρέπει να επιστρέφει μία λίστα με τους κωδικούς της ασθένειας οι οποίες έχουν συσχετιστεί με αυτο το pathway. H συνάρτηση θα πρέπει να επιστρέφει τους ακέραιους κωδικούς της ασθένεας. Για παράδειγμα θα πρέπει:

```python
print (f(diseases, 'pathway_4')) # τυπώνει [1, 9, 10] 
```


* Σημείωση 1: Μην χρησιμοποιήσετε comprehension
* Σημείωση 2: Μην χρησιμοποιήσετε map / filter
* Σημείωση 3: Με τον τελεστή `in` μπορούμε να ελέγξουμε αν ένα αντικείμενο υπάρχει σε ένα σύνολο.

### Άσκηση 62
Υλοποιήσετε την άσκηση 61 με comprehension

### Άσκηση 63
Υλοποιήσετε την άσκηση 61 με map / filter, χωρίς lambda 

### Άσκηση 64 
Υλοποιήσετε την άσκηση 61 με map / filter, με lambda  

### Άσκηση 65 
Εκτός από το dictionary της άσκησης 61 έχουμε τώρα και το παρακάτω dictionary το οποίο περιέχει για κλειδιά τα ονόματα των pathways, και για τιμές σύνολα με τα γονίδια τα οποία περιέχουν:

```python
pathways = {
 'pathway_1': {'gene_4', 'gene_2', 'gene_7', 'gene_1', 'gene_5'},
 'pathway_2': {'gene_10', 'gene_4', 'gene_2'},
 'pathway_3': {'gene_2', 'gene_1', 'gene_5'},
 'pathway_4': {'gene_6', 'gene_9', 'gene_10', 'gene_2', 'gene_7'},
 'pathway_5': {'gene_6', 'gene_3', 'gene_10', 'gene_2', 'gene_7'},
 'pathway_6': {'gene_6', 'gene_3', 'gene_10', 'gene_2', 'gene_1', 'gene_5'},
 'pathway_7': {'gene_3', 'gene_5', 'gene_10', 'gene_8', 'gene_7'},
 'pathway_8': {'gene_10', 'gene_3'},
 'pathway_9': {'gene_3', 'gene_8', 'gene_5'},
 'pathway_10': {'gene_6', 'gene_3', 'gene_4', 'gene_7', 'gene_8'},
}
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρία ορίσματα: ένα dictionary με την ίδια δομή όπως το `diseases`, ένα dictionary με την ίδια δομή όπως το `pathways` και ένα string (δεν χρειάζεται να τα ελέγξετε αυτά). H συνάρτηση θα επιστρέφει **ένα σύνολο** με τους κωδικούς των diseases των οποίων τα pathways περιέχουν το γονίδιο με το όνομα της 3ης παραμέτρου. Για παράδειγμα θα πρέπει:

```python
print (f(diseases, pathways, 'gene_4')) 

# Τυπώνει:
 {'disease_1',
 'disease_10',
 'disease_2',
 'disease_3',
 'disease_4',
 'disease_5',
 'disease_6',
 'disease_8',
 'disease_9'}
``` 

Σημείωση: Μην την υλοποιήσετε με comprehension

### Άσκηση 66 
Υλοποίησετε την άσκηση 65 με comprehension

### Άσκηση 67 
(Το αντίθετο τηε άσκησης 65/66)

Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρία ορίσματα: ένα dictionary με την ίδια δομή όπως το `diseases`, ένα dictionary με την ίδια δομή όπως το `pathways` και ένα string (δεν χρειάζεται να τα ελέγξετε αυτά). H συνάρτηση θα επιστρέφει **ένα σύνολο** με τους κωδικούς των diseases των οποίων τα pathways **ΔΕΝ** περιέχουν το γονίδιο με το όνομα της 3ης παραμέτρου. Για παράδειγμα θα πρέπει:

```python
print (f(diseases, pathways, 'gene_4')) # Τυπώνει {'disease_7'}
```

Επεξήγηση: Το `disease_7` περιέχει το `pathway_9` και το `pathway_5`. Κανένα από αυτά τα δύο δεν έχει το `gene_4`

Σημείωση: Πρέπει να χρησιμοποιήσετε την υλοποίηση της ασκήσης 65 ή 66.

### Άσκηση 68
Φτιάξτε μία συνάρτηση η οποία θα παίρνει δύο ορίσματα: ένα dictionary με την ίδια δομή όπως το `diseases` και ένα dictionary με την ίδια δομή όπως το `pathways` (δεν χρειάζεται να τα ελέγξετε αυτά). Η συνάρτηση θα φτιάχνει και θα επιστρέφει ένα dictionary το οποίο θα έχει τα ίδια κλειδιά με το `diseases` και σαν τιμές θα έχει το πλήθος των διαφορετικών γονιδίων που υπάρχουν σε όλα τα pathways αυτού του disease. Για παράδειγμα θα πρέπει:

```python

print (f(diseases, pathways))

# Τυπώνει:
{'disease_1': 9,
 'disease_2': 4,
 'disease_3': 9,
 'disease_4': 5,
 'disease_5': 7,
 'disease_6': 8,
 'disease_7': 7,
 'disease_8': 9,
 'disease_9': 10,
 'disease_10': 8}

```

Σημείωση: Πρέπει να την υλοποίσετε με comprehension. Αν την υλοποιήσετε χωρίς comprehension θα βαθμολογηθεί με 7/10. 

### Άσκηση 69
Φτιάξτε έναν generator ο οποίος θα παίρνει δύο ορίσματα: ένα dictionary με την ίδια δομή όπως το `diseases` και ένα dictionary με την ίδια δομή όπως το `pathways` (δεν χρειάζεται να τα ελέγξετε αυτά). Ο generator θα κάνει.. generate tuples τα οποία θα περιέχουν τρία στοιχεία: ένα disease, ένα pathway και ένα gene. Για κάθε tuple θα πρέπει το pathway να ανήκει στο disease καθώς και το gene να ανήκει στο pathway. Για παράδειγμα θα πρέπει:

```python

g = f(diseases, pathways)

print (next(g)) # Τυπώνει ('disease_1', 'pathway_4', 'gene_6')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_4', 'gene_9')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_4', 'gene_10')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_4', 'gene_2')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_4', 'gene_7')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_1', 'gene_4')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_1', 'gene_2')

```

Σημείωση: Στη δική σας υλοποίηση, η σειρά μπορεί να είναι διαφορετική.


### Άσκηση 70 
Υλοποιήστε την άσκηση 69 με generator comprehension. Δηλαδή θα πρέπει:

```python

g = ( ...ΤΟ ΦΑΝΤΑΣΤΙΚΟ GENERATOR COMPREHENSION ΣΑΣ... )

print (next(g)) # Τυπώνει ('disease_1', 'pathway_4', 'gene_6')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_4', 'gene_9')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_4', 'gene_10')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_4', 'gene_2')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_4', 'gene_7')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_1', 'gene_4')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_1', 'gene_2')

```

## Ασκήσεις 71-80
**Για τις ασκήσεις με regular expression είναι υποχρεωτικό να δηλώνετε τα regular expressions ως [raw strings](https://www.digitalocean.com/community/tutorials/python-raw-string), υπάρχει και στις [σημειώσεις](notes/python_ser_iter_re.ipynb) μία σχετική επεξήγηση.**

### Άσκηση 71

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα string. Η συνάρτηση θα επιστρέφει μία λίστα με αριθμούς οι οποίοι δηλώνονται ως ποσοστά στο string. Για παράδειγμα θα πρέπει:

```python
# Source: https://pubmed.ncbi.nlm.nih.gov/35140399/ 
s='''
Clustered somatic mutations are common in cancer genomes and previous analyses reveal several types of clustered single-base substitutions, which include doublet- and multi-base substitutions1-5, diffuse hypermutation termed omikli6, and longer strand-coordinated events termed kataegis3,7-9. Here we provide a comprehensive characterization of clustered substitutions and clustered small insertions and deletions (indels) across 2,583 whole-genome-sequenced cancers from 30 types of cancer10. Clustered mutations were highly enriched in driver genes and associated with differential gene expression and changes in overall survival. Several distinct mutational processes gave rise to clustered indels, including signatures that were enriched in tobacco smokers and homologous-recombination-deficient cancers. Doublet-base substitutions were caused by at least 12 mutational processes, whereas most multi-base substitutions were generated by either tobacco smoking or exposure to ultraviolet light. Omikli events, which have previously been attributed to APOBEC3 activity6, accounted for a large proportion of clustered substitutions; however, only 16.2% of omikli matched APOBEC3 patterns. Kataegis was generated by multiple mutational processes, and 76.1% of all kataegic events exhibited mutational patterns that are associated with the activation-induced deaminase (AID) and APOBEC3 family of deaminases. Co-occurrence of APOBEC3 kataegis and extrachromosomal DNA (ecDNA), termed kyklonas (Greek for cyclone), was found in 31% of samples with ecDNA. Multiple distinct kyklonic events were observed on most mutated ecDNA. ecDNA containing known cancer genes exhibited both positive selection and kyklonic hypermutation. Our results reveal the diversity of clustered mutational processes in human cancer and the role of APOBEC3 in recurrently mutating and fuelling the evolution of ecDNA. There was a decrease of -4.5% <--  That was Alex's addition. 
'''

print (f(s)) # Τυπώνει: [16.2, 76.1, 31.0, -4.5]

```

Σημείωση: Είναι υποχρεωτικό να χρησιμοποιήσετε regular expressions.

### Άσκηση 72 
Ας υποθέσουμε ότι διαβάζετε αυτό το paper: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6629674/ . Αφού φτάνετε στο τέλος βλέπετε ότι περιέχει συμπληρωματικές πληροφορίες (supplementary information): https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6629674/bin/41467_2019_11217_MOESM1_ESM.pdf . Ανοίγετε αυτό το PDF και βλέπετε το "Supplementary Table 1" το οποίο πολύ θα θέλατε να το φέρνατε σε μορφή python. Επιλέγετε όλο το κείμενο του table και το κάνετε copy paste:

```python
s = '''
Candidatus Carsonella ruddii PV - γ-proteobacteria 16.56 159662 184
Buchnera aphidicola Cc (Cinara cedri) - γ-proteobacteria 20.1 422434 378
Candidatus Sulcia muelleri CARI - Bacteroidetes 21.13 276511 266
Buchnera aphidicola Bp - γ-proteobacteria 25.3 615980 541
Clostridium difficile CD196 + Firmicutes 28.56 4110554 3805
Campylobacter jejuni 4031 - -proteobacteriaε 30.47 1669329 1711
Prochlorococcus marinus MIT 9312 - Cyanobacteria 31.21 1709204 2027
Staphylococcus aureus subsp. aureus NCTC 8325 + Firmicutes 32.87 2821361 2974
Bacillus anthracis Ames + Firmicutes 35.38 5227293 5844
Haemophilus influenzae Rd KW20 - γ-proteobacteria 38.15 1830138 1821
Helicobacter pylori 2017 - -proteobacteriaε 39.3 1548238 1682
Streptococcus pneumoniae D39 + Firmicutes 39.71 2046115 2217
Xenorhabdus nematophila ATCC19061 - γ-proteobacteria 44.15 4587917 4770
Yersinia pestis CO92 - γ-proteobacteria 47.64 4829855 4587
Escherichia coli K12 - γ-proteobacteria 50.79 4639675 4306
Neisseria meningitidis 053442 - β-proteobacteria 51.7 2153416 2034
Corynebacterium glutamicum ATCC 13032 + Actinobacteria 53.81 3309401 3223
Brucella abortus A13334 - α-proteobacteria 57.22 3286032 3566
Bifidobacterium longum NCC2705 + Actinobacteria 60.12 2260266 2049
Mycobacterium tuberculosis Beijing/NITR203 + Actinobacteria 65.61 4411128 4699
Pseudomonas aeruginosa PAO1 - γ-proteobacteria 66.56 6264404 5835
Burkholderia pseudomallei 1106b - β-proteobacteria 68.21 7224634 6990
Nocardia farcinica IFM 10152 + Actinobacteria 70.83 6292344 6283
Streptomyces griseus subsp. griseus NBRC 13350 + Actinobacteria 72.23 8545929 7547
Anaeromyxobacter dehalogenans 2CP-1 - δ-proteobacteria 74.72 5029329 4690
'''
```


Τώρα πολύ θα θέλατε, να φτιάξετε μία python λίστα η οποία να περιέχει tuples με τα 4 στοιχεία κάθε γραμμής. Φτιάξτε **ένα** regular expression το οποίο να κάνει ακριβώς αυτό. Η υλοποίησή σας θα πρέπει να είναι τέτοια όταν κάνω:

```python
for x in re.findall('...ΥΠΕΡΤΕΛΕΙΟ REGULAR EXPRESSION...', s):
    print (x)
```

Να τυπώνει:

```python
('Candidatus Carsonella ruddii PV', '-', 'γ-proteobacteria', '16.56', '159662', '184')
('Buchnera aphidicola Cc (Cinara cedri)', '-', 'γ-proteobacteria', '20.1', '422434', '378')
('Candidatus Sulcia muelleri CARI', '-', 'Bacteroidetes', '21.13', '276511', '266')
('Buchnera aphidicola Bp', '-', 'γ-proteobacteria', '25.3', '615980', '541')
('Clostridium difficile CD196', '+', 'Firmicutes', '28.56', '4110554', '3805')
('Campylobacter jejuni 4031', '-', '-proteobacteriaε', '30.47', '1669329', '1711')
('Prochlorococcus marinus MIT 9312', '-', 'Cyanobacteria', '31.21', '1709204', '2027')
('Staphylococcus aureus subsp. aureus NCTC 8325', '+', 'Firmicutes', '32.87', '2821361', '2974')
('Bacillus anthracis Ames', '+', 'Firmicutes', '35.38', '5227293', '5844')
('Haemophilus influenzae Rd KW20', '-', 'γ-proteobacteria', '38.15', '1830138', '1821')
('Helicobacter pylori 2017', '-', '-proteobacteriaε', '39.3', '1548238', '1682')
('Streptococcus pneumoniae D39', '+', 'Firmicutes', '39.71', '2046115', '2217')
('Xenorhabdus nematophila ATCC19061', '-', 'γ-proteobacteria', '44.15', '4587917', '4770')
('Yersinia pestis CO92', '-', 'γ-proteobacteria', '47.64', '4829855', '4587')
('Escherichia coli K12', '-', 'γ-proteobacteria', '50.79', '4639675', '4306')
('Neisseria meningitidis 053442', '-', 'β-proteobacteria', '51.7', '2153416', '2034')
('Corynebacterium glutamicum ATCC 13032', '+', 'Actinobacteria', '53.81', '3309401', '3223')
('Brucella abortus A13334', '-', 'α-proteobacteria', '57.22', '3286032', '3566')
('Bifidobacterium longum NCC2705', '+', 'Actinobacteria', '60.12', '2260266', '2049')
('Mycobacterium tuberculosis Beijing/NITR203', '+', 'Actinobacteria', '65.61', '4411128', '4699')
('Pseudomonas aeruginosa PAO1', '-', 'γ-proteobacteria', '66.56', '6264404', '5835')
('Burkholderia pseudomallei 1106b', '-', 'β-proteobacteria', '68.21', '7224634', '6990')
('Nocardia farcinica IFM 10152', '+', 'Actinobacteria', '70.83', '6292344', '6283')
('Streptomyces griseus subsp. griseus NBRC 13350', '+', 'Actinobacteria', '72.23', '8545929', '7547')
('Anaeromyxobacter dehalogenans 2CP-1', '-', 'δ-proteobacteria', '74.72', '5029329', '4690')
```


### Άσκηση 73
Έστω το string:
```python
s = '''
Secondary structure is known to be equally necessary to the functions of ribosomal RNAs (rRNAs) (128, 144, 164, 192), small nuclear RNAs (snRNAs) (39, 114), small nucleolar RNAs (snoRNAs) (44, 81, 82, 101, 127), and microRNAs (miRNAs) (19, 23, 92, 134, 145). Additionally, recent studies are beginning to demonstrate the importance of structure in long noncoding RNAs (lncRNAs) (129, 141, 174, 180) and messenger RNAs (mRNAs) (29, 49, 103, 149). Alex added this: (RNAs) (56) This is only to trick you (RNAs) (gg, tt) (RNAs) (123, aa) (RNAs) (123, aa (RNAs) (111 ,,).
'''
```

Παρατηρώ ότι έχει μέσα σε παρενθέσεις διάφορα είδη από RNAs και μετά μέσα σε παρενθέσεις λίστες με αριθμούς. Συμπληρώστε το παρακάτω regular expression ώστε όταν το τρέχω να τυπώνει τα είδη του RNA και ένα string με τις λίστες με τους αριθμούς (προσοχή, θα πρέπει να αpοφύγετε τις παγίδες που υπάρχουν στο τέλος του string!):

```python
for rna_kind, l in re.findall(r'..YOUR PRECIOUS REGULAR EXPRESSION HERE..', s)
    print (f'RNA={rna_kind}  list={l}')
```

Τυπώνει:

```
RNA=rRNAs  list=128, 144, 164, 192
RNA=snRNAs  list=39, 114
RNA=snoRNAs  list=44, 81, 82, 101, 127
RNA=miRNAs  list=19, 23, 92, 134, 145
RNA=lncRNAs  list=129, 141, 174, 180
RNA=mRNAs  list=29, 49, 103, 149
RNA=RNAs  list=56
```

Δίνεται εδώ το επίσημο documentation των regular expressions: https://docs.python.org/3/library/re.html

Σημείωση 1: Στη δική μου υλοποίηση έπρεπε να εφαρμόσω αυτό το οποίο δεν υπάρχει στις σημειώσεις:
> ```(?:...)```
> A non-capturing version of regular parentheses. Matches whatever regular expression is inside the parentheses, but the substring matched by the group cannot be retrieved after performing a match or referenced later in the pattern.

Μπορείτε να μεταβάλετε τον τρόπο που ελέγχεται το regular expressions θα πρέπει όμως να τυπώνει το ίδιο αποτέλεσμα. 

Σημείωση 2: Μπορείτε να βάλετε παρενθέσεις και άλλους "ειδικούς χαρακτήρες" σε regular expressions κάνοντάς τους escape με τον χαρακτήρα `\`. Π.χ.```'\('```.


### Άσκηση 74
Σε αυτό το link: https://www.dropbox.com/s/3my2injwaw0sj29/words_greek_normalized.txt?dl=1 υπάρχει ένα αρχείο με όλες τις ελληνικές λέξεις. Το αρχείο έχει επεξεργαστεί έτσι ώστε:
* Όλα τα κεφαλαία έχουν αντικατασταθεί με τα αντίστοιχα μικρά
* Όλοι οι τόνοι και διαλυτικά έχουν αντικατασταθεί με τα αντίστοιχα γράμματα χωρίς τόνους και διαλυτικά (π.χ. ά --> α, ϊ --> ι, ΐ --> ι)
* Το τελικό σίγμα (ς) έχει αντικατασταθεί με το σίγμα (σ)


Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο το path και το όνομα του αρχείου. Η συνάρτηση θα επιστρέφει τη μόνη ελληνική λέξη η οποία έχει 6 συνεχόμενα φωνήεντα και ξεκινάει με "ρ". 

* Σημείωση 1: απαγορεύεται να κάνετε: f.read() ή f.readlines() δηλαδή να φορτώσετε όλο το αρχείο στη μνήμη. Θα πρέπει να το διαβάσετε γραμμή-γραμμή.
* Σημείωση 2: Είναι υποχρεωτικό να χρησιμοποιήσετε **ένα** regular expression.


### Άσκηση 75
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα string της μορφής ([πηγή](http://rasp.zhanglab.net/download/), - HIV):
```python
s='ID=cds-AFJ52174.1;Parent=gene-tat2;Dbxref=NCBI_GP:AFJ52174.1;Name=AFJ52174.1;gbkey=CDS;gene=tat;product=tat protein;protein_id=AFJ52174.1'
```
Η συνάρτηση θα επιστρέφει 2 strings. Αυτό που ακολουθεί το `Parent=` και αυτό που ακολουθεί το `Name=`. Για παράδειγμα θα πρέπει:

```python
a,b = f(s)
print (a) # τυπώνει "gene-tat2"
print (b) # τυπώνει "AFJ52174.1"
```

Σημείωση: είναι υποχρεωτικό να χρησιμοποιήσετε **ένα** regular expression. 

### Άσκηση 76
Κατεβάστε το αρχείο `hg38.gff3.gz` από εδώ: http://rasp.zhanglab.net/download/. Μπρείτε να χρησιμοποιήσετε και αυτό το [link](http://rasp.zhanglab.net/api/downloadfile/?filetype=gff&filelist=hg38.gff3.gz). Μπορείτε να επεξεργαστείτε αυτό το αρχείο χωρίς να το αποσυμπιέσετε ως εξής:

```python
import gzip

c = 0
with gzip.open('/Users/admin/Downloads/hg38.gff3.gz', 'rb') as f:
    # Do whatever you want with file f!
    
    print ('First line:')
    print (f.readline().strip())
```

Το αρχείο περιέχει το γενετικό χάρτη του ανθρώπινου γονιδιώματος (που βρίσκονται τα γονίδια, exons, CDS, ...)

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν είσοδο το path του αρχείου `hg38.gff3.gz`. Η συνάρτηση θα πρέπει να επιστρέφει ένα dictionary όπου τα κλειδιά θα είναι όλα τα χρωμοσώματα (`chr1`, `chr2`, ...) και οι τιμές θα είναι το πληθος των γραμμών για αυτό το χρωμόσωμα για τις οποίες:
1. Η 2η στήλη είναι `ensembl`
2. H 3η στήλη είναι `lincRNA`

Το χρωμόσωμα βρίσκεται στη πρώτη στήλη. 

* Σημείωση 1: απαγορεύεται να κάνετε: f.read() ή f.readlines() δηλαδή να φορτώσετε όλο το αρχείο στη μνήμη. Θα πρέπει να το διαβάσετε γραμμή-γραμμή.
* Σημείωση 2: Είναι υποχρεωτικό να χρησιμοποιήσετε [defaultdict](https://docs.python.org/3/library/collections.html#collections.defaultdict)


### Άσκηση 77
Υλοποιήστε την άσκηση 76 χρησιμοποιώντας [Counter](https://docs.python.org/3/library/collections.html#collections.Counter)

* Σημείωση 1: Μην κάνετε f.read() ή f.readlines()
* Σημείωση 2: Δεν θα πρέπει γενικότερα κατά την υλοποίησή σας να βρίσκονται κάπου όλα τα δεδομένα του αρχείου μέσα στη μνήμη (hint: Generators..)

### Άσκηση 78
Υλοποιήστε την άσκηση 76 χρησιμοποιώντας [groupby](https://docs.python.org/3/library/itertools.html#itertools.groupby)

* Σημείωση 1: Μην κάνετε f.read() ή f.readlines()
* Σημείωση 2: Δεν θα πρέπει γενικότερα κατά την υλοποίησή σας να βρίσκονται κάπου όλα τα δεδομένα του αρχείου μέσα στη μνήμη (hint: Generators..)

### Άσκηση 79
Υλοποιήστε την άσκηση 76 χρησιμοποιώντας.. ότι άλλο θέλετε εκτός Counter, defaultdict και itertools (π.χ. μπορείτε να χρησιμοποιήσετε απλά dictionaries)

* Σημείωση 1: Μην κάνετε f.read() ή f.readlines()
* Σημείωση 2: Δεν θα πρέπει γενικότερα μέσα στην υλοποίησή σας να βρίσκονται όλα τα δεδομένα του αρχείου μέσα στη μνήμη.

### Άσκηση 80 
Έστω το αρχείο της άσκησης 74. Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο το path και το όνομα του αρχείου. Η συνάρτηση θα επιστρέφει ένα dictionary το οποίο για κλειδιά θα έχει όλα τα γράμματα της αλφαβήτα (μικρά). Οι τιμές θα είναι το πλήθος των λέξεων οι οποίες ξεκινάνε από το γράμμα του κλειδιού και όλα τα γράμματα στις ζυγές θέσεις (2η, 4η, 6η, ..) είναι φωνήεντα. 

* Σημείωση 1: είναι υποχρεωτικό να χρησιμοποιήσετε regular expressions και (Counter ή defaultdict ή itertools)
* Σημείωση 2: απαγορεύεται να φορτώσετε όλο το αρχείο στη μνήμη 

### Άσκηση 81
Φτιάξτε **ένα** αρχείο με το όνομα `ask_81.py` το οποίο θα παίρνει σαν παράμετρο 2 αριθμούς και θα τυπώνει το άθροισμά τους. Το αρχείο θα πρέπει να έχει μέσα μία συνάρτηση με το όνομα `add` η οποία θα παίρνει σαν παράμετρο 2 αριθμούς και θα επιστρέφει το άθροισμά τους. Θα πρέπει να μπορώ να χρησιμοποιήσω το αρχείο με 2 τρόπους:

Πρώτος: Από τη γραμμή εντολών. Για παράδειγμα αν γράψω:

```bash
python ask_81.py 5 8
```

Θα πρέπει να τυπώμει: 13. Είναι υποχρεωτικό για τον υπολογισμό του αθροίσματος να χρησιμοποιηθεί η συνάρτηση add. 


Δεύτερος: Από το jupyter. Για παράδειγμα θα πρέπει να μπορώ να γράψω:
```python
from ask_81 import add
print (add(5,8)) # Τυπώνει 13
```

Σημείωση: Στο μέιλ με τις ασκήσεις προσθέστε το αρχείο `ask_81.py` ως συνημμένο.

### Άσκηση 82
Λύστε την άσκηση 60 μέσω ενός προγράμματος το οποίο θα τρέχει από τη γραμμή εντολών. Το πρόγραμμα θα πρέπει να υπάρχει σε ένα αρχείο με το όνομα ask_82.py και θα πρέπει να δέχεται δύο παραμέτρους: Ο πρώτος θα είναι το path του αρχείου `variant_associations.tsv` και το δεύτερο το path του αρχείου το οποίο θα δημιουργείται. Για παράδειγμα θα πρέπει να μπορώ να τρέξω το αρχείο κάπως έτσι:

```bash
python ask_82.py /Users/admin/Downloads/variant_associations.tsv output.txt
```

Σημείωση: Στο μέιλ με τις ασκήσεις προσθέστε το αρχείο ask_82.py ως συνημμένο.

### Άσκηση 83
Σώστε τον παρακάτω κώδικα σε ένα αρχείο με το όνομα `ask_83.py` και αποθηκεύστε το στον ίδιο κατάλογο με αυτόν που δουλεύετε τις ασκήσεις. 

```python

def inv_sqaure(n):
    return 1/(n*n)

```

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα κάνει import τη συνάρτηση `inv_square` από το αρχείo `ask_83.py` και θα χρησιμοποιεί τη παρακάτω εξίσωση:

![img](https://wikimedia.org/api/rest_v1/media/math/render/svg/07cf884f66d93219f71af0011ba93fc61504a893)

Για να υπολογίσει το π όπως προκύπτει μετά το άθροισμα των 100 πρώτων όρων που παράγει η συνάρτηση `inv_square` (δηλαδή για n=1 μέχρι και n=100)

### Άσκηση 84
Φτιάξτε μία συνάρτηση η οποία παίρνει σαν παράμετρο δύο αριθμούς, έστω a και b.
* Αν κάποιος από τους δύο δεν είναι αριθμητικός (int ή float). Ρίχνει (δηλαδή κάνει raise) `TypeError` exception. 
* Αν ο δεύτερος είναι 0 ρίχνει `ZeroDivisionError` exception 
* Αν ο δεύτερος δεν διαρεί τον πρώτο (δηλαδή το υπόλοιπο της διαίρεσης είναι 0) ρίχνει `ValueError` exception
* Αν το αποτέλεσμα της διαίρεσης είναι αρνητικός αριθμός ρίχνει ένα exception με το μήνυμα: `Αρνητικό αποτέλεσμα`.
* Aν δεν συμβεί τίποτα από τα παραπάνω επιστρέφει το αποτέλεσμα της διαίρεσης `a/b`

Για παράδειγμα θα πρέπει:
```python
try:
    f(-2,1)
except Exception as e:
    print (e)

```
Τυπώνεi "αρνητικό αποτέλεσμα"


### Άσκηση 85
Φτιάξτε μία συνάρτηση η οποία θα "τεστάρει" τη συνάρτηση της άσκησης 84. Η συνάρτηση θα τρέχει τη συνάρτηση της άσκησης 84 με τα εξής ζευγάρια τιμών και θα τυπώνει είτε το αποτέλεσμα της συνάρτησης 84 (δηλαδή τι έκανε return) είτε το είδος του exception που πέταξε καθώς και το μήνυμα του exception
* a='mitsos', b=4
* a=4.3, b='maria'
* a=[1,2], b=5
* a=1, b=0
* a=1. b=2
* a=5, b=-1
* a=6, b=3 
* a=6, b=3.0 (Αυτό δεν πρέπει να πετάει exception από την 84) 



### Άσκηση 86
Φτιάξτε μία συνάρτηση η οποία δημιουργεί το [Cool S](https://en.wikipedia.org/wiki/Cool_S) σήμα:

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/7/79/%22Cool_S%22.svg/78px-%22Cool_S%22.svg.png)

### Άσκηση 87
Γράψτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο το path ενός αρχείου με την ίδια δομή σαν το `variant_associations.tsv` της άσκησης 59. Η συνάρτηση θα φτιάχνει ένα plot με κουκίδες. Κάθε κουκίδα θα είναι και μία μετάλλαξη (δηλαδή μία γραμμή του αρχείου). Στον Χ άξονα θα είναι η τιμή της στήλης `DSI` και τον Υ άξονα θα είναι η τιμή της στήλης `DPI`. Αγνοήστε τις μεταλλάξεις (γραμμές) που δεν έχουν τιμές `DPI` ή `DSI` τιμές. Δίνεται το πλότ που βγήκε σε μένα:

![img](https://i.imgur.com/jLmT4Ow.png)

### Άσκηση 88
Γράψτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο το path ενός αρχείου με την ίδια δομή σαν το `variant_associations.tsv` της άσκησης 59. Η συνάρτηση θα φτιάχνει ένα πλοτ όπου κάθε `3 prime UTR variant` θα είναι μία κουκίδα (αγνοήστε τις υπόλοιπες μεταλλάξεις). Στον Χ άξονα θα είναι ο αριθμός 1..22 ανάλογα με το χρωμόσωμα της μετάλλαξης, 23 για το Χ, 24 για το Υ και 25 για το ΜΤ. Στον άξονα Υ θα είναι η χρωμοσωμική θέση της μετάλλαξης. Δίνεται το plot που βγήκε σε μένα:

![img](https://i.imgur.com/DrIQje7.png)

### Άσκηση 89
Δίνεται ο παρακάτω κώδικας:

```python
import pandas as pd
from datetime import datetime, date
import re

def get_data():

    dfs = pd.read_html('https://en.wikipedia.org/wiki/Opinion_polling_for_the_May_2023_Greek_legislative_election')
    date_start = date(2019, 7, 7)
    data = []
    for x in dfs[0][1:].to_dict('records'):
        date_str = x[('Fieldwork date', 'Fieldwork date')]

        if pd.isna(date_str):
            continue

        try:
            ND = float(x[('ND', 'Unnamed: 3_level_1')])
            SYRIZA = float(x[('SYRIZA', 'Unnamed: 4_level_1')])
            PASOK = float(x[('PASOK', 'Unnamed: 5_level_1')])
            KKE = float(x[('KKE', 'Unnamed: 6_level_1')])
            EL = float(x[('EL', 'Unnamed: 7_level_1')])
            MERA25 = float(x[('MeRA25', 'Unnamed: 8_level_1')])
        except ValueError:
            continue 

        s = re.search(r'(\d+) (\D{3}) (\d{4})', date_str)
        assert s

        day = s.group(1)
        month = s.group(2)
        year = s.group(3)
        dt = datetime.strptime(f'{month} {day} {year}', '%b %d %Y')
        days = (dt.date() - date_start).days

        data.append({
            'days_since_7_jul_2019': days,
            'ND': ND,
            'SYRIZA': SYRIZA,
            'PASOK': PASOK,
            'KKE': KKE,
            'EL': EL,
            'MERA25': MERA25,
        })

    ret = pd.DataFrame(data).to_csv(index=False)
    
    return ret
```

Ο κώδικας αυτός επιστρέφει ένα string το οποίο περιέχει σε φορμάτ csv τα γκάλοπ που έγιναν στο μεσοδιάστημα των 2 τελευταίων εκλογών (7 Ιουλίου 2019 - 21 Μαΐου 2023). Φτιάξτε ένα plot με γραμμές, όπου στον άξονα Χ θα είναι οι τιμές της στήλης: `days_since_7_jul_2019`. Στον Y άξονα θα είναι οι αντίστοιχες τιμές των γκάλοπ για τα 6 κόμματα. Θα πρέπει να χρησιμοποιήσετε διαφορετικά χρώματα για κάθε κόμμα. 


### Άσκηση 90 
Φτιαξτε μία κλάση με το όνομα `Organism` το οποίο θα κωδικοποιεί έναν οργανισμό. Θα πρέπει κατά την αρχικοποίηση του οργανισμού να δηλώνεται η τιμή ενός ονόματος (string) και η τιμή ενός trait (αριθμητικό). Όταν κάνω print ένα αντικείμενο αυτής της κλάσης θα πρέπει να τυπώνονται και τα δύο. Για παράδειγμα θα πρέπει να μπορώ να γράφω:

```python
organism_1 = Organism('id_1', 178)
print (organism_1) # Τυπώνει 'Name: id_1  Trait: 178'
``` 

### Άσκηση 91
Προσθέστε στη κλάση `Organism` της άσκησης 90 τη κατάλληλη μέθοδο ώστε να μπορώ να εφαρμόσω τη πράξη της πρόσθεσης (+) μεταξύ δύο αντικειμένων της. Η πράξη `γ = α + β` θα εκπροσωπεί το γεγονός ότι τα αντικείμενα α και β κάναν απόγονο. Το όνομα του απογόνου θα είναι ή ένωση των ονομάτων τους με τον χαρακτήρα `+` όπου όμως θα υπάρχει ο χαρακτήρας `(` στην αρχή και ο χαρακτήρας `)` στο τέλος. Η τιμή του trait του απογόνουν θα βγαίνει από αυτόν τον τύπο `trait_απογόνου = (Α * trait_γονέα_1 + Β * trait_γονέα_2)`, όπου τα Α και Β θα είναι τυχαίες τιμές οι οποίες παράγονται από τη παρακάτω συνάρτηση:


```python
import random
def get_random_factor():
    return random.gauss(0.5, 0.05)
```
Για παράδειγμα θα πρέπει να μπορώ να γράφω:

```python
a = Organism('id_1', 100)
b = Organism('id_2', 200)
c = a+b
print (c) # Τυπώνει: Name: (id_1+id_2) Trait: 158 
# To 158 είναι τυχαία τιμή η οποία προκύπτει από τη πράξη: 100 * get_random_factor() + 200 * get_random_factor()
# σε εσάς θα βγάζει κάτι διαφορετικό.
```

### Άσκηση 92
Φτιάξτε μία κλάση με το όνομα Group η οποία θα εκπροσωπεί ένα σύνολο από οργανισμούς. Η αρχικοποίηση ενός αντικειμένου αυτής της κλάσης θα γίνεται δίνοντας τρεις τιμές:
* Το πλήθος των αντικειμένων (Ν)
* Ο μέσος όρος του trait που θα έχουν (mean)
* H τυπική απόκλιση (standard deviation) των trait.

Για παράδειγμα θα πρέπει να μπορώ να γράφω:
```python
g = Group(N=80, mean=100, sigma=3)
```

Η τιμή του name του κάθε οργανισμού θα παράγεται από όποια συνάρτηση θέλετε εσείς αρκεί κάθε οργανισμός να έχει διαφορετικό name.

Η τιμή του trait του κάθε οργανισμού θα παράγεται από τη συνάρτηση:
```python
import random
random.gauss(mean, sigma) # Αυτό παράγει τιμές με βάση τη κανονική κατανομή 
```

Προσθέστε επίσης τις κατάλληλες μεθόδους ώστε:
1. Να μπορώ να εφαρμόσω τη συνάρτηση len, η οποία θα μου δίνει το πλήθος από οργανισμούς που έχει το group και..
2. Να μπορώ να κάνω iterate σε όλο το group. Για παράδειγμα θα πρέπει να μπορώ να γράφω:

```python
g = Group(N=10, mean=170, sigma=5)
print (len(g)) # Τυπώνει 10

for organism in g:
   print (organism)

```

τυπώνει κάτι σαν:

```
Name=id_1  Trait:172.0145522422859
Name=id_2  Trait:170.3626042208354
Name=id_3  Trait:174.36224081998446
Name=id_4  Trait:170.1644383356308
Name=id_5  Trait:164.54067856290797
Name=id_6  Trait:164.8260819601845
Name=id_7  Trait:171.31281307625378
Name=id_8  Trait:169.78332813504014
Name=id_9  Trait:165.6178738634416
Name=id_10  Trait:178.74336847624937
```

Προσθέστε επίσης τη μέθοδο `average` η οποία επιστρέφει τον μέσο όρο του Trait για όλους τους οργανισμούς (προσοχή δεν επιστρέφει το mean της αρχικοποίησης, αλλά υπολογίζει τον μέσο όρο των οργανισμών). Είναι υποχρεωτικό να χρησιμοποιήσετε το len και το iteration που υποστηρίζει η κλάση. 

```python
print (g.average()) # επιστρέφει κάτι σαν: 167.6351644738201 
```

### Άσκηση 93
Προσθέστε στη μέθοδο αρχικοποίησης της κλάσης `Group` μία νέα παράμετρο με το όνομα `organsisms` η οποία από default θα είναι `None`. Αν δεν είναι `None` θα μπορεί να είναι μία λίστα με οργανισμούς. Σε αυτή τη περίπτωση η λίστα με τους οργανσιμούς της κλάσης θα είναι η λίστα `organisms` (στην περίπτωση που είναι `None` η λίστα με τους οργανσιμούς της κλάσης θα παράγεται από τις παραμέτρους `mean`, s`igma` και `N`). Για παράδειγμα θα πρέπει να μπορώ να γράφω:

```python
org_1 = Organism('id_1', 100)
org_2 = Organism('id_2', 200)
g1 = Group( organisms = [org_1, org_2] )
print (len(g1)) # Τυπώνει 2

g2 = Group(N=10, mean=170, sigma=5)
print (len(g2)) # Τυπώνει 10

```

Προσθέστε τη μέθοδο `next_generation` στη κλάση `Group`. Η μέθοδο αυτή θα παίρνει σαν παράμετρο έναν αριθμό, έστω κ, από το 0 μέχρι το 1 και έναν ακέραια αριθμό P. Στη συνέχεια θα κάνει το εξής:
1. Θα παίρνει τυχαία ένα organism του group, του οποίου το trait ανήκει στο top κ\*100% όλων των traits. Για παράδειγμα αν το κ=0.1 και το group έχει 150 organisms, τότε θα πρέπει να κάνει sort όλα τα organisms ανάλογα με το traits τους, και να παίρνει τυχαία ένα από τα τοπ 10% αυτών. Δηλαδή θα βρίσκει τα 15 organisms τα οποία έχουν το μεγαλύτερο trait, και θα διαλέγει τυχαία ένα από αυτά. 
2. Θα παίρνει τυχαία ένα δεύτερο organism του group ακολουθώντας την ίδια διαδικασία
3. Θα φτιάχνει έναν απόγονο που προκύπτει από τους οργανισμούς των δύο παραπάνω βημάτων
4. Ακολουθώντας τα βήματα 1,2,3 θα φτιάχνει συνολικά P οργανισμούς
5. Επιστρέφει ένα νέο αντικείμενο της κλάσης Group το οποίο περιέχει αυτούς του P οργανισμούς.

Γράψτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα:
1. Φτιάχνει ένα Group με N=1000, mean=170, sigma=5 
2. Για όλες τις τιμες κ από 0.01 μέχρι και 0.99 με βήμα 0.01 θα υπολογίζει το average trait του Group που επιστρέφει η `next_generation` του Group του βήματος 1 για P=1000 και k=κ.
3. Αφου υπολογίσει 99 averages κάνει ένα plot. Στον Χ άξονα θα είναι οι τιμές από 0.01 μέχρι και 0.99, στon Y θα είναι οι αντίστοιχες τιμές του average.

Δίνεται το plot όπως βγήκε σε εμένα:

![img](https://i.imgur.com/O4vkl4a.png)


### Άσκηση 94
Συμπληρώστε τις τελίτσες (...) στη παρακάτω συνάρτηση ώστε η συνάρτηση να παράγει το ίδιο plot με την άσκηση 87.

```python
import pandas as pd
def f():
    df = pd.read_csv('variant_associations.tsv', sep='\t')
    df.plot(...)
```

### Άσκηση 95
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα:
1. Φορτώνει το αρχείο `variant_associations.tsv` σε ένα pandas DataFrame (υπάρχει στη συνάρτηση της άσκησης 94 πως γίνεται αυτό)
2. Θα κάνει ένα bar plot (kind='bar') όπου σε κάθε χρωμόσωμα θα υπάρχουν 2 μπάρες. 
   1. Η μία μπάρα θα δείχνει το άθροισα των ασθενειών (`NofDiseases`) (προσοχή: άθροισμα (sum), όχι πλήθος (count)!) που προκαλούν όλες οι μεταλλάξεις οι οποίες είναι `3 prime UTR variant` (αυτή η τιμή βρίσκεται στη στήλη: `most_severe_consequence`).
   2. Η δεύτερη μπάρα θα δείχνει το ίδια άθροισμα αλλά για τις μεταλλάξει που είναι `5 prime UTR variant'`.

Σημείωση: [στις σημειώσεις σχετικά με pandas](https://github.com/kantale/biol-494/blob/main/notes/python_pandas.ipynb) υπάρχει ένα σχετικό παράδεγμα. 

Δίνεται το plot όπως βρήκε σε μένα (η σειρά των χρωμοσωμάτων δεν έχει σημασία):

![img](https://i.imgur.com/LL4vAbt.png)

### Άσκηση 96 
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα:
1. Φορτώνει το αρχείο `variant_associations.tsv` σε ένα pandas DataFrame (υπάρχει στη συνάρτηση της άσκησης 94 πως γίνεται αυτό)
2. Θα επιστρέφει το `snpId` της μετάλλαξης η οποία έχει το μεγαλύτερο άθροισμα τιμών στις στήλες: `NofDiseases`, `NofPmids`.

Δίνεται η απάντηση:
```python
print (f()) # Τυπώνει: rs113488022 
```

### Άσκηση 97
Δύο παίκτες Α και Β παίζουν το παρακάτω παιχνίδι: Στην αρχή ρίχνει ο Α ένα ζάρι 6 φορές και στη συνέχεια ο Β ρίχνει το ζάρι πάλι 6 φορές. Αν όλες οι ζαριές του Α είναι μεγαλύτερες από όλες τις αντίστοιχες ζαριές του Β, τότε ο Β δίνει στον Α 200 ευρώ. Διαφορετικά ο Α δίνει στον Β 1 ευρώ. Για παράδειγμα:

Ο Α ρίχνει:

```
[3,2,5,5,3,6]
```

και ο Β ρίχνει:

```
[2,1,4,5,2,5]
```

Εδώ ο Α δίνει 1 ευρώ στον Β (στη 4η ζαριά ρίξαν και οι 2 "5", οπότε δεν είναι όλες οι ζαριές του Α μεγαλύτερες από τις αντίστοιχες του Β)


Ενώ αν ο Α ρίξει:

```
[3,2,5,5,3,6]
```

και ο Β ρίξει:

```
[2,1,4,3,2,1]
```


Τότε ο Β δίνει στον Α 200 ευρώ (ισχύει ότι 3>2, 2>1, 5>4, 5>3, 3>2, 6>1), άρα όλες οι ζαριές του Α είναι μεγαλύτερες από τις αντίστοιχες του Β. 

Το παιχνίδι σταματάει μετά από 1.000.000 γύρους (έχουν πολύ ελεύθερη ώρα..). Αν ο Α ξεκίνησε με 0 ευρώ, πόσα λεφτά θα έχει ο Α στο τέλος του παιχνιδιού (η απάντηση μπορεί να είναι και αρνητική!);

Γράψτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει την απάντηση σε αυτήν την ερώτηση. 

Δίνεται μία μέθοδος να φτιάξεις ένα πίνακα 100 Χ 6 , με τυχαίους αριθμούς από το 1 μέχρι και το 6:
```python
import numpy as np
A = np.random.uniform(1, 7, (100, 6)).astype(int) # To 7 δεν είναι λάθος!
```

Απαγορεύεται (αυστηρά!) να χρησιμοποιήσετε for, while, if, comprehensions.

### Άσκηση 98
Ας υποθέσουμε ότι έχουμε έναν διδιάστατο πίνακα 1000 Χ 30 όπου περιέχει τις τιμές τις έκφρασης 1000 γονιδών σε 30 δείγματα (gene expression). Από τα 30 δείγματα τα πρώτα 10 (δηλαδή οι πρώτες 10 στήλες) ανήκουν σε ανθρώπους με μία συγκεκριμένη ασθένεια, ενώ τα υπόλοιπα δείγματα (υπόλοιπες στήλες) σε ανθρώπους χωρίς την ασθένεια. Θέλουμε να βρούμε ποια γονίδια έχουν διαφοροποιημένη έκφραση (differential expression) μεταξύ των διαφορετικών ειδών δειγμάτων (υγιεί - μη υγιεί). Για να το κάνουμε αυτό απλά μετράμε τον μέσο όρο της έκφρασης για κάθε γονίδιο σε όλα τα υγιεί δείγματα, έστω Α, και τον μέσο όρο της έκφρασης σε όλα τα μη-υγιεί δείγματα, έστω Β. Στη συνέχεια υπολογίζουμε τον λόγο Α/Β για κάθε γονίδιο. Αυτή η μετρική ονομάζεται και [fold chage](https://en.wikipedia.org/wiki/Fold_change). Ποια είναι τα 20 γονίδια τα οποία έχουν το μεγαλύτερο fold chage;

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο έναν 1000 Χ 30 numpy πίνακα. Η συνάρτηση θα επιστρέφει ένα μονοδιάστατο numpy array με τους αριθμούς της γραμμής των γονιδίων με τα 20 γονίδια που ζητούντε (δηλαδή κάθε αριθμός του array θα είναι από 0 μέχρι και 999). 

Μπορείτε να τεστάρετε τη συνάρτησή σας κάπως έτσι:

```python
import numpy as np
A = np.random.normal(13, 3, (1000, 30)) # τυχαίες τιμές

print (f(A))

```

Απαγορεύεται (αυστηρά!) να χρησιμοποιήσετε for, while, if, comprehensions.


### Άσκηση 99 

Σε ένα τουρνουά καλλιτεχνικού πατινάζ συμμετέχουν 20 αθλητές. Στο τουρνου εφαρμόζεται η παρακάτω βαθμολογία.
1. Κάθε αθλητής θα πρέπει να κάνει 10 άλματα
2. Το κάθε άλμα βαθμολογείται από 9 κριτές
3. Κάθε κριτής δίνει σε κάθε άλμα έναν βαθμό από -5 έως και +5

Για την εύρεση του καλύτερου αθλητή εφαρμόζεται η εξής μέθοδος:
1. Υπολογίζεται ο μέσος όρος της βαθμολογίας για κάθε άλμα από όλους τους κριτές. Αυτό γίνεται για όλους τους αθλητές (υπολογίζεται δηλαδή ένας πίνακας 20 Χ 10).
2. Απο τον πίνακα που προκύπτει από το βήμα 1 βρίσκουμε τον αθλητή με τη μεγαλύτερη βαθμολογία. 

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο έναν τριδιάστατο πίνακα 20 Χ 9 Χ 10. Η πρώτη διάσταση θα είναι οι αθλητες, η δεύτερη οι κριτές και η τρίτη τα άλματα. Για παράδειγμα:

```python
Χ[1,2,3] # Περιέχει τη βαθμολογία του 2ου αθλητή, από τον 3η κριτή για το 4ο του άλμα.
```

Η συνάρτηση θα επιστρέφει τον αριθμό (από το 0 μέχρι και το 19) του αθλητή που κέρδισε. 

Μπορείτε να τεστάρετε τη συνάρτησή σας κάπως έτσι:

```python
import numpy as np
A = np.random.uniform(-5, 6, (20, 9, 10)).astype(int) # Τυχαίες τιμές
print (f(A)) # Τυπώνει έναν αριθμό από το 0 μέχρι και το 19
```

Σημείωση: Απαγορεύεται (αυστηρά!) να χρησιμοποιήσετε for, while, if, comprehensions.

### Άσκηση 100

Δίνεται ο παρακάτω 2-διάστατος numpy πίνακας

```python
F1 = array([
    [19,  1,  0,  1,  1,  1,  3,  1,  1,  7,  2,  1,  1,  1,  1,  1,  7,  1,  1,  1,  6,  1],
    [ 1,  2,  1,  6,  2,  0,  4,  0,  5,  4, 12,  0,  6,  6,  3,  2,  2,  3,  3,  6,  4,  2],
    [18,  4,  2,  2,  4,  2,  1,  2,  0,  2,  0,  4,  5,  2,  5,  6,1,  2,  4,  3,  7,  3],
    [ 4,  5,  3,  4,  5,  3,  5,  3,  4,  0,  4,  3,  3,  4,  2,  3, 14,  8,  5,  4, 11,  5],
    [ 2,  3,  0,  0,  3,  4,  2,  0,  2,  1,  0,  5,  4,  3,  8,  4, 3,  0,  0,  5,  3,  4],
    [ 3, 10,  4, 13,  6,  5,  8,  4,  3,  3,  3,  2,  2,  0,  4,  5, 9,  5,  2,  2,  2, 18],
    [15,  7,  5,  3,  0,  8,  6,  9, 15,  6,  7,  7,  7, 12,  7,  7, 4, 10,  6,  9,  0,  6],
    [ 7,  6,  7, 14,  8,  7, 12, 10,  6,  0,  5,  8,  9,  7,  9, 11, 0,  4, 11,  8,  8,  7],
    [ 9,  0, 17,  0, 11,  9,  7,  7,  9,  5, 10,  6,  8,  5,  6,  0, 0,  7,  7, 19,  5,  0],
    [ 6,  0,  8,  5,  7,  6,  9, 11,  7,  0, 11, 14, 20,  0,  0, 13, 11, 15,  0, 10,  9, 15],
    [14,  0,  6, 18, 13, 12, 13,  8, 11, 13,  9,  9, 15, 15, 17,  0, 5, 11, 16,  7,  0,  9],
    [ 0,  0,  0,  8, 17, 11, 10,  6, 12,  9, 17, 11, 10,  8, 14,  0, 8,  6,  8, 14, 11, 10],
    [ 5,  9, 14,  9, 16, 17,  0,  0, 17, 10,  8,  0, 16, 16, 15, 16, 12, 14,  9, 17,  0, 17],
    [ 0,  8,  9, 12,  0, 13, 11,  5, 14,  0, 15, 12, 12,  9, 11,  8, 10, 18, 14, 11, 14, 14],
    [12, 13, 12, 10, 10, 15, 14, 16, 10, 11, 13, 10, 11, 11, 10,  0, 6, 12,  0, 15, 10,  8],
    [11,  0, 13, 17, 15, 14,  0, 14,  0,  8,  6, 15, 14, 17, 13, 12, 13, 17, 15, 16, 13, 16],
    [ 8,  0, 15,  7, 12, 10, 17, 13,  0, 14, 16,  0, 19, 13,  0, 14, 0, 13, 10,  0, 17, 11],
    [10, 11, 11, 15,  0,  0, 16,  0,  8,  0, 14, 16, 13, 14, 16, 10, 0, 16, 12, 13, 12, 12],
    [13, 14, 10, 11,  9, 18,  0, 12, 13,  0, 12, 13, 17, 10, 12,  0, 0,  0, 13, 12, 15, 13],
    [16,  0, 16, 16, 14, 16, 15, 15, 16, 12,  0,  0, 18, 18, 18, 15, 0,  9, 17, 18, 16, 19],
    [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  9, 0,  0,  0,  0,  0,  0],
    [17, 12,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0]
])
```

Ο πίνακας αυτός περιέχει 22 γραμμές και 22 στήλες. Κάθε γραμμή εκπροσωπεί έναν οδηγό της Formula 1. Κάθε στήλη είναι και ένας από τους 22 αγώνες του πρωταθλήματος του 2022 ([πραγματικά δεδομένα](https://en.wikipedia.org/wiki/2022_Formula_One_World_Championship)). Οι τιμές είναι η θέση που κατέκτησε ο κάθε οδηγός σε κάθε αγώνα. Για παράδειγμα ο πρώτος οδηγός στον 7ο αγώνα κατέκτησε τη 3η θέση (`F1[0][6]`). Αν μία θέση είναι 0 σημαίνει ότι ο οδηγός δεν βαθμολογήθηκε σε αυτόν τον αγώνα (π.χ. δεν τερμάτισε, αποκλείστηκε, κτλ). Δίνεται επίσης ο παρακάτω κώδικας ο οποίος περιέχει και τη βαθμολογία που παίρνει ένας οδηγός ανάλογα με τη θέση που τερματίζει σε κάθε αγώνα:

```python
points = np.array([25, 18, 15, 12, 10, 8, 6, 4, 2, 1])
```

Δηλαδή αν τερματίσει πρώτος παίρνει 25 βαθμούς, αν τερματίσει 2ος παίρνει 18 βαθμούς, αν τερματίσει 3ος παίρνει 15 βαθμούς κτλ. Οι πρώτες 10 θέσεις παίρνουν βαθμούς και οι υπόλοιπες παίρνουν 0 βαθμούς. Η συνολική βαθμολογία του κάθε οδηγού είναι το άθροισμα των βαθμών που παίρνει σε όλους τους αγώνες του πρωταθλήματος. Φτιάξτε μία συνάρτηση η οποία θα παίρνει για παράμετρο 2 πίνακες με την ίδια δομή όπως οι `F1`, `points`. Η συνάρτηση θα επιστρέφει τους συνολικούς πόντους που έχει πάρει κάθε οδηγός σε όλο το πρωτάθλημα. Δηλαδή η συνάρτηση θα επιστρέφει έναν numpy πίνακα μίας διάστασης με μέγεθος 22. Η πρώτη τιμή θα είναι η συνολική βαθμολογία του πρώτου οδηγού (δηλαδή της πρώτης γραμμής του πίνακα `F1`), η δεύτερη τιμή θα είναι η βαθμολογία του 2ου αδηγού κτλ. 


Σημείωση: Απαγορεύεται (αυστηρά!) να χρησιμοποιήσετε for, while, if, comprehensions.

Δίνεται η εξής συνάρτηση:

```python
import numpy as np

def count_unique_values(arr):
    unique_values, counts = np.unique(arr, return_counts=True)
    unique_counts = (arr[..., None] == unique_values).sum(axis=1)
    return unique_counts
```

Η συνάρτηση παίρνει σαν είσοδο εναν πίνακα και επιστρέφει πόσες φορές υπάρχει το κάθε διαφορετικό στοιχείο κάθε γραμμής. Για παράδειγμα:

```python
arr = np.array([[0, 0, 1],
                [1, 2, 0],
                [1, 1, 2]])


unique_counts = count_unique_values(arr)
print(unique_counts) 

# Τυπώνει:
[[2 1 0]
 [1 1 1]
 [0 2 1]]
```

Δηλαδή: 
* Στη 1η γραμμή το 0 υπάρχει **2** φορές το 1 υπάρχει **1** φορά και το 2 υπάρχει **0** φορές.
* Στη 2η γραμμή το 0 υπάρχει **1** φορές το 1 υπάρχει **1** φορά και το 2 υπάρχει **1** φορά.
* Στη 3η γραμμή το 0 υπάρχει **0** φορέςτο 1 υπάρχει **2** φορές και το 2 υπάρχει **1** φορά.

Για.. εκπαιδευτικούς σκοπούς (δεν θα τη χρειαστείτε) δίνεται και η συνάρτηση που έφτιαξα για να "πάρω" τα δεδομένα από τη wikipedia:

```python
import re
import pandas as pd
import numpy as np

def get_data():

    dfs = pd.read_html('https://en.wikipedia.org/wiki/2022_Formula_One_World_Championship')
    
    columns = list(range(2,24))
    data = []
    for record in dfs[5][2:24][columns].to_dict('records'):

        col_data = []

        for col in columns:
            value = record[col]

            if (
                pd.isna(value) or
                value in ['WD', 'DNS'] or
                re.search(r'Ret', value)
            ):
                col_data.append(0)
                continue

            s = re.search(r'^\d+', value)
            if s:
                v = int(s.group(0))
                if v == 186:
                    v = 18
                elif v > 20:
                    v = int(str(v)[0])

                col_data.append(v)
                continue

            assert False, value

        data.append(col_data)
    return np.array(data)
```


