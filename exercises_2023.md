
## Σημειώσεις για όλες τις ασκήσεις
* **ΑΠΑΓΟΡΕΥΕΤΑΙ** να κάνετε: ```a = input("...")``` (και γενικότερα μην το κάνετε ποτέ αυτό..)
* Όταν η εκφώνηση λέει ότι πρέπει να φτιάξετε συνάρτηση.. πρέπει να φτιάξετε συνάρτηση!
* Αν η εκφώνηση λέει ότι η συνάρτηση πρέπει να επιστρέφει κάτι.. τότε μέσα στη συνάρτησή σας πρέπει κάπου να κάνετε ```return```.
* Διαβάστε αυτή τη [λίστα με το κοινά λάθη](common_errors.md) που κάνουν συνήθως αρχάριοι στη python και στον προγραμματισμό.  
* **ΠΡΟΣΟΧΗ! Μην**  κάνετε: ```return True```  ή ```return False```  μετά από if


Για παράδειγμα, έστω ότι η άσκηση λέει: 

Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν αριθμό. Η συνάρτηση θα πρέπει να επιστρέφει:
* ```True``` αν ο αριθμός είναι μονός
* ```False``` αν ο αριθμός είναι ζυγός (άρτιος).

Τι να **ΜΗΝ** κάνετε:
```python
def f(n):
    if n%2 == 1:
        return True
    else:
        return False

```

Τι να κάνετε:
```python
def f(n):
    return n%2 == 1
```

Μπορείτε φυσικά να κάνετε `return True` ή `return False`, αν δεν μπορείτε να το απλοποιήσετε όπως παραπάνω.

* **ΑΠΑΓΟΡΕΥΕΤΑΙ** Να χρησιμοποιήσετε τα εξής **ονόματα μεταβλητών**: `str`, `id`, `int`, `list`, `tuple`, `dict`, `max`, `min`, `sum`. Αυτά είναι ονόματα συναρτήσεων της python. Η python σας αφήνει να τα χρησιμοποιήσετε με το "κόστος" ότι χάνεται η αρχική τους χρήση. π.χ:

```python
print (str(55))

str = 'Mitsos'
print (str(55))
```  

* Πάντα να βάζετε ένα σχόλιο πριν από την υλοποίηση με τον αριθμό της άσκησης που λύνεται. Για παράδειγμα:
```python

# άσκηση 42
def f(x):
    return x+1
```
* Θα παρατηρήσετε ότι οι περισσότερες συναρτήσεις σας ζητάνε να φτιάξετε μία συνάρτηση με συγκεκριμμένους παράμετρους. Εκτός αν το ζητάει η άσκηση, δεν χρειάζεται να ελέξετε αν οι τύποι των παραμέτρων είναι αυτός που ζητείται. Για παράδειγμα: 

> Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 2 ακέραιους αριθμούς...

Εσεις δεν χρειάζεται να ελέγξετε ότι όντως είναι ακέραιοι οι παράμετροι της συνάρτησης. 

* Μην κάνετε import βιβλιοθήκες, εκτός αν το ζητάει η άσκηση.


## Λίστα με τις ασκήσεις

### Άσκηση 1
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 2 αριθμούς. Η συνάρτηση θα επιστρέφει τον μέσο όρο των δύο αριθμών. Για παράδειγμα θα πρέπει:

```python

print (f(3,7)) # Τυπώνει: 5 
```

### Άσκηση 2
Φτιάξτε μία συνάρτηση η οποία θα παίρει σαν παράμετρο 3 αριθμούς. Η συνάρτηση θα επιστρέφει τον μέσο όρο των τριών αριθμών. Είναι υποχρεωτικό να χρησιμοποιήσετε τη συνάρτηση που φτιάξατε στη 1η άσκηση. Για παράδειγμα θα πρέπει:

```python
print (f(3,7,2)) # Τυπώνει 4  (δηλαδή (3+7+2)/3)  
```

Hint: αν `μ` είναι ο μέσος όρος των `α`,`β`. Τότε ο μέσος όρος των α,β,γ είναι: ((m\*2) + γ)/3 

### Άσκηση 3
Φιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 5 αριθμούς. Η συνάρτηση θα επιστρέφει τον μέσο όρο των 5 αριθμών. Είναι υποχρεωτικό να χρησιμοποιήσετε τη συνάρτηση της άσκησης 2 και τη συνάρτηση της άσκησης 1. Για παράδειγμα θα πρέπει:

```python
print (f(4,6,8,11,2)) # Τυπώνει 6.2 (δηλαδή: (4+6+8+11+2)/5)
```

Hint: αν `μ` είναι ο μέσoς όρος των `α`,`β` και `ν` είναι ο μέσος όρος των `γ`,`δ`,`ε`. Τότε ο μέσος όρος των `α`,`β`,`γ`,`δ`,`ε` είναι: ((μ\*2) + (ν\*3))/5.

### Άσκηση 4
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 2 αριθμούς. H συνάρτηση θα υπολογίζει το [Heronian Mean](https://en.wikipedia.org/wiki/Heronian_mean) αυτών των 2 αριθμών. Είναι υποχρεωτικό να χρησιμοποιήσετε τη συνάρτηση της 2ης άσκησης. Για παράδειγμα θα πρέπει:

```python
print (f(3,7)) # Τυπώνει 4.860858564985279 
```

Hint: H τετραγωνική ρίζα ενός αριθμού υπολογίζεται με: ```x**0.5``` . π.χ. `print(16**0.5)`, τυπώνει 4.


### Άσκηση 5
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 3 αριθμούς α,β,γ. Η συνάρτηση θα επιστρέφει: 

* `True` αν ο αριθμός β είναι μεγαλύτερος από το α και μικρότερος από το γ.
* `False` διαφορετικά 

Για παράδειγμα:

```python
print (f(1,3,5)) # Τυπώνει True
print (f(1,6,5)) # Τυπώνει False
```

* Σημείωση 1: Απαγορεύεται να χρησιμοποιήσετε την if. 
* Σημείωση 2: Η συνάρτηση θα επιστρέφει μία λογική τιμή, όχι αλφαριθμητικό. Για παράδειγμα μη μπερδέψετε το `True` με το  `'True'`

### Άσκηση 6
Φτιάξτε μία συνάρτηση η οποία θα παίρνει για παράμετρο 4 αριθμούς α,β,γ,δ . Η συνάρτηση θα επιστρέφει:

* `True` , αν το α είναι μικρότερο του β και το β μικρότερο του γ και το γ μικρότερο του δ.
* `False`, αν δεν ισχύει το παραπάνω.

 Για παράδειγμα θα πρέπει:

```python
print (f(1,2,3,4,)) # Τυπώνει True
print (f(1,2,4,3,)) # Τυπώνει False
print (f(2,1,3,4,)) # Τυπώνει False
```

* Σημείωση 1: Απαγορεύεται να χρησιμοποιήσετε την if. 
* Σημείωση 2: Είναι υποχρεωτικό να χρησιμοποιήσετε την συνάρτηση της άσκησης 5

### Άσκηση 7
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 4 αριθμούς α,β,γ,δ. Η συνάρτηση θα πρέπει να επιστρέφει:

* `False`, αν δεν είναι όλοι διαφορετικοί
* `True`, αν οι 4 αριθμοί είναι ταξινομημένοι από τον μεγαλύτερο στον μικρότερο (δηλαδή α>β>γ>δ).
* `False`, αν δεν είναι ταξινομημένοι από τον μεγαλύτερο στον μικρότερο.

Δηλαδή θα πρέπει:

```python
print (f(1,2,3,3)) # Τυπώνει False
print (f(1,2,3,1)) # Τυπώνει False
print (f(1,2,3,4)) # Τυπώνει False
print (f(7,5,3,1)) # Τυπώνει True
print (f(7,5,1,3)) # Τυπώνει False
print (f(7,1,5,3)) # Τυπώνει False
print (f(1,7,5,3)) # Τυπώνει False
```

* Σημείωση 1: είναι υποχεωτικό να χρησιμοποιήσετε τη συνάρτηση της άσκησης 6.
* Σημείωση 2: Απαγορεύεται να χρησιμοποιήσετε την if. 

### Άσκηση 8
Δύο γονίδια Α και Β είναι μεταγραφικοί παράγοντες σε ένα τρίτο γονίδιο Γ. Αν και τα δύο γονίδια Α και Β είναι ανενεργά τότε το Γ είναι ενεργό. Αν ένα από τα Α και Β είναι ενεργό, τότε το Γ είναι ενεργό. Αν όμως τα γονίδια Α και Β είναι και τα δύο ενεργά, τότε αλληλοεπιδρούν και φτιάχνουν μία πρωτεΐνη η οποία εξουδετερώνει τη δράση του Γ, οπότε το γονίδιο Γ δεν ενεργοποιείται.

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 2 λογικές τιμές την Α και Β. Η συνάρτηση θα επιτρέφει:

* `True`, αν οι τιμές των Α και Β είναι τέτοιες που να ενεργοποιούν το γονίδιο Γ.
* `False`, αν οι τιμές των Α και Β είναι τέτοιες που να απενεργοποιούν το γονίδιο Γ.

Δηλαδή θα πρέπει:

```python
print(f(True, True)) # Τυπώνει False
print(f(True, False)) # Τυπώνει True
print(f(False, True)) # Τυπώνει True
print(f(False, False)) # Τυπώνει True
```

Η υλοποίησή σας θα πρέπει να συμπληρώνει τις τελίστες στη παρακάτω συνάρτηση:

```python
def f(A,B):
    return ............
```

### Άσκηση 9
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 2 παράμετρους α και β οι οποίες θα είναι αλφαριθμητικά. Η συνάρτηση θα επιστρέφει:

* `True` αν το αντίστροφο του α υπάρχει στο τέλος του β
* `False` αν δεν ισχύει το παραπάνω

Για παράδειγμα θα πρέπει:

```python
print (f('si', 'Alexis')) # Τυπώνει True ( το αντίστροφο του si είναι το is το οποίο υπάρχει στο τέλος του Alexis)
print (f('is', 'Alexis')) # Τυπώνει False

```

Σημείωση: Απαγορεύεται να χρησιμοποιήσετε την if. 

### Άσκηση 10
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα αλφσαριθμητικό το οποίο θα είναι μία ακολουθία DNA. Η συνάρτηση θα επιστρέφει ένα string το οποίο θα περιέχει το 2ο νουκλεοτίδιο κάθε codon. Για παράδειγμα θα πρέπει:

```python
print (f('ACGTGAAAGGTT')) # Τυπώνει `CGAT`
```

Επεξήγηση:
```
ACGTGAAAGGTT  --> Σε codons:

ACG | TGA | AAG| GTT  -> το 2ο γράμμα κάθε codon είναι:
 |     |     |    |
 C     G     A    T

```

### Άσκηση 11
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο το ύψος και το βάρος ενός ανθρώπου. Η συνάρτηση θα πρέπει:
* Αν το ύψος είναι μεγαλύτερο από 2.30 ή μικρότερο από 1 μέτρο, να επιστρέφει "λάθος τιμές για ύψος"
* Αν το βάρος είναι μεγαλύτερο από 200 ή μικρότερο από 30, να επιστρέφει "λάθος τιμές για βάρος"
* Υπολογίζει το BMI (βάρος/(ύψος<sup>2</sup>))
* Αν το BMI είναι μικρότερο από 19 επιστρέφει "αδύνατο"
* Αν το BMI είναι ίσο με 19 και μικρότερο από 25 επιστρέφει "φυσιολογικό"
* Αν το BMI είναι ίσο με 25 και μικρότερο από 30 επιστρέφει "υπέρβαρο"
* Αν το BMI είναι ίσο με 30 ή μεγαλύτερο επιστρέφει "παχύσαρκο"


### Άσκηση 12
Υλοποιήστε την άσκηση 8 με if

### Άσκηση 13
Η ενεργοποίηση του [Lac operon](https://en.wikipedia.org/wiki/Lac_operon) στα βακτήρια απαιτεί ένα αρκετό πολύπλοκο σύστημα από πρωτεϊνικές αλληλεπιδράσεις. Αν το απλοποιήσουμε λίγο μπορούμε να πούμε ότι:

* Το lac operon δεν είναι ενεργοποιημένο αν δεν υπάρχει λακτόζη.
* Αν υπάρχει λακτόζη αλλά υπάρχει και γλυκόζη, τότε πάλι το lac operon είναι απενεργοποιημένο
* Αν υπάρχει λακτόζη αλλά δεν υπάρχει γλυκόζη τότε η ενεργοποίηση του lac operon εξαρτάται από τη συγκέντρωση του [cAMP](https://en.wikipedia.org/wiki/Cyclic_adenosine_monophosphate). Αν η συγκέτρωση είναι πάνω από 0.2 τότε το lac operon ενεργοποιείται, αλλιως δεν ενεργοποιείται. 

Φτιάξτε μία συνάρτηση η οποία θα παίρνει 3 παραμέτρους, lactose_present, glucose_present και cAMP_concentration. Οι πρώτες δύο θα είναι λογικές μεταβλητές και η τρίτη (cAMP_concentration) θα είναι αριθμητική. Η συνάρτηση θα πρέπει να επιστρέφει True ή False ανάλογα με το αν οι τιμές των παραμέτρων είναι κατάλληλες για να ενεργοποιηθεί το Lac operon 

Για παράδειγμα θα πρέπει:

```python
print (f(False, False, 0.5)) # Τυπώνει False
print (f(False, True, 0.1)) # Τυπώνει False
print (f(True, True, 0.1)) # Τυπώνει False
print (f(True, True, 0.5)) # Τυπώνει False
print (f(True, False, 0.5)) # Τυπώνει True
print (f(True, False, 0.1)) # Τυπώνει False
```


### Άσκηση 14
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 4 αριθμητικούς παραμέτρους α,β,γ,δ. Η συνάρτηση θα πρέπει να επιτρέφει True αν το διάστημα [α,β] έχει κάποια τομή με το διάστημα [γ,δ]. Αν δεν υπάρχει κάποια τομή μεταξύ τους, επιστρέφει False.  Αν το [α,β] είναι "μέσα" στο [γ,δ] ή το [γ,δ] μέσα στο [α,β] τότε πάλι επιστρέφει False. Για παράδειγμα θα πρέπει:

```python
print (f(1,3,5,7)) # Τυπώνει False: το διάστημα [1,3] δεν έχει τομή με το διάστημα [5,7]
print (f(1,3,2,5)) # Τυπώνει True: το [1,3] έχει τομή με το [2,7]
print (f(2,5,1,3)) # Τυπώνει True: το [2,5] έχει τομή με το [1,3]
print (f(1,3,0,4)) # Τυπώνει False: το [1,3] είναι όλο μέσα στο [0,4]
print (f(2,8,3,5)) # Τυπώνει False: το [3,5] είναι όλο μέσα στο [2,8] 
```

* Σημείωση 1: απαγορεύετσαι να χρησιμοποιήσετε for (ή κάποια άλλη επανάληψη). Θα πρέπει να το υλοποιήσετε μόνο με if
* Σημείωση 2: Στην άσκηση αυτή θεωρούμε ότι τα διαστήματα είναι ανοιχτά. Δηλαδή το διάστημα [1,2] δεν έχει κοινό με το διάστημα [2,3]. 

### Άσκηση 15
Φτιάξτε μία συνάρτηση η οποία θα παίρνει τους εξής παραμέτρους: credit_score (αριθμητική), income (αριθμητική), employment_status (string), current_debt (αριθμητική), loan_amount (αριθμητική). Υποθέτουμε ότι μία τράπεζα δίνει ένα δάνεια αν ([και μόνο αν](https://el.wikipedia.org/wiki/%CE%91%CE%BD_%CE%BA%CE%B1%CE%B9_%CE%BC%CF%8C%CE%BD%CE%BF_%CE%B1%CE%BD)) συντρέχουν όλοι οι παρακάτω όροι:

1. To `credit_score` είναι πάνω από 600
2. Το `income` είναι πάνω από 20000
3. To `employment_status` είναι είτε `"full_time"` είτε `"part_time"`
4. To `debt_to_income_ratio` το οποίο είναι ο λόγος του `current_debt` με το `income` είναι μικρότερο από 0.5
5. το `loan_amount` είναι μικρότερο από το 25% του `income`

Η συνάρτηση θα επιστρέφει True αν μπορεί ένας πελάτης να πάρει δάνειο ή False διαφορετικά. 

Σημείωση: είναι υποχρεωτικό να χρησιμοποιείσετε την elif

### Άσκηση 16
Υλοποιήσετε την άσκηση 15 χωρίς να χρησιμοποιείσετε την elif

### Άσκηση 17
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 3 παραμέτρους: `exercises`, `project`, `final`. Οι παράμετροι αυτοί εκπροσωπούν τους βαθμούς (από 0 μέχρι και 10, δεν χρειάζεται να το ελέγξετε αυτό), που πήρε κάποιος φοιτητής στις ασκήσεις, στο project και στο τελικό διαγώνισμα ενός μαθήματος αντίστοιχα. Η συνάρτηση θα πρέπει να επιστρέφει True αν περνάει το μάθημα και False διαφορετικά. Οι κανόνες για να περάσει κάποιος το μάθημα είναι:

1. Υπολογίζεται ο συνολικός βαθμός του μαθήματος ο οποίος απότελείται από το 33% του βαθμού των ασκήσεων, το 33% του βαθμού του project, και το 34% του βαθμού του τελικού.
2. Αν ο τελικός βαθμός είναι μεγαλύτερος ή ίσος από 5 τότε περνάει (επιστρέφει True) διαφορετικά δεν περνάει
3. Ο κανόνας 2 έχει μία εξαίρεση: Αν ο φοιτητής έχει βαθμό project ή βαθμό ασκήσεων μικρότερο από 4 τότε δεν περνάει, ανεξάρτητα από τον βαθμό του τελικού.
4. Οι κανόνες 2 και 3 έχουν μία εξαίρεση: Αν ο βαθμός στο τελικό είναι μεγαλύτερος ή ίσος με 9, τότε περνάει.

Δίνονται μετικά παραδείγματα:
```python
print (f(8,8,8)) # Τυπώνει True, Μέσος όρος 8, περνάει 
print (f(5,5,4)) # Τυπώνει False, Μέσος όρος <5.0
print (f(3,8,8)) # Τυπώνει False, Μέσος όρος >5.0, αλλά έχει γράψει στις ασκήσεις <4  
print (f(8,3,8)) # Τυπώνει False, Μέσος όρος >5.0, αλλά έχει γράψει στο project < 4 
print (f(8,3,9)) # Τυπώνει True, έχει γράψει στο project < 4 αλλά έχει γράψει >= 9 στο τελικό
print (f(3,8,9)) # Τυπώνει True, έχει πάρει στις ασκήσεις < 4 αλλά έχει γράψει >= 9 στο τελικό 
print (f(1,1,10)) # Τυπώνει True, έχει μέσο όρο < 5, έχει γράψει <4 σε ασκήσεις και projects αλλά έχει γράψει >= 9 στο τελικό
```

### Άσκηση 18
Οι ακολουθίες του DNA οι οποίες μπορούν να μεταφραστούν ως ένα [stop codon](https://en.wikipedia.org/wiki/Stop_codon) είναι: `TAG`, `TAA`, `TGA`. Φτιάξτε μία συνάρτηση η οποία παίρνει τις εξής παραμέτρους (όλοι είναι λογικοί παράμετροι):
* `Τ_1` : είναι True, αν το 1ο νουκλεοτίδιο του codon είναι T, αλλίως False
* `A_2` : είναι True, αν το 2ο νουκλεοτίδιο του codon είναι A, αλλίως False
* `G_2` : είναι True, αν το 2ο νουκλεοτίδιο του codon είναι G, αλλίως False
* `G_3` : είναι True, αν το 3ο νουκλεοτίδιο του codon είναι G, αλλίως False
* `Α_3` : είναι True, αν το 3ο νουκλεοτίδιο του codon είναι A, αλλίως False

* Αν και το Α_2 και το G_2 είναι True θα πρέπει να επιστρέφει το string: `impossible`
* Αν και το G_3 και το A_3 είναι True θα πρέπει να επιστρέφει το string: `impossible`

Διαφορετικά:

Η συνάρτηση θα πρέπει να επιστρέφει True αν οι παραμέτροι είναι τέτοιοι που να σχηματίζεται ένα stop codon αλλιώς να επιστρέφει False. Για παράδειγμα θα πρέπει:

```python
print (f(T_1=True, A_2=True, G_2=True, G_3=True, A_3=False)) # Τυπώνει "impossible"
print (f(T_1=True, A_2=True, G_2=False, G_3=True, A_3=False)) # (TAG) Τυπώνει True 
print (f(T_1=True, A_2=True, G_2=False, G_3=False, A_3=True)) # (TAA) Τυπώνει True
print (f(T_1=True, A_2=False, G_2=True, G_3=False, A_3=True)) # (TGA) Τυπώνει True
print (f(T_1=False, A_2=False, G_2=True, G_3=False, A_3=True)) #  Τυπώνει False
print (f(T_1=True, A_2=False, G_2=True, G_3=True, A_3=False)) # (TGG) Τυπώνει False
```

Σημείωση: Απαγορεύεται να χρησιμοποιήσετε οποιοδήποτε τελεστή! (==, !=, or, and, ...)

Hint:

Αυτό:

```python
if T_1 == True:
    print ('Το πρώτο νουκλεοτίδιο είναι Τ')
```

Είναι το ίδιο με αυτό:

```python
if T_1:
    print ('Το πρώτο νουκλεοτίδιο είναι Τ')
```

Προσέξτε ότι βγάλαμε τον τελεστή `==`

### Άσκηση 19
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα string με 3 γράμματα (δεν χρειάζεται να το ελέξετε αυτό). Η συνάρτηση θα επιστρέφει:

* `True`: αν το string μπορεί να μεταφραστεί σε stop codon
* `False`: αν το string δεν μπορεί να μεταφραστεί σε stop codon

Για παράδειγμα θα πρέπει:

```python
print (f('TAG')) # Τυπώνει "True"
print (f('TAA')) # Τυπώνει "True"
print (f('TGA')) # Τυπώνει "True"
print (f('AGA')) # Τυπώνει "False"
print (f('TGG')) # Τυπώνει "False"
```

Σημείωση: είναι υποχρεωτικό να χρησιμοποιήσετε τη συνάρτηση της άσκησης 18.

### Άσκηση 20
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα string. Η συνάρτηση αυτή θα ελέγχει αν το string έχει όλες τις προδιαγραφές για να χρησιμοποιηθεί ως το password ενός χρήστη (password validation). Οι προδιαγραφές είναι:

* Πρέπει να είναι πάνω από 6 χαρακτήρες
* Πρέπει να περιέχει τους χαρακτήρες "!" και "@" σε απόσταση 3 ή περίσσότερο μεταξύ τους. 
* Πρέπει να ξεκινάει με ένα κεφαλαίο γράμμα και να τελειώνει με ένα μικρό ή το αντίθετο (να ξεκινάει με μικρό και να τελειώνει με κεφαλαίο)

([ναι.. οι κανόνες δεν χρειάζεται να βγάζουν νόημα](https://dumbpasswordrules.com/))

Αν ισχύουν όλοι οι κανόνες θα επιστρέφει True αλλίως θα επιστρέφει False

### Άσκηση 21 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρεις παράμετρους. Η πρώτη θα είναι μία λίστα με αριθμούς (π.x l) η δεύτερη ένας αριθμός (π.χ. α) και η τρίτη ένας αριθμός π.χ. β. Η συνάρτηση θα επιστρέφει το **άθροισμα** των αριθμών της λίστας οι οποίοι είναι μεγαλύτεροι από α και μικρότεροι από β. Για παράδειγμα θα πρέπει:

```python
print (f([8,3,10, 11,9,8,5], 5, 10)) # Τυπώνει:  25 (δηλαδή 8+8+9, οι αριθμοί που είναι μεγαλύτεροι από 5 και μικρότεροι από 10) 
```

* Σημείωση 1: είναι υποχρεωτικό να χρησιμοποιήσετε for (όχι list comprehension)
* Σημείωση 2: Απαγορεύεται να χρησιμοποιήσετε continue

### Άσκηση 22 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρεις παράμετρους. Η πρώτη θα είναι μία λίστα με αριθμούς (π.x l) η δεύτερη ένας αριθμός (π.χ. α) και η τρίτη ένας αριθμός π.χ. β. Η συνάρτηση θα επιστρέφει το **πλήθος** των αριθμών της λίστας οι οποίοι είναι μεγαλύτεροι από α και μικρότεροι από β. Για παράδειγμα θα πρέπει:

```python
print (f([8,3,10, 11,9,8,5], 5, 10)) # Τυπώνει: 3  
```

* Σημείωση 1: είναι υποχρεωτικό να χρησιμοποιήσετε for (όχι list comprehension)
* Σημείωση 2: Απαγορεύεται να χρησιμοποιήσετε continue

### Άσκηση 23
Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρεις παράμετρους. Η πρώτη θα είναι μία λίστα με αριθμούς (π.x l) η δεύτερη ένας αριθμός (π.χ. α) και η τρίτη ένας αριθμός π.χ. β. Η συνάρτηση θα επιστρέφει τον μεγαλύτερι αριθμό της λίστας ο οποίος είναι μεγαλύτερος από α και μικρότερος από β. Για παράδειγμα θα πρέπει:

```python
print (f([8,3,10, 11,9,8,5], 5, 10)) # Τυπώνει: 9  
```

* Σημείωση 1: είναι υποχρεωτικό να χρησιμοποιήσετε for (όχι list comprehension)
* Σημείωση 2: Απαγορεύεται να χρησιμοποιήσετε continue

### Άσκηση 24
Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρεις παράμετρους. Η πρώτη θα είναι μία λίστα με αριθμούς (π.x l) η δεύτερη ένας αριθμός (π.χ. α) και η τρίτη ένας αριθμός π.χ. β. Η συνάρτηση θα επιστρέφει `True` αν υπάρχει έστω ένας αριθμός ο οποίος να είναι μεγαλύτερος από α και μικρότερος από β ή `False` αν δεν υπάρχει κανένας τέτοιος αριθμός . Για παράδειγμα θα πρέπει:

```python
print (f([8,3,10, 11,9,8,5], 5, 10)) # Τυπώνει: True  
print (f([-8,3,10, 11,-9,-8,5], 5, 10)) # Τυπώνει: False  
```

* Σημείωση 1: είναι υποχρεωτικό να χρησιμοποιήσετε for (όχι list comprehension)
* Σημείωση 2: Απαγορεύεται να χρησιμοποιήσετε break ή continue.

### Άσκηση 25
Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρεις παράμετρους. Η πρώτη θα είναι μία λίστα με αριθμούς (π.x l) η δεύτερη ένας αριθμός (π.χ. α) και η τρίτη ένας αριθμός π.χ. β. Η συνάρτηση θα επιστρέφει `True` αν υπάρχει έστω ένας αριθμός ο οποίος να είναι μεγαλύτερος από α και μικρότερος από β ή `False` αν δεν υπάρχει κανένας τέτοιος αριθμός . Για παράδειγμα θα πρέπει:

```python
print (f([8,3,10, 11,9,8,5], 5, 10) # Τυπώνει: True  
print (f([-8,3,10, 11,-9,-8,5], 5, 10) # Τυπώνει: False  
```

* Σημείωση 1: είναι υποχρεωτικό να χρησιμοποιήσετε for (όχι list comprehension)
* Σημείωση 2: είναι υποχρεωτικό να χρησιμοποιήσετε break και continue (και τα 2!). To continue δεν μπορεί να είναι στο τέλος της for. Για παράδειγμα:

```python
for x in [1,2,3]:
    print (x)
    continue # <-- Δεν έχει νόημα αυτό
```

### Άσκηση 26 
Υλοποιήστε την άσκηση 21

* Σημείωση 1: είναι υποχρεωτικό να χρησιμοποιήσετε for (όχι list comprehension)
* Σημείωση 2: είναι υποχρεωτικό να χρησιμοποιήσετε continue. To continue δεν μπορεί να είναι στο τέλος της for.

### Άσκηση 27
Υπάρχει μόνο ένα ζευγάρι τιμών χ,y τέτοια ώστε:
* Τα χ,y είναι ακέραιοι από το 1 μέχρι και το 100
* Η έκφραση `x*y+23*x-7*y` διαιρείται ακριβώς με το 1000.

Ποιο είναι το άθροισμα των χ,y που έχει αυτή την ιδιότητα; Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα επιστρέφει την απάντηση σε αυτή την ερώτηση. Δίνεται τι θα επιστρέφει η συνάρτηση:

```python
print (f()) # Τυπώνει 168
```

Δίνεται πως ελέγχουμε αν ένας αριθμός διαιρείται με το 1000. Απλά τσεκάρουμε αν το υπόλοιπο της διαίρεσης με το 1000 είναι 0:

```python
print ( 1234 % 1000 == 0 ) # Τυπώνει False. το 1234 δεν διαρείται με το 1000
print ( 3000 % 1000 == 0 ) # Τυπώνει True. το 3000 διαρείται με το 1000
```

### Άσκηση 28
Φτιάξτε μία συνάρτηση η οποία δεν παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει ένα string το οποίο θα περιέχει όλα τα 64 codons ακριβώς μία φορά. Δηλαδή θα πρέπει:

```python
print (f()) # Τυπώνει: AAAAACAAGAATACAACCACGACTAGAAGCAGGAGTATAATCATGATTCAACACCAGCATCCACCCCCGCCTCGACGCCGGCGTCTACTCCTGCTTGAAGACGAGGATGCAGCCGCGGCTGGAGGCGGGGGTGTAGTCGTGGTTTAATACTAGTATTCATCCTCGTCTTGATGCTGGTGTTTATTCTTGTTT
```

Εξήγηση: Όλα τα codons είναι: `AAA`, `AAC`, `AAG`, `AAT`, `ACA`, `ACC`, `ACG`, `ACT`, `AGA`, ... H σειρά δεν έχει σημασία αρκεί να είναι και τα 64 (`4*4*4`) ακριβώς μία φορά το κάθε ένα. Είναι υποχρεωτικό να χρησιμοποιήσετε for και να μην κάνετε import τίποτα.

### Άσκηση 29
Φτιάξτε μία συνάρτηση η οποία θα τυπώνει χαριτωμένα σχεδιάκια με αστεράκια με τον εξής τρόπο:

```python
print f(1)
```
Τυπώνει:
```
*
```


```python
print f(2)
```
Τυπώνει:
```
**
*
```

```python
print f(3)
```
Τυπώνει:
```
***
**
*
```

```python
print f(4)
```
Τυπώνει:
```
****
***
**
*
```

κτλ..

### Άσκηση 30
Μία ακολουθία DNA λέγεται συμμετρική αν διαβάζεται το ίδιο από την αρχή και από το τέλος. Μερικά παραδείγματα είναι: `ACCA`, `ACGCA`, `GGG`, `TT`. Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία ακολουθία DNA. Η συνάρτηση θα επιστρέφει True αν υπάρχει έστω και μία υπο-ακολουθία η οποία να είναι συμμετρική ή False διαφορετικά. Για παράδειγμα θα πρέπει:

```python 
print (f('ACGACTAG')) # Τυπώνει False, δεν περιέχει συμμετρική ακολουθία
print (f('ACGAATAG')) # Τυπώνει True, υπάρχει η ΑΑ
print (f('ACGAGCAG')) # Τυπώνει True, υπάρχει η CGAGC
```

### Άσκηση 31
Ποιο είναι το άθροισμα όλων των αριθμών από το 1 μέχρι και το 1000 αν δεν μετρήσουμε τους αριθμούς που έχουν μέσα το "3"; Δηλαδή δεν μετράμε το 3, το 13, το 23, ..., 103, ... 134, ... 

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα πρέπει να επιστρέφει την απάντηση στην παραπάνω ερώτηση.

Σημείωση: Αν χρησιμοποιήσετε τη `str` θα χάσετε 2 πόντους! Δηλαδή θα βαθμολογηθείτε με άριστα το 8/10. Προσπαθήστε να την υλοποιήσετε χωρίς τη `str`

### Άσκηση 32
Ποιο είναι το άθροισμα όλων των αριθμών από το 1 μέχρι και το 10.000 αν δεν μετρήσουμε τους αριθμούς που έχουν μέσα το "3" μόνο μία φορά; Δηλαδή δεν μετράμε το 3, το 13, το 23, ..., 103, ... 134, ..., 305, 2003. Αλλά μετράμε το 33, 331, 333, 1033, 1303,  

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα πρέπει να επιστρέφει την απάντηση στην παραπάνω ερώτηση.

Σημείωση: Αν χρησιμοποιήσετε τη `str` θα χάσετε 2 πόντους! Δηλαδή θα βαθμολογηθείτε με άριστα το 8/10. Προσπαθήστε να την υλοποιήσετε χωρίς τη `str`

### Άσκηση 33
[Γνωρίζουμε από τα μαθηματικά](https://en.wikipedia.org/wiki/1/2_%2B_1/4_%2B_1/8_%2B_1/16_%2B_%E2%8B%AF) ότι: 1/2 + 1/4 + 1/8 + 1/16 + ... = 1. Πόσους όρους αυτής της ακολουθίας πρέπει να προσθέσουμε ώστε η διαφορά του αθροίσματός τους με το 1 να γίνει μικρότερη από 0.000001 ;

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα πρέπει να επιστρέφει την απάντηση στην παραπάνω ερώτηση.

### Άσκηση 34
[Γωνρίζουμε από τα μαθηματικά](https://en.wikipedia.org/wiki/1/2_%E2%88%92_1/4_%2B_1/8_%E2%88%92_1/16_%2B_%E2%8B%AF) ότι: 1/2 - 1/4 + 1/8 - 1/16 + ... = 1/3. Πόσους όρους αυτής της ακολουθίας πρέπει να προσθέσουμε ώστε η απόλυτη διαφορά (`abs(s-1/3)`) του αθροίσματός τους με το 1/3 να γίνει μικρότερη από το  0.000001 ;

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα πρέπει να επιστρέφει την απάντηση στην παραπάνω ερώτηση.

Σημείωση: Μπορείτε να χρησιμοποιήσετε τη συνάρτηση `abs` της python η οποία επιστρέφει την απόλυτη τιμή μίας έκφρασης.  

### Άσκηση 35
[Γνωρίζουμε από τα μαθηματικά](https://en.wikipedia.org/wiki/Pi#Rate_of_convergence) ότι: 

![img](https://wikimedia.org/api/rest_v1/media/math/render/svg/fdafa8bd24ce2b6fd518a3cf253ad1ef409388a6)

Πόσους όρους αυτής της ακολουθίας πρέπει να προσθέσουμε ώστε το η απόλυτη διάφορά του αθροίσματός τους με το π να γίνει μικρότερη από το 0.0001 ;

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα πρέπει να επιστρέφει την απάντηση στην παραπάνω ερώτηση.


Δίνεται ότι η τιμή του π (pi) είναι:

```python
import math
print (math.pi)
```


### Άσκηση 36 
To [παραγοντικό ενός αριθμού](https://en.wikipedia.org/wiki/Factorial) n συμβολίζεται με n! και ισούται με το γινόμενο όλων των ακέραιων αριθμών από 1 μέχρι και το n. Για παράδειγμα το παραγοντικό του 4 είναι 24 (1\*2\*3\*4). Ορίζουμε επίσης ότι το παραγοντικό του 0 είναι 1, δηλαδή 0! = 1. Εννοείται ότι όλοι γνωρίζουμε από τα μαθηματικά ότι το ([e, δηλαδή η βάση των φυσικών λογαρίθμων](https://en.wikipedia.org/wiki/E_%28mathematical_constant%29)) είναι ίσο με:

e = 1/(0!) + 1/(1!) + 1/(2!) + 1/(3!) + 1/(4!) + ...

ή αλλιώς:

e = 1/1 + 1/1 + 1/(1\*2) + 1/(1\*2\*3) + 1/(1\*2\*3\#4) + ...

ή αλλιώς:

![img](https://wikimedia.org/api/rest_v1/media/math/render/svg/2f9a1f86072b07e1f69d5e21571c207d52680d8f)


Πόσους όρους αυτής της ακολουθίας πρέπει να προσθέσουμε ώστε η διαφορά του αθροίσματός τους με το e να γίνει μικρότερη από το 0.0001 ;

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα επιστρέφει την απάντηση στη παραπάνω ερώτηση.

To e μπορείτε να το "πάρετε" με τον εξής τρόπο:

```python
import math

print (math.e)

```

* Σημείωση 1: Απαγορεύεται να κάνε import κάποια βιβλιοθήκη εκτός από την import για να πάρετε το e (αν δεν ξέρετε τι είναι αυτό, τόσο το καλύτερο!)
* Σημείωση 2: Θα πρέπει να φτιάξετε μία και μόνο μία συνάρτηση (μην φτιάξετε συνάρτηση η οποία υπολογίζει το παραγοντικό)

### Άσκηση 37

Ο Lothar Collatz, είπε [ένα θεώρημα](https://en.wikipedia.org/wiki/Collatz_conjecture) το οποίο μέχρι σήμερα είναι αναπόδεικτο! Συγκεκριμένα είπε ότι αν πάρουμε οποιοδήποτε ακέραιο αριθμό μεγαλύτερο από 1 και εφαρμόσουμε την εξής διαδικασία:

* Αν είναι ζυγός τον διαιρούμε με το 2
* Αν είναι μονός το πολλαπλασιάζουμε με το 3 και προσθέτουμε το 1
* Εφαρμόζουμε τους παραπάνω δύο κανόνες στον νέο αριθμό που βρήκαμε

Τότε ο αριθμός που θα καταλήξουμε θα είναι πάντα ο 1 !!! Για παράδειγμα έστω ότι έχουμε τον αριθμό 45:
* Το 45 είναι μονός άρα πάμε στον 45\*3 + 1 = 136
* Το 136 είναι ζυγός άρα πάμε στον 136/2 = 68
* Το 68 είναι ζυγός άρα πάμε στον 68/2 = 34
* Το 34 είναι ζυγός άρα πάμε στον 34/2 = 17
* Το 17 είναι μονός άρα πάμε στον 17\*3 + 1 = 52
* Το 52 είναι ζυγός άρα πάμε στον 52/2 = 26
* Το 26 είναι ζυγός άρα πάμε στον 26/2 = 13
* Το 13 είναι μονός άρα πάμε στον 13\*3 + 1 = 40
* Το 40 είναι ζυγός άρα πάμε στον 40/2 = 20
* Το 20 είναι ζυγός άρα πάμε στον 20/2 = 10
* Το 10 είναι ζυγός άρα πάμε στον 10/2 = 5
* Το 5 είναι μονός άρα πάμε στον 5\*3 +  1 = 16
* Το 16 είναι ζυγός άρα πάμε στον 16/2 = 8
* Το 8 είναι ζυγός άρα πάμε στον 8/2 = 4
* Το 4 είναι ζυγός άρα πάμε στον 4/2 = 2
* Το 2 είναι ζυγός άρα πάμε στον 2/2 = 1 !!! 


Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο έναν αριθμό n. Η συνάρτηση θα επιστρέφει μία λίστα με όλους τους αριθμούς που παίρνουμε με βάση την παραπάνω διαδικασία για να καταλήξουμε στο 1. Δηλαδή θα πρέπει:


```python
print (f(45)) # Τυπώνει [136, 68, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
```
 

### Άσκηση 38
Όπως είπαμε και στο μάθημα το [πρόβλημα της παραγοντοποίησης](https://en.wikipedia.org/wiki/Integer_factorization) είναι ένα από τα πιο δύσκολα στην επιστήμη των υπολογιστών. Ευτυχώς για μικρούς αριθμούς το πρόβλημα δεν είναι καθόλου δύσκολο. Η παραγοντοποίηση λοιπόν ενός ακέραιου θετικού αριθμού ορίζεται ώς το σύνολο από πρώτους αριθμούς τους οποίους αν τους πολλαπλασιάσεις θα πάρεις τον αρχικό αριθμό. Δίνονται μερικά παραδειγματα:

```
100 = 2 * 2 * 5 * 5
99 = 3 * 3 * 11
98 = 2 * 7 * 7
96 = 2 * 2 * 2 * 2 * 2 * 3
```


Φτιάξτε μία συνάρτηση η οποία θα παίρνει έναν αριθμό και θα επιστρέφει το πλήθος από παράγοντες που έχει. Θα πρέπει δηλαδή:

```python
print (f(100)) # Τυπώνει: 4
print (f(99)) # Τυπώνει: 3
print (f(98)) # Τυπώνει: 3
print (f(96)) # Τυπώνει: 6
```

* Σημείωση: Δεχόμαστε σαν σύμβαση ότι το 1 έχει 0 παράγοντες (δες και επόμενη άσκηση). Δηλαδή:

```python
print (f(1)) # Τυπώνει 0
```

### Άσκηση 39
(Συνέχεια της άσκησης 38)

Παρατηρούμε τώρα ότι κάποιοι αριθμοί όπως το 100 και το 96 έχουν ζυγό αριθμό από παράγοντες (το 100 έχει 4 και το 96 έχει 6), ενώ κάποιοι άλλοι όπως το 99 και το 98 έχουν μονό αριθμό από παράγοντες (και οι 2 έχουν 3 παράγοντες). Αν πάρουμε έναν αριθμό έστω n και πάρουμε όλους τους αριθμούς από το 1 μέχρι και το n, τότε αυτοί οι αριθμοί μπορούν να χωριστούν σε δύο κατηγορίες: αυτοί που έχουν ζυγό αριθμό από παράγοντες και μονό αριθμό από παράγοντες. Ποιος είναι ο λόγος των αριθμών από το 1 μέχρι και το n που έχουν μονό αριθμό από παράγοντες; Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο έναν αριθμό n. Η συνάρτηση θα επιστρέφει έναν αριθμό ο οποίος θα είναι ο αυτός ο λόγος (λόγος = [ratio](https://en.wikipedia.org/wiki/Ratio),  δηλαδή ένας αριθμός από 0 μέχρι και 1). 

Για παράδειγμα ας πάρουμε τον αριθμό 10. Όλοι οι αριθμοί από 1 μέχρι και το 10 μαζί με τους παράγοντες τους, το πλήθος των παραγόντων και αν είναι μονός ή ζυγός αριθμός αυτό το πλήθος είναι: 

| αριθμός  | παράγοντες    |  πλήθος παραγόντων  |  μονό πλήθος ή ζυγό πλήθος      |
|----------|---------------|---------------------|---------------------------------|
| 1  | []      | 0  | ζυγός |
| 2  | [2]     | 1  | μονός |
| 3  | [3]     | 1  | μονός |
| 4  | [2,2]   | 2  | ζυγός |
| 5  | [5]     | 1  | μονός |
| 6  | [2,3]   | 2  | ζυγός |
| 7  | [7]     | 1  | μονός |     
| 8  | [2,2,2] | 3  | μονός |
| 9  | [3,3]   | 2  | ζυγός |
| 10 | [2,5]   | 2  | ζυγός |


Αν μετρήσουμε τώρα το πλήθος από αριθμούς με μονό πλήθος παραγόντων, θα δούμε ότι είναι 5 (το 2, το 3, το 5, το 7 και το 8). Άρα 5 από τους 10 αριθμούς έχουν μονό πλήθος από παράγοντες, άρα ο ζητούμενος λόγος είναι: 5/10 = 0.5. Συνεπώς θα πρέπει:

```python
print (f(10)) # Τυπώνει 0.5  
```

Σημείωση: Θεωρούμε ότι το 0 είναι ζυγός αριθμός.

### Άσκηση 40
(Συνέχεια της άσκησης 39)

Ποιος είναι ο μικρότερος αριθμός ο οποίος να είναι μεγαλύτερος από 100 για τον οποίο η συνάρτηση της άσκησης 39 επιστρέφει 0.5 ; 

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει την απάντηση στο παραπάνω ερώτημα. 

Σημείωση (εγκυκλοπαιδική): Προφανώς θα αναρωτιέστε, ποιος και γιατί ασχολείται με αυτά τα "ερωτήματα". Το ερώτημα του μονού/ζυγού πλήθους από παράγοντες απασχολεί τους μεγαλύτερους μαθηματικούς εδώ και πολλά χρόνια. Ο George Pólya το 1919 [είπε](https://en.wikipedia.org/wiki/P%C3%B3lya_conjecture) ότι αυτός ο λόγος είνα μεγαλύτερος ή ίσος με το 0.5 για όλους τους θετικούς ακέραιους αριθμούς. Για 40 χρόνια κανείς δεν τον αμφισβήτησε, ώσπου τι 1958 ο C. Brian Haselgrove απέδειξε ότι ο λόγος αυτός είναι μικρότερος από 0.5 για έναν αριθμό "κοντά" στο 1.845 × 10<sup>361</sup>. Το 1980 βρέθηκε ο μικρότερος αριθμός τέτοιος ώστε η συνάρτηση της άσκησης 39 να επιστρέφει αριθμό μικρότερο του 0.5. Ο αριθμός αυτός είναι ο 906,150,257. Όσον αφορά το "γιατί" σκεφτείτε ότι αν θεωρήσουμε ότι η κατανομή των παραγόντων είναι τυχαία, τότε ο λόγος αυτός θα είναι 0.5 για πολύυυ μεγάλους αριθμούς. Αν δεν είναι 0.5  σημαίνει ότι για "κάποιο λόγο" υπάρχουν περισσότεροι αριθμοί με μονό πλήθος από παράγοντες από ότι με ζυγούς (ή το αντίθετο). Άρα υπάρχει κάποια "αιτία" για αυτή την ανισοκατανομή. Μία συνέπεια αυτής της αιτίας θα είναι ότι επηρεάζει τη κατανομή των πρώτων αριθμών. Αν βρεθεί αυτή η αιτία σημαίνει ότι μπορούμε "εύκολα" να κατασκευάσουμε μεγάλους πρώτους αριθμούς, κάτι που [προς το παρών δεν μπορεί να γίνει](https://en.wikipedia.org/wiki/Generation_of_primes) και θα έχει τεράστιες συνέπεις στη κρυπτογραφεία.


### Άσκηση 41
Έστω το παρακάτω dictionary:

```python
d = {
 'DTO1E': [7, 13, 10, 5, 5, 8, 6, 8, 9, 12, 5, 5, 14, 15, 15, 5, 13, 6, 5, 8],
 'ZFT5Q': [8, 13, 9, 14, 12, 11, 9, 14, 12, 5, 9, 15, 6, 9],
 '53SDW': [5, 9, 13, 9, 5, 13, 14, 13, 14, 12, 12, 5, 14, 14, 11, 14],
 'GOFAD': [6, 7, 8, 8, 11, 5, 12, 8, 11, 5, 15],
 '8H65O': [14, 6, 10, 15, 9, 7, 12, 10, 9, 11, 6, 6, 6, 11, 10, 5, 11, 12],
 'P86CG': [7, 15, 12, 15, 13, 11, 15, 7, 15, 7, 14, 8, 10, 10, 8, 11, 8, 14, 11],
 '7A1EH': [5, 11, 9, 13, 14, 8, 15, 5, 10, 15, 12, 10, 8, 11, 8, 14, 11],
 'KR7FS': [7, 8, 11, 11, 14, 13, 15, 14, 9, 15, 9, 9, 10, 6, 15],
 '7L5J0': [12, 7, 14, 5, 8, 6, 11, 13, 14, 15, 5, 15, 12, 7, 11, 8],
 'M3JQ7': [10, 12, 15, 13, 13, 14, 6, 9, 13, 11, 5, 8, 10, 10, 5, 5],
 'UI0FX': [8, 9, 7, 9, 11, 7, 12, 11, 15, 9, 7, 5, 14, 9, 10, 10, 13, 7, 13],
 '2UDZT': [6, 8, 6, 6, 14, 6, 11, 9, 11, 9, 6, 6, 10, 14],
 'GM5ED': [6, 15, 10, 6, 6, 6, 15, 7, 11, 12],
 'E4WQO': [6, 5, 10, 7, 5, 13, 14, 5, 10, 12, 8, 13, 10],
 'D4XJ8': [9, 8, 7, 11, 15, 11, 12, 10, 11, 13, 8, 15, 6, 9, 14, 13, 14, 13],
 'YTKP3': [8, 12, 11, 15, 9, 10, 15, 13, 14, 5, 8, 9, 10, 13, 11, 10, 5, 5],
 'Q32C8': [14, 7, 11, 12, 11, 8, 7, 10, 15, 8, 12, 9, 11],
 '3F9AK': [5, 14, 6, 5, 14, 15, 14, 15, 13, 9, 7, 11, 5],
 'PMJ7T': [5, 5, 6, 13, 8, 8, 5, 8, 10, 7],
 '40ZOG': [5, 11, 5, 9, 13, 14, 6, 13, 8, 13, 14, 11, 9],
}
```

Σε αυτό το dictionary τα κλειδιά είναι strings τα οποία αναπαριστούν ονόματα γονιδίων (τυχαία) και οι τιμές είναι λίστες που αναπαριστούν πόσες μεταλλάξεις έχει το κάθε exon του γονιδίου (επίσης τυχαίοι αριθμοί). Για παράδειγμα:

Το 5ο exon του γονιδίου `M3JQ7` έχει 13 μεταλλάξεις:

```python
print (d['M3JQ7'][4]) # Τυπώνει 13
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary με την ίδια δομή όπως το d. Η συνάρτηση θα πρέπει να επιστρέφει το γονίδιο που έχει τα περισσότερα exons. Δηλαδή θα πρέπει:

```python
print (f(d)) # Τυπώνει ένα string με την απάντηση
```

### Άσκηση 42

Θεωρείστε το ίδιο dictionary με την άσκηση 41. 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary με την ίδια δομή όπως το d. Η συνάρτηση θα πρέπει να επιστρέφει το γονίδιο που έχει τις λιγότερες μεταλλάξεις (**προσοχή!** όχι τα λιγότερα exons). Δηλαδή θα πρέπει:

```python
print (f(d)) # Τυπώνει ένα string με την απάντηση
```

### Άσκηση 43
Θεωρείστε το ίδιο dictionary με την άσκηση 41. 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary με την ίδια δομή όπως το d. Η συνάρτηση θα πρέπει να επιστρέφει μία λίστα η οποία περιέχει τα γονίδια ταξινομημένα με βάση το πλήθος των exon που έχουν. Η ταξινόμηση θα ξεκινάει από το γονίδιο με το μικρότερο πλήθος από exons προς το γονίδιο με το μεγαλύτερο πλήθος από exons. Δηλαδή θα πρέπει:

```python
print (f(d)) # Τυπώνει μία λίστα με την απάντηση
```

### Άσκηση 44
Θεωρείστε το ίδιο dictionary με την άσκηση 41. 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary με την ίδια δομή όπως το d. Η συνάρτηση θα πρέπει να επιστρέφει μία λίστα η οποία περιέχει τα γονίδια ταξινομημένα με βάση το πλήθος των μεταλλάξεων που έχουν. Η ταξινόμηση θα ξεκινάει από το γονίδιο με το μεγαλύτερο πλήθος από μεταλλάξεις προς το γονίδιο με το μικρότερο πλήθος από μεταλλάξεις. Δηλαδή θα πρέπει:

```python
print (f(d)) # Τυπώνει μία λίστα με την απάντηση
```

### Άσκηση 45

Θεωρείστε το ίδιο dictionary με την άσκηση 41. 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary με την ίδια δομή όπως το d. Η συνάρτηση θα πρέπει να επιστρέφει το πλήθος από γονίδια των οποίων το πλήθος από μεταλλάξεις είναι μικρότερο από 100. Δηλαδή η συνάρτησή σας θα πρέπει να επιστρέφει έναν αριθμό:

```python
print (f(d)) # Τυπώνει έναν αριθμό με την απάντηση 
```

### Άσκηση 46

Θεωρείστε το ίδιο dictionary με την άσκηση 41. 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary με την ίδια δομή όπως το d. Η συνάρτηση θα πρέπει να επιστρέφει το άθροισμα όλων των exons τα οποία έχουν 5,6 ή 7 μεταλλάξεις. Δηλαδή η συνάρτησή σας θα πρέπει να επιστρέφει έναν αριθμό:

```python
print (f(d)) # Τυπώνει έναν αριθμό με την απάντηση 
```

### Άσκηση 47
Θεωρείστε το ίδιο dictionary με την άσκηση 41. 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary με την ίδια δομή όπως το d. Η συνάρτηση θα πρέπει να επιστρέφει το γονίδιο που έχει το δεύτερο μεγαλύτερο άθροισμα μεταλλάξεων. Δηλαδή θα πρέπει:

```python
print (f(d)) # Τυπώνει ένα string με την απάντηση
```

### Άσκηση 48
Θεωρείστε το ίδιο dictionary με την άσκηση 41. 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary με την ίδια δομή όπως το d. Η συνάρτηση θα πρέπει να επιστρέφει ένα dictionary όπου τα κλεδιά θα είναι τα ονόματα των γονιδίων και οι τιμές θα είναι ο μέσος όρος των μεταλλάξεων που έχουν όλα τα exons του. 

Για παράδειγμα αν ένα γονίδιο έχει τις εξής μεταλλάξεις στα exons του: `[1,5,8]`. Τότε ο μέσος όρος είναι `(1+5+8)/3 = 14/3`. Δηλαδή θα πρέπει:

```python
print (f(d)) # Τυπώνει ένα dictionary με την απάντηση 
```

### Άσκηση 49
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει ένα dictionary όπου σαν κλειδιά θα έχει όλους τους αριθμούς από το 100 μέχρι και το 200. Οι τιμές του κάθε κλειδιού θα είναι μία λίστα με τους παράγοντές του. Ο παράγοντας ενός αριθμού Ν είναι όλοι οι αριθμοί που τον διαιρούν ακριβώς, εκτός από το 1 και τον εαυτό του. Για παράδειγμα όλοι οι παράγοντες του 120 είναι: `[2, 3, 4, 5, 6, 8, 10, 12, 15, 20, 24, 30, 40, 60,]`

Δηλαδή θα πρέπει:
```python
print (f()) # Τυπώνει ένα dictionary
```

### Άσκηση 50

Συμπληρώστε τις τελίτσες παρακάτω:

```python
f = lambda ....
```

Έτσι ώστε όταν κάνω:

```python
print ( f(d) )
```

Να τυπώνει αυτό που ζητάει η άσκηση 42. 

Σημείωση: Απαγορεύεται να χρησιμοποιήσετε τη συνάρτηση της άσκησης 42 (ή οποιαδήποτε άλλη συνάρτηση πέρα από αυτές της python). Αυτό γιατί μία προφανής λύση θα ήταν: `f = lambda d : f_42(d)`

# Οι ασκήσεις 51-60 δεν έχουν καθαρογραφεί

### Άσκηση 51
Μέσα από την εφαρμογή notepad (ή κάτι παρόμοιο) δημιουργήστε ένα αρχείο με το όνομα `ask_51.txt` με το εξής περιεχόμενο:

```text
gene_1=1,4,5,6,7,8,4
gene_2=7,6,3,4,9,8,5,4
gene_3=8,7,3,4,7,8,9,1
gene_4=1,7,6,5,9,8,7
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο το όνομα ενός αρχείου. Το αρχείο θα πρέπει να έχει την ίδια δομή όπως το `ask_51.txt` (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα πρέπει να επιστρέφει ένα dictionary όπου τα κλειδιά θα είναι τα ονόματα των γονιδίων και οι τιμές μία λίστα με τις τιμές. Για παράδειγμα θα πρέπει:

```python
print (f('ask_51.txt'))
```


Θα τυπώνει το εξής dictionary:

```python
{
    'gene_1' : [1,4,5,6,7,8,4],
    'gene_2' : [7,6,3,4,9,8,5,4],
    'gene_3' : [8,7,3,4,7,8,9,1],
    'gene_4' : [1,7,6,5,9,8,7],
}

```


### Άσκηση 52
Μέσα από την εφαρμογή notepad (ή κάτι παρόμοιο) δημιουργήστε ένα αρχείο με το όνομα `ask_52.txt` με το εξής περιεχόμενο:

```text
gene_1:exons=7,mutations=10
gene_2:exons=3,mutations=6
gene_3:exons=3,mutations=9
gene_4:exons=9,mutations=13
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο το όνομα ενός αρχείου. Το αρχείο θα πρέπει να έχει την ίδια δομή όπως το `ask_52.txt` (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα πρέπει να επιστρέφει ένα dictionary όπου τα κλειδιά θα είναι τα ονόματα των γονιδίων και οι τιμές θα είναι dictionaries με κλειδιά τα `exons`, `mutations` και τιμές οι αντίστοιχες τιμές του αρχείου. Για παράδειγμα θα πρέπει:

```python
print (f('ask_52.txt'))
```


Θα τυπώνει το εξής dictionary:

```python
{
    'gene_1' : {'exons': 7, 'mutations': 10},
    'gene_2' : {'exons': 3, 'mutations': 6},
    'gene_3' : {'exons': 3, 'mutations': 9},
    'gene_4' : {'exons': 9, 'mutations': 13},
}
```


### Άσκηση 53
Μέσα από την εφαρμογή notepad (ή κάτι παρόμοιο) δημιουργήστε ένα αρχείο με το όνομα `ask_53.txt` με το εξής περιεχόμενο:

```text
gene_1:exons=7|4|1,mutations=10
gene_2:exons=8|6|2,mutations=6
gene_3:exons=9|10|3,mutations=9
gene_4:exons=1|5|1,mutations=13
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο το όνομα ενός αρχείου. Το αρχείο θα πρέπει να έχει την ίδια δομή όπως το `ask_53.txt` (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα πρέπει να επιστρέφει ένα dictionary όπου τα κλειδιά θα είναι τα ονόματα των γονιδίων και οι τιμές θα είναι dictionaries με κλειδιά τα `exons` και `mutations`. Για το `exons` οι τιμές πρέπει να είναι λίστες. Για παράδειγμα θα πρέπει:

```python
print (f('ask_53.txt'))
```


Θα τυπώνει το εξής dictionary:

```python
{
    'gene_1' : {'exons': [7,4,1], 'mutations': 10},
    'gene_2' : {'exons': [8,6,2], 'mutations': 6},
    'gene_3' : {'exons': [9,10,3], 'mutations': 9},
    'gene_4' : {'exons': [1,5,1], 'mutations': 13},
}
```



### Άσκηση 54
Μέσα από την εφαρμογή notepad (ή κάτι παρόμοιο) δημιουργήστε ένα αρχείο με το όνομα `ask_54.txt` με το εξής περιεχόμενο:

```text
gene_1:disease_8,disease_5,disease_1,disease_3
gene_2:disease_6,disease_1,disease_9
gene_3:disease_1,disease_4,disease_10,disease_2
gene_4:disease_3,disease_2
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο το όνομα ενός αρχείου. Το αρχείο θα πρέπει να έχει την ίδια δομή όπως το `ask_54.txt` (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα πρέπει να επιστρέφει ένα dictionary όπου τα κλειδιά θα είναι τα ονόματα των ασθενειών (disease_XXX) και οι τιμές θα είναι λίστες με όλα τα ονόματα γονίδιων (gene_XXX) οι οποίες έχουν συσχετιστεί με αυτές. Για παράδειγμα θα πρέπει:

```python
print (f('ask_54.txt'))
```


Θα τυπώνει το εξής dictionary:

```python
{
    'disease_1' : ['gene_1', 'gene_2', 'gene_3'],
    'disease_2' : ['gene_3', 'gene_4'],
    'disease_3' : ['gene_1', 'gene_4'],
    'disease_4' : ['gene_3']
    'disease_5' : ['gene_1'],
    'disease_6' : ['gene_2'],
    'disease_8' : ['gene_1', 'gene_2', 'gene_3'],
    'disease_9' : ['gene_2'],
    'disease_10' : ['gene_3'],
}
```



### Άσκηση 55
Μέσα από την εφαρμογή notepad (ή κάτι παρόμοιο) δημιουργήστε ένα αρχείο με το όνομα `ask_55.txt` με το εξής περιεχόμενο:


```
|========|============|============|============|============|============|
|  DATA  | Species_KL | Species_LM | Species_MN | Species_NO | Species_OP |
|========|============|============|============|============|============|
| Env_7  |       0    |     1      |     1      |     2      |     1      |
| Env_8  |       1    |     0      |     2      |     0      |     1      |
| Env_17 |       3    |     0      |     1      |     1      |     1      |
| Env_62 |       0    |     2      |     1      |     0      |     0      |
| Env_19 |       1    |     2      |     3      |     1      |     0      |
| Env_51 |       2    |     1      |     2      |     1      |     2      |
| Env_81 |       1    |     0      |     0      |     1      |     1      |
| Env_18 |       0    |     0      |     3      |     1      |     0      |
|========|============|============|============|============|============|
```

Το αρχείο αυτό περιέχει τη καταμέτρηση του πλήθους 5 διαφορετικών ειδών (Species...) σε 8 διαφορετικά περιβάλλονα (Env....). Για παράδειγμα υπάρχουν 2 `Species_MN` στο περιβάλλον `Env_51`. Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο το όνομα ενός αρχείου το οποίο θα έχει την ίδια δομή όπως το `ask_55.txt` (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα επιστρέφει το περιβάλλον το οποίο έχει το μεγαλύτερο άθροισμα από όλα τα είδη. Για παράδειγμα θα πρέπει:

```python
print (f('ask_55.txt')) # Τυπώνει: Env_51  (To Env_51 έχει συνολικά 8 είδη, κανένα άλλο περιβάλλον δεν έχει μεγαλύτερο άθροισμα από είδη)
```



### Άσκηση 56
Μέσα από την εφαρμογή notepad (ή κάτι παρόμοιο) δημιουργήστε ένα αρχείο με το όνομα `ask_56.txt` με το εξής περιεχόμενο:


```
|========|============|============|============|============|============|
|  DATA  | Species_KL | Species_LM | Species_MN | Species_NO | Species_OP |
|========|============|============|============|============|============|
| Env_7  |       0    |     1      |     1      |     2      |     1      |
| Env_8  |       1    |     0      |     2      |     0      |     1      |
| Env_17 |       3    |     0      |     1      |     1      |     1      |
| Env_62 |       0    |     2      |     1      |     0      |     0      |
| Env_19 |       1    |     2      |     3      |     1      |     0      |
| Env_51 |       2    |     1      |     2      |     1      |     2      |
| Env_81 |       1    |     0      |     0      |     1      |     1      |
| Env_18 |       0    |     0      |     3      |     1      |     0      |
|========|============|============|============|============|============|
```

Το αρχείο αυτό περιέχει τη καταμέτρηση του πλήθους 5 διαφορετικών ειδών (Species...) σε 8 διαφορετικά περιβάλλονα (Env....). Για παράδειγμα υπάρχουν 2 `Species_MN` στο περιβάλλον `Env_51`. Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο το όνομα ενός αρχείου το οποίο θα έχει την ίδια δομή όπως το `ask_56.txt` (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα επιστρέφει το είδος το οποίο έχει το μεγαλύτερο άθροισμα σε όλα τα περιβάλλοντα. Για παράδειγμα θα πρέπει:

```python
print (f('ask_56.txt')) # Τυπώνει: Species_MN  (υπάρχουν συνολικό 13 Species_MN σε όλα τα περιβάλλοντα και κανένα άλλο είδος δεν έχει μεγαλύτερο άθροισμα)
```



### Άσκηση 57

Μέσα από την εφαρμογή notepad (ή κάτι παρόμοιο) δημιουργήστε ένα αρχείο με το όνομα `ask_57.txt` με το εξής περιεχόμενο:

```text
gene_1:exons=7,mutations=10
gene_2:exons=3,mutations=6
gene_3:exons=3,mutations=9
gene_4:exons=9,mutations=13
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 παράμετρους. Η πρώτη θα είναι το όνομα ενός αρχείο με την ίδια δομή όπως το `ask_57.txt` (δεν χρειάζεται να το ελέγξετε αυτό). Η δεύτερη θα είναι το όνομα ενός αρχείο το οποίο δεν θα υπάρχει (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση διαβάζει το αρχείο της πρώτης παραμέτρου και θα πρέπει να φτιάχνει ένα αρχείο με το όνομα της δεύτερης παραμέτρου. Το αρχείο αυτό θα έχει την ίδια πληροφορία αλλά δομημένη με τον παρακάτω τρόπο:

```text
genes:gene_1,gene_2,gene_3,gene_4
exons:7,3,3,9
mutations:10,6,9,3
```

Για παράδειγμα θα πρέπει:

```python

f('ask_57.txt', 'ask_57_new.txt')

with open('ask_57_new.txt') as f:
    for l in f:
        print (l.strip())

```

Τυπώνει:

```text
genes:gene_1,gene_2,gene_3,gene_4
exons:7,3,3,9
mutations:10,6,9,3
```

Σημείωση: Εννοείται ότι για να ελέγξω την υλοποίησή σας εγώ θα βάλω διαφορετικό αρχείο στη 1η παράμετρο, αλλά με την ίδια δομή. Το αρχείο μπορεί να έχει περισσότερα (ή λιγότερα) από 4 γονίδια, αλλά πάντα θα έχει exons και mutations για το κάθε γονίδιο.


### Άσκηση 58
(το αντίθετο της άσκησης 57)

Μέσα από την εφαρμογή notepad (ή κάτι παρόμοιο) δημιουργήστε ένα αρχείο με το όνομα `ask_58.txt` με το εξής περιεχόμενο:

```text
genes:gene_1,gene_2,gene_3,gene_4
exons:7,3,3,9
mutations:10,6,9,3
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 παράμετρους. Η πρώτη θα είναι το όνομα ενός αρχείο με την ίδια δομή όπως το `ask_58.txt`. Η δεύτερη θα είναι το όνομα ενός αρχείο το οποίο δεν θα υπάρχει (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα διαβάζει το αρχείο της πρώτης παραμέτρου και θα πρέπει να φτιάχνει ένα αρχείο με το όνομα της δεύτερης παραμέτρου. Το αρχείο αυτό θα έχει την ίδια πληροφορία αλλά δομημένη με τον παρακάτω τρόπο:


```text
gene_1:exons=7,mutations=10
gene_2:exons=3,mutations=6
gene_3:exons=3,mutations=9
gene_4:exons=9,mutations=3
```


Για παράδειγμα θα πρέπει:

```python

f('ask_58.txt', 'ask_58_new.txt')

with open('ask_58_new.txt') as f:
    for l in f:
        print (l.strip())

```

Τυπώνει:

```text
gene_1:exons=7,mutations=10
gene_2:exons=3,mutations=6
gene_3:exons=3,mutations=9
gene_4:exons=9,mutations=13
```

Σημείωση: Εννοείται ότι για να ελέγξω την υλοποίησή σας εγώ θα βάλω διαφορετικό αρχείο στη 1η παράμεοτρο, αλλά με την ίδια δομή. Το αρχείο μπορεί να έχει περισσότερα (ή λιγότερα) από 4 γονίδια, αλλά πάντα θα έχει exons και mutations για το κάθε γονίδιο.



### Άσκηση 59
Σε αυτό το link: https://www.dropbox.com/s/s4gf6lijg508yuy/variant_associations.tsv?dl=1 υπάρχει ένα αρχείο με διάφορες πληροφορίες για μεταλλάξεις οι οποίες έχουν συσχετιστεί με ασθένεις. Το αρχείο προέρχεται από τη βάση δεδομένων [DisGenNET](https://www.disgenet.org/). Οι πρώτες 5 γραμμές του αρχείου είναι:

```text
snpId   class   chromosome  position    most_severe_consequence DSI DPI NofDiseases NofPmids
rs1000005   snv 21   33060745   intron variant          1   1
rs10000770  snv 4   142693109   intron variant  1   0.04    1   1
rs1000091588    snv 11   68935374   stop gained 1   0.12    1   1
rs1000096   snv 4    38691214   intron variant          1   1
```

Όπως παρατηρούμε η πρώτη γραμμή περιέχει μία επικεφαλίδα με τους τίτλους της κάθε στήλης. Οι στήλες χωρίζονται με τον χαρακτήρα tab (`\t`), οπότε θα χρειαατεί να κάνετε `line.split('\t')` για να πάρετε μία λίστα με όλα τα πεδία κάθε γραμμής. Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο τη τοποθεσία (path) του αρχείου. Η συνάρτηση θα επιστρέφει το πλήθος των μεταλλάξεων (ή αλλιώς των γραμμών) για τις οποίες η τιμη της στήλης `most_severe_consequence` είναι `3 prime UTR variant`. 


Για παράδειγμα θα πρέπει:

```python
print (f('variant_associations.tsv')) # Τυπώνει έναν αριθμό
```

* Σημείωση 1: απαγορεύεται να κάνετε import κάτι (p.x. `import csv`)
* Σημείωση 2: απαγορεύεται να κάνετε `f.read()` ή `f.readlines()`, δηλαδή απαγορεύεται να διαβάσετε όλο το αρχείο απευθείας στη μνήμη. Θα πρέπει να το διαβάσετε γραμμή-γραμμή.

### Άσκηση 60
Θωρήστε το ίδιο αρχείο με την άσκηση 59. Φτιάξτε μία συνάρτηση η οποία θα παίρνει δύο παράμετρους. Η πρώτη θα είναι το όνομα του αρχείου της άσκησης 59 και η δεύτερη θα είναι το όνομα ενός αρχείου το οποίο δεν θα υπάρχει (δεν χρειάζεται να τα ελέγξετε αυτά). Η συνάρτηση θα φτιάχνει ένα αρχείο με το όνομα της 2ης παραμέτρου το οποίο θα έχει 26 γραμμές. Η πρώτη θα είναι μία επικεφαλίδα και θα ακολουθουν 25 γραμμές όσες και το πλήθος των χρωμοσωμάτων + το μιτοχονδριακό DNA (δηλαδή 1-22, Χ,Υ, ΜΤ). Κάθε γραμμή θα πρέπει να περιέχει το όνομα του χρωμοσώματος (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,Χ,Υ,ΜΤ) και το πλήθος από μεταλάξεις που έχει για τις οποίες η στήλη `most_severe_consequence` του αρχείου της 1ης παραμέτρου έχει τιμή: `3 prime UTR variant`. Το φορμάτ του αρχείου μπορεί να είναι όπως θέλετε εσείς αρκεί να υπάρχει η παραπάνω πληροφορία για κάθε γραμμή. Για παράδειγμα θα πρέπει:

```python
f('variant_associations.tsv'. 'ask_60_new.txt')

with open('ask_60_new.txt') as f:
    for l in f:
        print (l.strip())

```

Τυπώνει (προσοχή το 100 το έχω βάλει εδώ τυχαία, εσείς θα πρέπει να βάλετε τη σωστή τιμή για κάθε χρωμόσωμα):

```
Chromosome,3 prime UTR variants
1,100
2,100
3,100
4,100
5,100
6,100
7,100
8,100
9,100
10,100
11,100
12,100
13,100
14,100
15,100
16,100
17,100
18,100
19,100
20,100
21,100
22,100
X,100
Y,100
MT,100
```

* Σημείωση 1: απαγορεύεται να κάνετε import κάτι (p.x. `import csv`)
* Σημείωση 2: απαγορεύεται να κάνετε `f.read()` ή `f.readlines()`, δηλαδή απαγορεύεται να διαβάσετε όλο το αρχείο απευθείας στη μνήμη. Θα πρέπει να το διαβάσετε γραμμή-γραμμή.

### Άσκηση 61
Ας υποθέσουμε ότι τα κλειδιά στο παρακάτω dictionary περιέχουν τα ονόματα κάποιων ασθενειών και οι τιμές είναι σύνολα με τα μονοπάτια (pathways) με τα οποία οι ασθένειες έχουν συσχετιστεί. 

```python
diseases = {
 'disease_1':  {'pathway_4', 'pathway_1', 'pathway_5', 'pathway_6'},
 'disease_2':  {'pathway_2', 'pathway_8'},
 'disease_3':  {'pathway_10', 'pathway_5', 'pathway_6', 'pathway_8','pathway_9'},
 'disease_4':  {'pathway_10'},
 'disease_5':  {'pathway_2', 'pathway_1', 'pathway_8'},
 'disease_6':  {'pathway_9', 'pathway_1', 'pathway_8'},
 'disease_7':  {'pathway_9', 'pathway_5'},
 'disease_8':  {'pathway_9', 'pathway_5', 'pathway_3', 'pathway_10'},
 'disease_9':  {'pathway_9', 'pathway_1', 'pathway_4'},
 'disease_10': {'pathway_4', 'pathway_10'},
}

```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει δύο παράμετρους: ένα dictionary με την ίδια δομή όπως τα diseases (δεν χρειάζεται να το ελέγξετε αυτό) και το όνομα ενός pathway. H συνάρτηση θα πρέπει να επιστρέφει μία λίστα με τους κωδικούς της ασθένειας οι οποίες έχουν συσχετιστεί με αυτο το pathway. H συνάρτηση θα πρέπει να επιστρέφει τους ακέραιους κωδικούς της ασθένεας. Για παράδειγμα θα πρέπει:

```python
print (f(diseases, 'pathway_4')) # τυπώνει [1, 9, 10] 
```


* Σημείωση 1: Μην χρησιμοποιήσετε comprehension
* Σημείωση 2: Μην χρησιμοποιήσετε map / filter
* Σημείωση 3: Με τον τελεστή `in` μπορούμε να ελέγξουμε αν ένα αντικείμενο υπάρχει σε ένα σύνολο.

### Άσκηση 62
Υλοποιήσετε την άσκηση 61 με comprehension

### Άσκηση 63
Υλοποιήσετε την άσκηση 61 με map / filter, χωρίς lambda 

### Άσκηση 64 
Υλοποιήσετε την άσκηση 61 με map / filter, με lambda  

### Άσκηση 65 
Εκτός από το dictionary της άσκησης 61 έχουμε τώρα και το παρακάτω dictionary το οποίο περιέχει για κλειδιά τα ονόματα των pathways, και για τιμές σύνολα με τα γονίδια τα οποία περιέχουν:

```python
pathways = {
 'pathway_1': {'gene_4', 'gene_2', 'gene_7', 'gene_1', 'gene_5'},
 'pathway_2': {'gene_10', 'gene_4', 'gene_2'},
 'pathway_3': {'gene_2', 'gene_1', 'gene_5'},
 'pathway_4': {'gene_6', 'gene_9', 'gene_10', 'gene_2', 'gene_7'},
 'pathway_5': {'gene_6', 'gene_3', 'gene_10', 'gene_2', 'gene_7'},
 'pathway_6': {'gene_6', 'gene_3', 'gene_10', 'gene_2', 'gene_1', 'gene_5'},
 'pathway_7': {'gene_3', 'gene_5', 'gene_10', 'gene_8', 'gene_7'},
 'pathway_8': {'gene_10', 'gene_3'},
 'pathway_9': {'gene_3', 'gene_8', 'gene_5'},
 'pathway_10': {'gene_6', 'gene_3', 'gene_4', 'gene_7', 'gene_8'},
}
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρία ορίσματα: ένα dictionary με την ίδια δομή όπως το `diseases`, ένα dictionary με την ίδια δομή όπως το `pathways` και ένα string (δεν χρειάζεται να τα ελέγξετε αυτά). H συνάρτηση θα επιστρέφει **ένα σύνολο** με τους κωδικούς των diseases των οποίων τα pathways περιέχουν το γονίδιο με το όνομα της 3ης παραμέτρου. Για παράδειγμα θα πρέπει:

```python
print (f(diseases, pathways, 'gene_4')) 

# Τυπώνει:
 {'disease_1',
 'disease_10',
 'disease_2',
 'disease_3',
 'disease_4',
 'disease_5',
 'disease_6',
 'disease_8',
 'disease_9'}
``` 

Σημείωση: Μην την υλοποίσετε με comprehension

### Άσκηση 66 
Υλοποίησετε την άσκηση 65 με comprehension

### Άσκηση 67 
(Το αντίθετο τηε άσκησης 65/66)

Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρία ορίσματα: ένα dictionary με την ίδια δομή όπως το `diseases`, ένα dictionary με την ίδια δομή όπως το `pathways` και ένα string (δεν χρειάζεται να τα ελέγξετε αυτά). H συνάρτηση θα επιστρέφει **ένα σύνολο** με τους κωδικούς των diseases των οποίων τα pathways **ΔΕΝ** περιέχουν το γονίδιο με το όνομα της 3ης παραμέτρου. Για παράδειγμα θα πρέπει:

```python
print (f(diseases, pathways, 'gene_4')) # Τυπώνει {'disease_7'}
```

Επεξήγηση: Το `disease_7` περιέχει το `pathway_9` και το `pathway_5`. Κανένα από αυτά τα δύο δεν έχει το `gene_4`

Σημείωση: Πρέπει να χρησιμοποιήσετε την υλοποίηση της ασκήσης 65 ή 66.

### Άσκηση 68
Φτιάξτε μία συνάρτηση η οποία θα παίρνει δύο ορίσματα: ένα dictionary με την ίδια δομή όπως το `diseases` και ένα dictionary με την ίδια δομή όπως το `pathways` (δεν χρειάζεται να τα ελέγξετε αυτά). Η συνάρτηση θα φτιάχνει και θα επιστρέφει ένα dictionary το οποίο θα έχει τα ίδια κλειδιά με το `diseases` και σαν τιμές θα έχει το πλήθος των διαφορετικών γονιδίων που υπάρχουν σε όλα τα pathways αυτού του disease. Για παράδειγμα θα πρέπει:

```python

print (f(diseases, pathways))

# Τυπώνει:
{'disease_1': 9,
 'disease_2': 4,
 'disease_3': 9,
 'disease_4': 5,
 'disease_5': 7,
 'disease_6': 8,
 'disease_7': 7,
 'disease_8': 9,
 'disease_9': 10,
 'disease_10': 8}

```

Σημείωση: Πρέπει να την υλοποίσετε με comprehension. Αν την υλοποιήσετε χωρίς comprehension θα βαθμολογηθεί με 7/10. 

### Άσκηση 69
Φτιάξτε έναν generator ο οποίος θα παίρνει δύο ορίσματα: ένα dictionary με την ίδια δομή όπως το `diseases` και ένα dictionary με την ίδια δομή όπως το `pathways` (δεν χρειάζεται να τα ελέγξετε αυτά). Ο generator θα κάνει.. generate tuples τα οποία θα περιέχουν τρία στοιχεία: ένα disease, ένα pathway και ένα gene. Για κάθε tuple θα πρέπει το pathway να ανήκει στο disease καθώς και το gene να ανήκει στο pathway. Για παράδειγμα θα πρέπει:

```python

g = f(diseases, pathways)

print (next(g)) # Τυπώνει ('disease_1', 'pathway_4', 'gene_6')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_4', 'gene_9')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_4', 'gene_10')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_4', 'gene_2')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_4', 'gene_7')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_1', 'gene_4')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_1', 'gene_2')

```


### Άσκηση 70 
Υλοποιήστε την άσκηση 69 με generator comprehension. Δλδ θα πρέπει:

```python

g = ( ...ΤΟ ΦΑΝΤΑΣΤΙΚΟ GENERATOR COMPREHENSION ΣΑΣ... )

print (next(g)) # Τυπώνει ('disease_1', 'pathway_4', 'gene_6')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_4', 'gene_9')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_4', 'gene_10')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_4', 'gene_2')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_4', 'gene_7')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_1', 'gene_4')
print (next(g)) # Τυπώνει ('disease_1', 'pathway_1', 'gene_2')

```


