
## Σημειώσεις για όλες τις ασκήσεις
* **ΑΠΑΓΟΡΕΥΕΤΑΙ** να κάνετε: ```a = input("...")``` (και γενικότερα μην το κάνετε ποτέ αυτό..)
* Όταν η εκφώνηση λέει ότι πρέπει να φτιάξετε συνάρτηση.. πρέπει να φτιάξετε συνάρτηση!
* Αν η εκφώνηση λέει ότι η συνάρτηση πρέπει να επιστρέφει κάτι.. τότε μέσα στη συνάρτησή σας πρέπει κάπου να κάνετε ```return```.
* Διαβάστε αυτή τη [λίστα με το κοινά λάθη](common_errors.md) που κάνουν συνήθως αρχάριοι στη python και στον προγραμματισμό.  
* **ΠΡΟΣΟΧΗ! Μην**  κάνετε: ```return True```  ή ```return False```  μετά από if


Για παράδειγμα, έστω ότι η άσκηση λέει: 

Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν αριθμό. Η συνάρτηση θα πρέπει να επιστρέφει:
* ```True``` αν ο αριθμός είναι μονός
* ```False``` αν ο αριθμός είναι ζυγός (άρτιος).

Τι να **ΜΗΝ** κάνετε:
```python
def f(n):
    if n%2 == 1:
        return True
    else:
        return False

```

Τι να κάνετε:
```python
def f(n):
    return n%2 == 1
```

Μπορείτε φυσικά να κάνετε `return True` ή `return False`, αν δεν μπορείτε να το απλοποιήσετε όπως παραπάνω.

* **ΑΠΑΓΟΡΕΥΕΤΑΙ** Να χρησιμοποιήσετε τα εξής ονόματα μεταβλητών: `str`, `id`, `int`, `list`, `tuple`, `dict`. Αυτά είναι ονόματα συναρτήσεων της python. Η python σας αφήνει να τα χρησιμοποιήσετε με το "κόστος" ότι χάνεται η αρχική τους χρήση. π.χ:

```python
print (str(55))

str = 'Mitsos'
print (str(55))
```  

* Πάντα να βάζετε ένα σχόλιο πριν από την υλοποίηση με τον αριθμό της άσκησης που λύνεται. Για παράδειγμα:
```python

# άσκηση 42
def f(x):
    return x+1
```
* Θα παρατηρήσετε ότι οι περισσότερες συναρτήσεις σας ζητάνε να φτιάξετε μία συνάρτηση με συγκεκριμμένους παράμετρους. Εκτός αν το ζητάει η άσκηση, δεν χρειάζεται να ελέξετε αν οι τύποι των παραμέτρων είναι αυτός που ζητείται. Για παράδειγμα: 

> Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 2 ακέραιους αριθμούς...

Εσεις δεν χρειάζεται να ελέγξετε ότι όντως είναι ακέραιοι οι παράμετροι της συνάρτησης. 

* Μην κάνετε import βιβλιοθήκες, εκτός αν το ζητάει η άσκηση.


## Λίστα με τις ασκήσεις

### Άσκηση 1
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 2 αριθμούς. Η συνάρτηση θα επιστρέφει τον μέσο όρο των δύο αριθμών. Για παράδειγμα θα πρέπει:

```python

print (f(3,7)) # Τυπώνει: 5 
```

### Άσκηση 2
Φτιάξτε μία συνάρτηση η οποία θα παίρει σαν παράμετρο 3 αριθμούς. Η συνάρτηση θα επιστρέφει τον μέσο όρο των τριών αριθμών. Είναι υποχρεωτικό να χρησιμοποιήσετε τη συνάρτηση που φτιάξατε στη 1η άσκηση. Για παράδειγμα θα πρέπει:

```python
print (f(3,7,2)) # Τυπώνει 4  (δηλαδή (3+7+2)/3)  
```

Hint: αν `μ` είναι ο μέσος όρος των `α`,`β`. Τότε ο μέσος όρος των α,β,γ είναι: ((m\*2) + γ)/3 

### Άσκηση 3
Φιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 5 αριθμούς. Η συνάρτηση θα επιστρέφει τον μέσο όρο των 5 αριθμών. Είναι υποχρεωτικό να χρησιμοποιήσετε τη συνάρτηση της άσκησης 2 και τη συνάρτηση της άσκησης 1. Για παράδειγμα θα πρέπει:

```python
print (f(4,6,8,11,2)) # Τυπώνει 6.2 (δηλαδή: (4+6+8+11+2)/5)
```

Hint: αν `μ` είναι ο μέσoς όρος των `α`,`β` και `ν` είναι ο μέσος όρος των `γ`,`δ`,`ε`. Τότε ο μέσος όρος των `α`,`β`,`γ`,`δ`,`ε` είναι: ((μ\*2) + (ν\*3))/5.

### Άσκηση 4
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 2 αριθμούς. H συνάρτηση θα υπολογίζει το [Heronian Mean](https://en.wikipedia.org/wiki/Heronian_mean) αυτών των 2 αριθμών. Είναι υποχρεωτικό να χρησιμοποιήσετε τη συνάρτηση της 2ης άσκησης. Για παράδειγμα θα πρέπει:

```python
print (f(3,7)) # Τυπώνει 4.860858564985279 
```

Hint: H τετραγωνική ρίζα ενός αριθμού υπολογίζεται με: ```x**0.5``` . π.χ. `print(16**0.5)`, τυπώνει 4.


### Άσκηση 5
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 3 αριθμούς α,β,γ. Η συνάρτηση θα επιστρέφει: 

* `True` αν ο αριθμός β είναι μεγαλύτερος από το α και μικρότερος από το γ.
* `False` διαφορετικά 

Για παράδειγμα:

```python
print (f(1,3,5)) # Τυπώνει True
print (f(1,6,5)) # Τυπώνει False
```

* Σημείωση 1: Απαγορεύεται να χρησιμοποιήσετε την if. 
* Σημείωση 2: Η συνάρτηση θα επιστρέφει μία λογική τιμή, όχι αλφαριθμητικό. Για παράδειγμα μη μπερδέψετε το `True` με το  `'True'`

### Άσκηση 6
Φτιάξτε μία συνάρτηση η οποία θα παίρνει για παράμετρο 4 αριθμούς α,β,γ,δ . Η συνάρτηση θα επιστρέφει:

* `True` , αν το α είναι μικρότερο του β και το β μικρότερο του γ και το γ μικρότερο του δ.
* `False`, αν δεν ισχύει το παραπάνω.

 Για παράδειγμα θα πρέπει:

```python
print (f(1,2,3,4,)) # Τυπώνει True
print (f(1,2,4,3,)) # Τυπώνει False
print (f(2,1,3,4,)) # Τυπώνει False
```

* Σημείωση 1: Απαγορεύεται να χρησιμοποιήσετε την if. 
* Σημείωση 2: Είναι υποχρεωτικό να χρησιμοποιήσετε την συνάρτηση της άσκησης 5

### Άσκηση 7
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 4 αριθμούς α,β,γ,δ. Η συνάρτηση θα πρέπει να επιστρέφει:

* `False`, αν δεν είναι όλοι διαφορετικοί
* `True`, αν οι 4 αριθμοί είναι ταξινομημένοι από τον μεγαλύτερο στον μικρότερο (δηλαδή α>β>γ>δ).
* `False`, αν δεν είναι ταξινομημένοι από τον μεγαλύτερο στον μικρότερο.

Δηλαδή θα πρέπει:

```python
print (f(1,2,3,3)) # Τυπώνει False
print (f(1,2,3,1)) # Τυπώνει False
print (f(1,2,3,4)) # Τυπώνει False
print (f(7,5,3,1)) # Τυπώνει True
print (f(7,5,1,3)) # Τυπώνει False
print (f(7,1,5,3)) # Τυπώνει False
print (f(1,7,5,3)) # Τυπώνει False
```

* Σημείωση 1: είναι υποχεωτικό να χρησιμοποιήσετε τη συνάρτηση της άσκησης 6.
* Σημείωση 2: Απαγορεύεται να χρησιμοποιήσετε την if. 

### Άσκηση 8
Δύο γονίδια Α και Β είναι μεταγραφικοί παράγοντες σε ένα τρίτο γονίδιο Γ. Αν και τα δύο γονίδια Α και Β είναι ανενεργά τότε το Γ είναι ενεργό. Αν ένα από τα Α και Β είναι ενεργό, τότε το Γ είναι ενεργό. Αν όμως τα γονίδια Α και Β είναι και τα δύο ενεργά, τότε αλληλοεπιδρούν και φτιάχνουν μία πρωτεΐνη η οποία εξουδετερώνει τη δράση του Γ, οπότε το γονίδιο Γ δεν ενεργοποιείται.

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 2 λογικές τιμές την Α και Β. Η συνάρτηση θα επιτρέφει:

* `True`, αν οι τιμές των Α και Β είναι τέτοιες που να ενεργοποιούν το γονίδιο Γ.
* `False`, αν οι τιμές των Α και Β είναι τέτοιες που να απενεργοποιούν το γονίδιο Γ.

Δηλαδή θα πρέπει:

```python
print(f(True, True)) # Τυπώνει False
print(f(True, False)) # Τυπώνει True
print(f(False, True)) # Τυπώνει True
print(f(False, False)) # Τυπώνει True
```

Η υλοποίησή σας θα πρέπει να συμπληρώνει τις τελίστες στη παρακάτω συνάρτηση:

```python
def f(A,B):
    return ............
```

### Άσκηση 9
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 2 παράμετρους α και β οι οποίες θα είναι αλφαριθμητικά. Η συνάρτηση θα επιστρέφει:

* `True` αν το αντίστροφο του α υπάρχει στο τέλος του β
* `False` αν δεν ισχύει το παραπάνω

Για παράδειγμα θα πρέπει:

```python
print (f('si', 'Alexis')) # Τυπώνει True ( το αντίστροφο του si είναι το is το οποίο υπάρχει στο τέλος του Alexis)
print (f('is', 'Alexis')) # Τυπώνει False

```

Σημείωση: Απαγορεύεται να χρησιμοποιήσετε την if. 

### Άσκηση 10
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα αλφσαριθμητικό το οποίο θα είναι μία ακολουθία DNA. Η συνάρτηση θα επιστρέφει ένα string το οποίο θα περιέχει το 2ο νουκλεοτίδιο κάθε codon. Για παράδειγμα θα πρέπει:

```python
print (f('ACGTGAAAGGTT')) # Τυπώνει `CGAT`
```

Επεξήγηση:
```
ACGTGAAAGGTT  --> Σε codons:

ACG | TGA | AAG| GTT  -> το 2ο γράμμα κάθε codon είναι:
 |     |     |    |
 C     G     A    T

```

### Άσκηση 11
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο το ύψος και το βάρος ενός ανθρώπου. Η συνάρτηση θα πρέπει:
* Αν το ύψος είναι μεγαλύτερο από 2.30 ή μικρότερο από 1 μέτρο, να επιστρέφει "λάθος τιμές για ύψος"
* Αν το βάρος είναι μεγαλύτερο από 200 ή μικρότερο από 30, να επιστρέφει "λάθος τιμές για βάρος"
* Υπολογίζει το BMI (βάρος/(ύψος<sup>2</sup>))
* Αν το BMI είναι μικρότερο από 19 επιστρέφει "αδύνατο"
* Αν το BMI είναι ίσο με 19 και μικρότερο από 25 επιστρέφει "φυσιολογικό"
* Αν το BMI είναι ίσο με 25 και μικρότερο από 30 επιστρέφει "υπέρβαρο"
* Αν το BMI είναι ίσο με 30 ή μεγαλύτερο επιστρέφει "παχύσαρκο"


### Άσκηση 12
Υλοποιήστε την άσκηση 8 με if

### Άσκηση 13
Η ενεργοποίηση του [Lac operon](https://en.wikipedia.org/wiki/Lac_operon) στα βακτήρια απαιτεί ένα αρκετό πολύπλοκο σύστημα από πρωτεϊνικές αλληλεπιδράσεις. Αν το απλοποιήσουμε λίγο μπορούμε να πούμε ότι:

* Το lac operon δεν είναι ενεργοποιημένο αν δεν υπάρχει λακτόζη.
* Αν υπάρχει λακτόζη αλλά υπάρχει και γλυκόζη, τότε πάλι το lac operon είναι απενεργοποιημένο
* Αν υπάρχει λακτόζη αλλά δεν υπάρχει γλυκόζη τότε η ενεργοποίηση του lac operon εξαρτάται από τη συγκέντρωση του [cAMP](https://en.wikipedia.org/wiki/Cyclic_adenosine_monophosphate). Αν η συγκέτρωση είναι πάνω από 0.2 τότε το lac operon ενεργοποιείται, αλλιως δεν ενεργοποιείται. 

Φτιάξτε μία συνάρτηση η οποία θα παίρνει 3 παραμέτρους, lactose_present, glucose_present και cAMP_concentration. Οι πρώτες δύο θα είναι λογικές μεταβλητές και η τρίτη (cAMP_concentration) θα είναι αριθμητική. Η συνάρτηση θα πρέπει να επιστρέφει True ή False ανάλογα με το αν οι τιμές των παραμέτρων είναι κατάλληλες για να ενεργοποιηθεί το Lac operon 

Για παράδειγμα θα πρέπει:

```python
print (f(False, False, 0.5)) # Τυπώνει False
print (f(False, True, 0.1)) # Τυπώνει False
print (f(True, True, 0.1)) # Τυπώνει False
print (f(True, True, 0.5)) # Τυπώνει False
print (f(True, False, 0.5)) # Τυπώνει True
print (f(True, False, 0.1)) # Τυπώνει False
```


### Άσκηση 14
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 4 αριθμητικούς παραμέτρους α,β,γ,δ. Η συνάρτηση θα πρέπει να επιτρέφει True αν το διάστημα [α,β] έχει κάποια τομή με το διάστημα [γ,δ]. Αν δεν υπάρχει κάποια τομή μεταξύ τους, επιστρέφει False.  Αν το [α,β] είναι "μέσα" στο [γ,δ] ή το [γ,δ] μέσα στο [α,β] τότε πάλι επιστρέφει False. Για παράδειγμα θα πρέπει:

```python
print (f(1,3,5,7)) # Τυπώνει False: το διάστημα [1,3] δεν έχει τομή με το διάστημα [5,7]
print (f(1,3,2,5)) # Τυπώνει True: το [1,3] έχει τομή με το [2,7]
print (f(2,5,1,3)) # Τυπώνει True: το [2,5] έχει τομή με το [1,3]
print (f(1,3,0,4)) # Τυπώνει False: το [1,3] είναι όλο μέσα στο [0,4]
print (f(2,8,3,5)) # Τυπώνει False: το [3,5] είναι όλο μέσα στο [2,8] 
```

* Σημείωση 1: απαγορεύετσαι να χρησιμοποιήσετε for (ή κάποια άλλη επανάληψη). Θα πρέπει να το υλοποιήσετε μόνο με if
* Σημείωση 2: Στην άσκηση αυτή θεωρούμε ότι τα διαστήματα είναι ανοιχτά. Δηλαδή το διάστημα [1,2] δεν έχει κοινό με το διάστημα [2,3]. 

### Άσκηση 15
Φτιάξτε μία συνάρτηση η οποία θα παίρνει τους εξής παραμέτρους: credit_score (αριθμητική), income (αριθμητική), employment_status (string), current_debt (αριθμητική), loan_amount (αριθμητική). Υποθέτουμε ότι μία τράπεζα δίνει ένα δάνεια αν ([και μόνο αν](https://el.wikipedia.org/wiki/%CE%91%CE%BD_%CE%BA%CE%B1%CE%B9_%CE%BC%CF%8C%CE%BD%CE%BF_%CE%B1%CE%BD)) συντρέχουν όλοι οι παρακάτω όροι:

1. To `credit_score` είναι πάνω από 600
2. Το `income` είναι πάνω από 20000
3. To `employment_status` είναι είτε `"full_time"` είτε `"part_time"`
4. To `debt_to_income_ratio` το οποίο είναι ο λόγος του `current_debt` με το `income` είναι μικρότερο από 0.5
5. το `loan_amount` είναι μικρότερο από το 25% του `income`

Η συνάρτηση θα επιστρέφει True αν μπορεί ένας πελάτης να πάρει δάνειο ή False διαφορετικά. 

Σημείωση: είναι υποχρεωτικό να χρησιμοποιείσετε την elif

### Άσκηση 16
Υλοποιήσετε την άσκηση 15 χωρίς να χρησιμοποιείσετε την elif

### Άσκηση 17
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 3 παραμέτρους: `exercises`, `project`, `final`. Οι παράμετροι αυτοί εκπροσωπούν τους βαθμούς (από 0 μέχρι και 10, δεν χρειάζεται να το ελέγξετε αυτό), που πήρε κάποιος φοιτητής στις ασκήσεις, στο project και στο τελικό διαγώνισμα ενός μαθήματος αντίστοιχα. Η συνάρτηση θα πρέπει να επιστρέφει True αν περνάει το μάθημα και False διαφορετικά. Οι κανόνες για να περάσει κάποιος το μάθημα είναι:

1. Υπολογίζεται ο συνολικός βαθμός του μαθήματος ο οποίος απότελείται από το 33% του βαθμού των ασκήσεων, το 33% του βαθμού του project, και το 34% του βαθμού του τελικού.
2. Αν ο τελικός βαθμός είναι μεγαλύτερος ή ίσος από 5 τότε περνάει (επιστρέφει True) διαφορετικά δεν περνάει
3. Ο κανόνας 2 έχει μία εξαίρεση: Αν ο φοιτητής έχει βαθμό project ή βαθμό ασκήσεων μικρότερο από 4 τότε δεν περνάει, ανεξάρτητα από τον βαθμό του τελικού.
4. Οι κανόνες 2 και 3 έχουν μία εξαίρεση: Αν ο βαθμός στο τελικό είναι μεγαλύτερος ή ίσος με 9, τότε περνάει.

Δίνονται μετικά παραδείγματα:
```python
print (f(8,8,8)) # Τυπώνει True, Μέσος όρος 8, περνάει 
print (f(5,5,4)) # Τυπώνει False, Μέσος όρος <5.0
print (f(3,8,8)) # Τυπώνει False, Μέσος όρος >5.0, αλλά έχει γράψει στις ασκήσεις <4  
print (f(8,3,8)) # Τυπώνει False, Μέσος όρος >5.0, αλλά έχει γράψει στο project < 4 
print (f(8,3,9)) # Τυπώνει True, έχει γράψει στο project < 4 αλλά έχει γράψει >= 9 στο τελικό
print (f(3,8,9)) # Τυπώνει True, έχει πάρει στις ασκήσεις < 4 αλλά έχει γράψει >= 9 στο τελικό 
print (f(1,1,10)) # Τυπώνει True, έχει μέσο όρο < 5, έχει γράψει <4 σε ασκήσεις και projects αλλά έχει γράψει >= 9 στο τελικό
```

### Άσκηση 18
Οι ακολουθίες του DNA οι οποίες μπορούν να μεταφραστούν ως ένα [stop codon](https://en.wikipedia.org/wiki/Stop_codon) είναι: `TAG`, `TAA`, `TGA`. Φτιάξτε μία συνάρτηση η οποία παίρνει τις εξής παραμέτρους (όλοι είναι λογικοί παράμετροι):
* `Τ_1` : είναι True, αν το 1ο νουκλεοτίδιο του codon είναι T, αλλίως False
* `A_2` : είναι True, αν το 2ο νουκλεοτίδιο του codon είναι A, αλλίως False
* `G_2` : είναι True, αν το 2ο νουκλεοτίδιο του codon είναι G, αλλίως False
* `G_3` : είναι True, αν το 3ο νουκλεοτίδιο του codon είναι G, αλλίως False
* `Α_3` : είναι True, αν το 3ο νουκλεοτίδιο του codon είναι A, αλλίως False

* Αν και το Α_2 και το G_2 είναι True θα πρέπει να επιστρέφει το string: `impossible`
* Αν και το G_3 και το A_3 είναι True θα πρέπει να επιστρέφει το string: `impossible`

Διαφορετικά:

Η συνάρτηση θα πρέπει να επιστρέφει True αν οι παραμέτροι είναι τέτοιοι που να σχηματίζεται ένα stop codon αλλιώς να επιστρέφει False. Για παράδειγμα θα πρέπει:

```python
print (f(T_1=True, A_2=True, G_2=True, G_3=True, A_3=False)) # Τυπώνει "impossible"
print (f(T_1=True, A_2=True, G_2=False, G_3=True, A_3=False)) # (TAG) Τυπώνει True 
print (f(T_1=True, A_2=True, G_2=False, G_3=False, A_3=True)) # (TAA) Τυπώνει True
print (f(T_1=True, A_2=False, G_2=True, G_3=False, A_3=True)) # (TGA) Τυπώνει True
print (f(T_1=False, A_2=False, G_2=True, G_3=False, A_3=True)) #  Τυπώνει False
print (f(T_1=True, A_2=False, G_2=True, G_3=True, A_3=False)) # (TGG) Τυπώνει False
```

Σημείωση: Απαγορεύεται να χρησιμοποιήσετε οποιοδήποτε τελεστή! (==, !=, or, and, ...)

Hint:

Αυτό:

```python
if T_1 == True:
    print ('Το πρώτο νουκλεοτίδιο είναι Τ')
```

Είναι το ίδιο με αυτό:

```python
if T_1:
    print ('Το πρώτο νουκλεοτίδιο είναι Τ')
```

Προσέξτε ότι βγάλαμε τον τελεστή `==`

### Άσκηση 19
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα string με 3 γράμματα (δεν χρειάζεται να το ελέξετε αυτό). Η συνάρτηση θα επιστρέφει:

* `True`: αν το string μπορεί να μεταφραστεί σε stop codon
* `False`: αν το string δεν μπορεί να μεταφραστεί σε stop codon

Για παράδειγμα θα πρέπει:

```python
print (f('TAG')) # Τυπώνει "True"
print (f('TAA')) # Τυπώνει "True"
print (f('TGA')) # Τυπώνει "True"
print (f('AGA')) # Τυπώνει "False"
print (f('TGG')) # Τυπώνει "False"
```

Σημείωση: είναι υποχρεωτικό να χρησιμοποιήσετε τη συνάρτηση της άσκησης 18.

### Άσκηση 20
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα string. Η συνάρτηση αυτή θα ελέγχει αν το string έχει όλες τις προδιαγραφές για να χρησιμοποιηθεί ως το password ενός χρήστη (password validation). Οι προδιαγραφές είναι:

* Πρέπει να είναι πάνω από 6 χαρακτήρες
* Πρέπει να περιέχει τους χαρακτήρες "!" και "@" σε απόσταση 3 ή περίσσότερο μεταξύ τους. 
* Πρέπει να ξεκινάει με ένα κεφαλαίο γράμμα και να τελειώνει με ένα μικρό ή το αντίθετο (να ξεκινάει με μικρό και να τελειώνει με κεφαλαίο)

([ναι.. οι κανόνες δεν χρειάζεται να βγάζουν νόημα](https://dumbpasswordrules.com/))

Αν ισχύουν όλοι οι κανόνες θα επιστρέφει True αλλίως θα επιστρέφει False

### Άσκηση 21 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρεις παράμετρους. Η πρώτη θα είναι μία λίστα με αριθμούς (π.x l) η δεύτερη ένας αριθμός (π.χ. α) και η τρίτη ένας αριθμός π.χ. β. Η συνάρτηση θα επιστρέφει το **άθροισμα** των αριθμών της λίστας οι οποίοι είναι μεγαλύτεροι από α και μικρότεροι από β. Για παράδειγμα θα πρέπει:

```python
print (f([8,3,10, 11,9,8,5], 5, 10) # Τυπώνει:  25 (δηλαδή 8+8+9, οι αριθμοί που είναι μεγαλύτεροι από 5 και μικρότεροι από 10) 
```

* Σημείωση 1: είναι υποχρεωτικό να χρησιμοποιήσετε for (όχι list comprehension)
* Σημείωση 2: Απαγορεύεται να χρησιμοποιήσετε continue

### Άσκηση 22 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρεις παράμετρους. Η πρώτη θα είναι μία λίστα με αριθμούς (π.x l) η δεύτερη ένας αριθμός (π.χ. α) και η τρίτη ένας αριθμός π.χ. β. Η συνάρτηση θα επιστρέφει το **πλήθος** των αριθμών της λίστας οι οποίοι είναι μεγαλύτεροι από α και μικρότεροι από β. Για παράδειγμα θα πρέπει:

```python
print (f([8,3,10, 11,9,8,5], 5, 10) # Τυπώνει: 3  
```

* Σημείωση 1: είναι υποχρεωτικό να χρησιμοποιήσετε for (όχι list comprehension)
* Σημείωση 2: Απαγορεύεται να χρησιμοποιήσετε continue

### Άσκηση 23
Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρεις παράμετρους. Η πρώτη θα είναι μία λίστα με αριθμούς (π.x l) η δεύτερη ένας αριθμός (π.χ. α) και η τρίτη ένας αριθμός π.χ. β. Η συνάρτηση θα επιστρέφει τον μεγαλύτερι αριθμό της λίστας ο οποίος είναι μεγαλύτερος από α και μικρότερος από β. Για παράδειγμα θα πρέπει:

```python
print (f([8,3,10, 11,9,8,5], 5, 10) # Τυπώνει: 9  
```

* Σημείωση 1: είναι υποχρεωτικό να χρησιμοποιήσετε for (όχι list comprehension)
* Σημείωση 2: Απαγορεύεται να χρησιμοποιήσετε continue

### Άσκηση 24
Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρεις παράμετρους. Η πρώτη θα είναι μία λίστα με αριθμούς (π.x l) η δεύτερη ένας αριθμός (π.χ. α) και η τρίτη ένας αριθμός π.χ. β. Η συνάρτηση θα επιστρέφει `True` αν υπάρχει έστω ένας αριθμός ο οποίος να είναι μεγαλύτερος από α και μικρότερος από β ή `False` αν δεν υπάρχει κανένας τέτοιος αριθμός . Για παράδειγμα θα πρέπει:

```python
print (f([8,3,10, 11,9,8,5], 5, 10) # Τυπώνει: True  
print (f([-8,3,10, 11,-9,-8,5], 5, 10) # Τυπώνει: False  
```

* Σημείωση 1: είναι υποχρεωτικό να χρησιμοποιήσετε for (όχι list comprehension)
* Σημείωση 2: Απαγορεύεται να χρησιμοποιήσετε break ή continue.

### Άσκηση 25
Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρεις παράμετρους. Η πρώτη θα είναι μία λίστα με αριθμούς (π.x l) η δεύτερη ένας αριθμός (π.χ. α) και η τρίτη ένας αριθμός π.χ. β. Η συνάρτηση θα επιστρέφει `True` αν υπάρχει έστω ένας αριθμός ο οποίος να είναι μεγαλύτερος από α και μικρότερος από β ή `False` αν δεν υπάρχει κανένας τέτοιος αριθμός . Για παράδειγμα θα πρέπει:

```python
print (f([8,3,10, 11,9,8,5], 5, 10) # Τυπώνει: True  
print (f([-8,3,10, 11,-9,-8,5], 5, 10) # Τυπώνει: False  
```

* Σημείωση 1: είναι υποχρεωτικό να χρησιμοποιήσετε for (όχι list comprehension)
* Σημείωση 2: είναι υποχρεωτικό να χρησιμοποιήσετε break και continue. To continue δεν μπορεί να είναι στο τέλος της for. Για παράδειγμα:

```python
for x in [1,2,3]:
    print (x)
    continue # <-- Δεν έχει νόημα αυτό
```

### Άσκηση 26 
Υλοποιήστε την άσκηση 21

* Σημείωση 1: είναι υποχρεωτικό να χρησιμοποιήσετε for (όχι list comprehension)
* Σημείωση 2: είναι υποχρεωτικό να χρησιμοποιήσετε continue. To continue δεν μπορεί να είναι στο τέλος της for.

### Άσκηση 27
Υπάρχει μόνο ένα ζευγάρι τιμών χ,y τέτοια ώστε:
* Τα χ,y είναι ακέραιοι από το 1 μέχρι και το 100
* Η έκφραση `x*y+23*x-7*y` διαιρείται ακριβώς με το 1000.

Ποιο είναι το άθροισμα των χ,y που έχει αυτή την ιδιότητα; Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα επιστρέφει την απάντηση σε αυτή την ερώτηση. Δίνεται τι θα επιστρέφει η συνάρτηση:

```python
print (f()) # Τυπώνει 168
```

Δίνεται πως ελέγχουμε αν ένας αριθμός διαιρείται με το 1000. Απλά τσεκάρουμε αν το υπόλοιπο της διαίρεσης με το 1000 είναι 0:

```python
print ( 1234 % 1000 == 0 ) # Τυπώνει False. το 1234 δεν διαρείται με το 1000
print ( 3000 % 1000 == 0 ) # Τυπώνει True. το 3000 διαρείται με το 1000
```

### Άσκηση 28
Φτιάξτε μία συνάρτηση η οποία δεν παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει ένα string το οποίο θα περιέχει όλα τα 64 codons ακριβώς μία φορά. Δηλαδή θα πρέπει:

```python
print (f()) # Τυπώνει: AAAAACAAGAATACAACCACGACTAGAAGCAGGAGTATAATCATGATTCAACACCAGCATCCACCCCCGCCTCGACGCCGGCGTCTACTCCTGCTTGAAGACGAGGATGCAGCCGCGGCTGGAGGCGGGGGTGTAGTCGTGGTTTAATACTAGTATTCATCCTCGTCTTGATGCTGGTGTTTATTCTTGTTT
```

Εξήγηση: Όλα τα codons είναι: `AAA`, `AAC`, `AAG`, `AAT`, `ACA`, `ACC`, `ACG`, `ACT`, `AGA`, ... H σειρά δεν έχει σημασία αρκεί να είναι και τα 64 (`4*4*4`) ακριβώς μία φορά το κάθε ένα. Είναι υποχρεωτικό να χρησιμοποιήσετε for και να μην κάνετε import τίποτα.

### Άσκηση 29
Φτιάξτε μία συνάρτηση η οποία θα τυπώνει χαριτωμένα σχεδιάκια με αστεράκια με τον εξής τρόπο:

```python
print f(1)
```
Τυπώνει:
```
*
```


```python
print f(2)
```
Τυπώνει:
```
**
*
```

```python
print f(3)
```
Τυπώνει:
```
***
**
*
```

```python
print f(4)
```
Τυπώνει:
```
****
***
**
*
```

κτλ..

### Άσκηση 30
Μία ακολουθία DNA λέγεται συμμετρική αν διαβάζεται το ίδιο από την αρχή και από το τέλος. Μερικά παραδείγματα είναι: `ACCA`, `ACGCA`, `GGG`, `TT`. Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία ακολουθία DNA. Η συνάρτηση θα επιστρέφει True αν υπάρχει έστω και μία υπο-ακολουθία η οποία να είναι συμμετρική ή False διαφορετικά. Για παράδειγμα θα πρέπει:

```python 
print (f('ACGACTAG')) # Τυπώνει False, δεν περιέχει συμμετρική ακολουθία
print (f('ACGAΑTAG')) # Τυπώνει True, υπάρχει η ΑΑ
print (f('ACGAGCAG')) # Τυπώνει True, υπάρχει η CGAGC
```

# Οι παρακάτω ασκήσεις είναι πρόχειρες (δεν έχουν καθαρογραφεί).

### Άσκηση 31
Ποιο είναι το άθροισμα όλων των αριθμών από το 1 μέχρι και το 1000 αν δεν μετρήσουμε τους αριθμούς που έχουν μέσα το "3"; Δηλαδή δεν μετράμε το 3, το 13, το 23, ..., 103, ... 134, ... 

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα πρέπει να επιστρέφει την απάντηση στην παραπάνω ερώτηση.

Σημείωση: Αν χρησιμοποιήσετε τη `str` θα χάσετε 2 πόντους! Δηλαδή θα βαθμολογηθείτε με άριστα το 8/10. Προσπαθήστε να την υλοποιήστε χωρίς τη `str`

### Άσκηση 32
Ποιο είναι το άθροισμα όλων των αριθμών από το 1 μέχρι και το 10.000 αν δεν μετρήσουμε τους αριθμούς που έχουν μέσα το "3" μόνο μία φορά; Δηλαδή δεν μετράμε το 3, το 13, το 23, ..., 103, ... 134, ..., 305, 2003. Αλλά μετράμε το 33, 331, 333, 1033, 1303,  

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα πρέπει να επιστρέφει την απάντηση στην παραπάνω ερώτηση.

Σημείωση: Αν χρησιμοποιήσετε τη `str` θα χάσετε 2 πόντους! Δηλαδή θα βαθμολογηθείτε με άριστα το 8/10. Προσπαθήστε να την υλοποιήστε χωρίς τη `str`

### Άσκηση 33
[Γνωρίζουμε από τα μαθηματικά](https://en.wikipedia.org/wiki/1/2_%2B_1/4_%2B_1/8_%2B_1/16_%2B_%E2%8B%AF) ότι: 1/2 + 1/4 + 1/8 + 1/16 + ... = 1. Πόσους όρους αυτής της ακολουθίας πρέπει να προσθέσουμε ώστε η διαφορά του αθροίσματός τους με το 1 να γίνει μικρότερη από 0.000001 ;

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα πρέπει να επιστρέφει την απάντηση στην παραπάνω ερώτηση.

### Άσκηση 34
[Γωνρίζουμε από τα μαθηματικά](https://en.wikipedia.org/wiki/1/2_%E2%88%92_1/4_%2B_1/8_%E2%88%92_1/16_%2B_%E2%8B%AF) ότι: 1/2 - 1/4 + 1/8 - 1/16 + ... = 1/3. Πόσους όρους αυτής της ακολουθίας πρέπει να προσθέσουμε ώστε η απόλυτη διαφορά (`abs(s-1/3)`) του αθροίσματός τους με το 1/3 να γίνει μικρότερη από το  0.000001 ;

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα πρέπει να επιστρέφει την απάντηση στην παραπάνω ερώτηση.

### Άσκηση 35
[Γνωρίζουμε από τα μαθηματικά](https://en.wikipedia.org/wiki/Pi#Rate_of_convergence) ότι: 

![img](https://wikimedia.org/api/rest_v1/media/math/render/svg/fdafa8bd24ce2b6fd518a3cf253ad1ef409388a6)

Πόσους όρους αυτής της ακολουθίας πρέπει να προσθέσουμε ώστε το η απόλυτη διάφορά του αθροίσματός τους με το pi να γίνει μικρότερη από το 0.0001 ;

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα πρέπει να επιστρέφει την απάντηση στην παραπάνω ερώτηση.


Δίνεται ότι η τιμή του pi είναι:

```python
import math
print (math.pi)
```


### Άσκηση 36 
To [παραγοντικό ενός αριθμού](https://en.wikipedia.org/wiki/Factorial) n συμβολίζεται με n! και ισούται με το γινόμενο όλων των ακέραιων αριθμών από 1 μέχρι και το n. Για παράδειγμα το παραγοντικό του 4 είναι 24 (1\*2\*3\*4). Ορίζουμε επίσης ότι το παραγοντικό του 0 είναι 1, δηλαδή 0! = 1. Εννοείται ότι όλοι νωρίζουμε από τα μαθηματικά ότι το ([e, δηλαδή η βάση των φυσικών λογαρίθμων](https://en.wikipedia.org/wiki/E_%28mathematical_constant%29)) είναι ίσο με:

e = 1/(0!) + 1/(1!) + 1/(2!) + 1/(3!) + 1/(4!) + ...

ή αλλιώς:

e = 1/1 + 1/1 + 1/(1\*2) + 1/(1\*2\*3) + 1/(1\*2\*3\#4) + ...

ή αλλιώς:

![img](https://wikimedia.org/api/rest_v1/media/math/render/svg/2f9a1f86072b07e1f69d5e21571c207d52680d8f)


Πόσους όρους αυτής της ακολουθίας πρέπει να προσθέσουμε ώστε η διαφορά του αθροίσματός τους με το e να γίνει μικρότερη από το 0.0001 ;

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα επιστρέφει την απάντηση στη παραπάνω ερώτηση.

* Σημείωση 1: Απαγορεύεται να κάνε import κάποια βιβλιοθήκη (αν δεν ξέρετε τι είναι αυτό, τόσο το καλύτερο!)
* Σημείωση 2: Θα πρέπει να φτιάξετε μία και μόνο μία συνάρτηση (μην φτιάξετε συνάρτηση η οποία υπολογίζει το παραγοντικό)

### Άσκηση 37

Ο Lothar Collatz, είπε [ένα θεώρημα](https://en.wikipedia.org/wiki/Collatz_conjecture) το οποίο μέχρι σήμερα είναι αναπόδεικτο! Συγκεκριμένα είπε ότι αν πάρουμε οποιοδήποτε ακέραιο αριθμό μεγαλύτερο από 1 και εφαρμόσουμε την εξής διαδικασία:

* Αν είναι ζυγός τον διαιρούμε με το 2
* Αν είναι μονός το πολλαπλασιάζουμε με το 3 και προσθέτουμε το 1
* Εφαρμόζουμε τους παραπάνω δύο κανόνες στον νέο αριθμό που βρήκαμε

Τότε ο αριθμός που θα καταλήξουμε θα είναι πάντα ο 1 !!! Για παράδειγμα έστω ότι έχουμε τον αριθμό 45:
* Το 45 είναι μονός άρα πάμε στον 45\*3 + 1 = 136
* Το 136 είναι ζυγός άρα πάμε στον 136/2 = 68
* Το 68 είναι ζυγός άρα πάμε στον 68/2 = 34
* Το 34 είναι ζυγός άρα πάμε στον 34/2 = 17
* Το 17 είναι μονός άρα πάμε στον 17\*3 + 1 = 52
* Το 52 είναι ζυγός άρα πάμε στον 52/2 = 26
* Το 26 είναι ζυγός άρα πάμε στον 26/2 = 13
* Το 13 είναι μονός άρα πάμε στον 13\*3 + 1 = 40
* Το 40 είναι ζυγός άρα πάμε στον 40/2 = 20
* Το 20 είναι ζυγός άρα πάμε στον 20/2 = 10
* Το 10 είναι ζυγός άρα πάμε στον 10/2 = 5
* Το 5 είναι μονός άρα πάμε στον 5\*3 +  1 = 16
* Το 16 είναι ζυγός άρα πάμε στον 16/2 = 8
* Το 8 είναι ζυγός άρα πάμε στον 8/2 = 4
* Το 4 είναι ζυγός άρα πάμε στον 4/2 = 2
* Το 2 είναι ζυγός άρα πάμε στον 2/2 = 1 !!! 


Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο έναν αριθμό n. Η συνάρτηση θα επιστρέφει μία λίστα με όλους τους αριθμούς που παιρνάμε με βάση την παραπάνω διαδικασία για να καταλήξουμε στο 1. Δηλαδή θα πρέπει:


```python
print (f(45)) # Τυπώνει [136, 68, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
```
 

### Άσκηση 38
Όπως είπαμε και στο μάθημα το [πρόβλημα της παραγοντοποίησης](https://en.wikipedia.org/wiki/Integer_factorization) είναι ένα από τα πιο δύσκολα στην επιστήμη των υπολογιστών. Ευτυχώς για μικρούς αριθμούς το πρόβλημα δεν είναι καθόλου δύσκολο. Η παραγοντοποίηση λοιπόν ενός ακέραιου θετικού αριθμού ορίζεται ώς το σύνολο από πρώτους αριθμούς τους οποίους αν τους πολλαπλασιάσεις θα πάρεις τον αρχικό αριθμό. Δίνονται μερικά παραδειγματα:

```
100 = 2 * 2 * 5 * 5
99 = 3 * 3 * 11
98 = 2 * 7 * 7
96 = 2 * 2 * 2 * 2 * 2 * 3
```


Φτιάξτε μία συνάρτηση η οποία θα παίρνει έναν αριθμό και θα επιστρέφει το πλήθος από παράγοντες που έχει. Θα πρέπει δηλαδή:

```python
print (f(100)) # Τυπώνει: 4
print (f(99)) # Τυπώνει: 3
print (f(98)) # Τυπώνει: 3
print (f(96)) # Τυπώνει: 6
```

* Σημείωση: Δεχόμαστε σαν σύμβαση ότι το 1 έχει 0 παράγοντες (δες και επόμενη άσκηση). Δηλαδή:

```python
print (f(1)) # Τυπώνει 0
```

### Άσκηση 39
(Συνέχεια της άσκησης 38)

Παρατηρούμε τώρα ότι κάποιοι αριθμοί όπως το 100 και το 96 έχουν ζυγό αριθμό από παράγοντες (το 100 έχει 4 και το 96 έχει 6), ενώ κάποιοι άλλοι όπως το 99 και το 98 έχουν μονό αριθμό από παράγοντες (και οι 2 έχουν 3 παράγοντες). Αν πάρουμε έναν αριθμό έστω n και πάρουμε όλους τους αριθμούς από το 1 μέχρι και το n, τότε αυτοί οι αριθμοί μπορούν να χωριστούν σε δύο κατηγορίες: αυτοί που έχουν ζυγό αριθμό από παράγοντες και μονό αριθμό από παράγοντες. Ποιος είναι ο λόγος των αριθμών από το 1 μέχρι και το n που έχουν μονό αριθμό από παράγοντες; Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο έναν αριθμό n. Η συνάρτηση θα επιστρέφει έναν αριθμό ο οποίος θα είναι ο αυτός ο λόγος (λόγος = [ratio](https://en.wikipedia.org/wiki/Ratio),  δηλαδή ένας αριθμός από 0 μέχρι και 1). 

Για παράδειγμα ας πάρουμε τον αριθμό 10. Όλοι οι αριθμοί από 1 μέχρι και το 10 μαζί με τους παράγοντες τους, το πλήθος των παραγόντων και αν είναι μονός ή ζυγός αριθμός αυτό το πλήθος είναι: 

| αριθμός  | παράγοντες    |  πλήθος παραγόντων  |  μονό πλήθος ή ζυγό πλήθος      |
|----------|---------------|---------------------|---------------------------------|
| 1  | []      | 0  | ζυγός |
| 2  | [2]     | 1  | μονός |
| 3  | [3]     | 1  | μονός |
| 4  | [2,2]   | 2  | ζυγός |
| 5  | [5]     | 1  | μονός |
| 6  | [2,3]   | 2  | ζυγός |
| 7  | [7]     | 1  | μονός |     
| 8  | [2,2,2] | 3  | μονός |
| 9  | [3,3]   | 2  | ζυγός |
| 10 | [2,5]   | 2  | ζυγός |


Αν μετρήσουμε τώρα το πλήθος από αριθμούς με μονό πλήθος παραγόντων, θα δούμε ότι είναι 5 (το 2, το 3, το 5, το 7 και το 8). Άρα 5 από τους 10 αριθμούς έχουν μονό πλήθος από παράγοντες, άρα ο ζητούμενος λόγος είναι: 5/10 = 0.5. Συνεπώς θα πρέπει:

```python
print (f(10)) # Τυπώνει 0.5  
```

Σημείωση: Θεωρούμε ότι το 0 είναι ζυγός αριθμός.

### Άσκηση 40
(Συνέχεια της άσκησης 39)

Ποιος είναι ο μικρότερος αριθμός ο οποίος να είναι μεγαλύτερος από 100 για τον οποίο η συνάρτηση της άσκησης 39 επιστρέφει 0.5 ; 

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει την απάντηση στο παραπάνω ερώτημα. 

Σημείωση: Προφανώς θα αναρωτιέστε, ποιος και γιατί ασχολείται με αυτά τα "ερωτήματα". Το ερώτημα του μονού/ζυγού πλήθους από παράγοντες απασχόλησε τον George Pólya ο οποίος το 1919 [είπε](https://en.wikipedia.org/wiki/P%C3%B3lya_conjecture) ότι αυτός ο λόγος είνα μεγαλύτερος ή ίσος με το 0.5 για όλους τους θετικούς ακέραιους αριθμούς. Για 40 χρόνια κανείς δεν τον αμφισβήτησε, ώσπου τι 1958 ο C. Brian Haselgrove απέδειξε ότι ο λόγος αυτός είναι μικρότερος από 0.5 για έναν αριθμό "κοντά" στο 1.845 × 10<sup>361</sup>. Το 1980 βρέθηκε ο μικρότερος αριθμός τέτοιος ώστε η συνάρτηση της άσκησης 39 να επιστρέφει αριθμό μικρότερο του 0.5. Ο αριθμός αυτός είναι ο 906,150,257. 


<!--
### Πρόχειρο (αγνοήστε το!)
* https://en.wikipedia.org/wiki/Three-gap_theorem 
-->


