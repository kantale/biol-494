
# Λίστα με ασκήσεις

## Σημειώσεις για όλες τις ασκήσεις
* **ΑΠΑΓΟΡΕΥΕΤΑΙ** να κάνετε: ```a = input("...")``` (και γενικότερα μην το κάνετε ποτέ αυτό..)
* Όταν η εκφώνηση λέει ότι πρέπει να φτιάξετε συνάρτηση.. πρέπει να φτιάξετε συνάρτηση!
* Αν η εκφώνηση λέει ότι η συνάρτηση πρέπει να επιστρέφει κάτι.. τότε μέσα στη συνάρτησή σας πρέπει κάπου να κάνετε ```return```.
* **AΠΑΓΟΡΕΥΕΤΑΙ** να κάνετε: ```return True```  ή ```return False```  (αν το χρησιμοποιείσετε χάνετε τη μισή άσκηση)


Για παράδειγμα, έστω ότι η άσκηση λέει: 

Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν αριθμό. Η συνάρτηση θα πρέπει να επιστρέφει:
* ```True``` αν ο αριθμός είναι μονός
* ```False``` αν ο αριθμός είναι ζυγός (άρτιος).

Τι να **ΜΗΝ** κάνετε:
```python
def f(n):
    if n%2 == 1:
        return True
    else:
        return False

```

Τι να κάνετε:
```python
def f(n):
    return n%2 == 1
```

* **ΑΠΑΓΟΡΕΥΕΤΑΙ** Να χρησιμοποιήσετε τα εξής ονόματα μεταβλητών: `str`, `id`, `int`, `list`, `tuple`, `dict`. Αυτά είναι ονόματα συναρτήσεων της python. Η python σας αφήνει να τα χρησιμοποιήσετε με το "κόστος" ότι χάνεται η αρχική τους χρήση. π.χ:

```python
print (str(55))

str = 'Mitsos'
print (str(55))
```  

### Άσκηση 1
Φτιάξτε μία συνάρτητη η οποία θα παίρνει σαν όρισμα 1 αριθμό. Η συνάρτηση θα επιστρέφει `True` αν ο αριθμός είναι μεταξύ του 10 και του 20 (συπεριλαμβάνοντας το 10 και το 20). Διαφορετικά η συνάρτηση θα επιστρέφει False.

### Άσκηση 2
Ας υποθέσουμε ότι έχουμε μία χημική ένωση η οποία αποτελείται μόνο από άνθρακα (C), υδρογόνο (H) και οξυγόνο (O). Ποιο είναι το μοριακό βάρος της ένωσης; Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 3 αριθμούς. Ο πρώτος θα είναι το πλήθος από άτομα C που έχει η χημική ένωση, ο δεύτερος είναι το πλήθος από άτομα υδρογόνου και ο τρίτος από άτομα οξυγόνου που περιέχει. Η συνάρτηση θα επιστρέφει το μοριακό βάρος της ένωσης. Δίνεται ότι το ατομικό βάρος του υδρογόνου είναι 1.00784, το ατομικό βάρος του άνθρακα είναι 12.0096 και το ατομικό βάρος του οξυγόνου είναι 15.99903. Για παράδειγμα το μοριακό βάρος της C<sub>6</sub>H<sub>12</sub>O<sub>6</sub> είναι: 6\*12.0096 + 12\*1.00784 + 6\*15.99903 = 180.14586 .

Για παράδειγμα, αν f είναι η συνάρτηση που φτιάξατε θα πρέπει:

```python
f(6,12,6) # Επιστρέφει: 180.14586   (μπορεί και να επιστρέψει 180.14586000000003)
``` 

### Άσκηση 3
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 4 παράμετρους. Η πρώτη θα είναι το βάρος μίας χημικής ένωσης σε γραμμάρια. Η δεύτερη θα είναι το πλήθος από άτομα άνθρακα που έχει η χημική της ένωση, η τρίτη θα είναι το πλήθος από άτομα υδρογόνου και η τέταρτη το πλήθος από άτομα οξυγόνου που έχει η χημική της ένωση. Η συνάρτηση θα επιστρέφει το βάρος της χημικής ένωσης σε γραμμομόρια (moles). Δίνεται ότι το βάρος μίας χημικής ένωσης σε γραμμομόρια είναι ίση με το βάρος της γραμμάρια διαιρεμένο με το ατομικό της βάρος. Για παράδειγμα 60 γραμμάρια γλυκόζης (C<sub>6</sub>H<sub>12</sub>O<sub>6</sub>) ζυγίζουν: 60/180.14586 = 0.3330634409250371 moles. 

Άρα θα πρέπει:
```python
f(60, 6, 12, 6) # Επιστρέφει 0.3330634409250371 
```

**Σημείωση:** είναι υποχρεωτικό να χρησιμοποιήσετε τη συνάρτηση της άσκησης 2.


### Άσκηση 4
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 3 αριθμούς. Ο πρώτος θα είναι το πλήθος από άτομα C που έχει μία χημική ένωση, ο δεύτερος είναι το πλήθος από άτομα υδρογόνου και ο τρίτος από άτομα οξυγόνου που περιέχει. Η συνάρτηση θα επιστρέφει ένα string με το χημικό τύπο της ένωσης. Για παράδειγμα:

```python
f(6,12,6) # Επιστρέφει: C6H12O6
f(1,2,3) # Επιστρέφει CH2O3  (όχι C1H2O3)
```

### Άσκηση 5 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα string το οποίο θα είναι ο χημικός τύπος μίας ένωσης η οποία αποτελείται μόνο από άτομα άνθρακα, υδρογόνου και οξυγόνου. Υποθέτουμε ότι η ένωση αποτελείται από 2 μέχρι και 9 άτομα του κάθε στοιχείου. Η συνάρτηση θα επιτρέφει έναν ακέραιο αριθμό ο οποίος είναι το πλήθος από άτομα υδρογόνου που έχει η χημική ένωση. Για παράδειγμα θα πρέπει:

```python
f('C6H8O2') # Επιστρέφει 8 
```  

### Άσκηση 6
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα string το οποίο θα είναι ο χημικός τύπος μίας ένωσης η οποία αποτελείται μόνο από άτομα άνθρακα, υδρογόνου και οξυγόνου. Υποθέτουμε ότι η ένωση αποτελείται από 2 μέχρι και 9 άτομα του κάθε στοιχείου. Η συνάρτηση θα επιτρέφει:
* `True` αν τα άτομα του υδρογόνου είναι περισσότερα από τα άτομα του άνθρακα
* `False` διαφορετικά.

### Άσκηση 7
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν όρισμα έναν αριθμό. Ο αριθμός αυτός θα είναι το πλήθος από άνθρακες ο οποίος περιέχει ένα [αλκάνιο](https://el.wikipedia.org/wiki/%CE%91%CE%BB%CE%BA%CE%AC%CE%BD%CE%B9%CE%B1). Η συνάρτηση θα επιστρέφει ένα string το οποίο θα είναι η χημική ένωση αυτού του αλκανίου. Για παράδειγμα θα πρέπει:

```python
f(1) # Επιστρέφει CH4   (μεθάνιο)
f(2) # Επιστρέφει C2H6   (αιθάνιο)
f(3) # Επιστρέφει C3Η8   (προπάνιο)
f(4) # Επιστρέφει C4H10   (βουτάνιο)
f(5) # Επιστρέφει C5H12   (πεντάνιο)
f(6) # Επιστρέφει C6H14   (εξάνιο)
f(7) # Επιστρέφει C7H16   (επτάνιo)
...
f(100) # Επιστρέφει C100H202
``` 

### Άσκηση 8 
Η αναλογία μέσης-γοφών ([waist-hip ratio](https://en.wikipedia.org/wiki/Waist%E2%80%93hip_ratio)) είναι μία μετρική ανάλογη με τον λόγο ύψους / βάρους, που χρησιμοποιείται πολύ στη διαιτολογία. Ορίζεται ο λόγος της περιφέρειας της μέσης προς τη περιφέρεια των γοφών ενός ανθρώπου. Για παράδειγμα ένας άνθρωπος με περιφέρεια μέσης 76 εκατοστά και περιφέρεια γοφών 97 έχει αναλογία μέσης-γοφών: 76 / 97 = 0.7835051546391752. 

Ανάλογα με τον λόγο αυτό και ανάλογα με το φύλο του ατόμου υπάρχει η παρακάτω κατηγοριοποίηση:
Για άντρες:
* κάτω από 0.9: φυσιολογικός
* ίσο με 0.9 μέχρι 1.00 (χωρίς το 1.00) υπέρβαρος
* ίσο ή μεγαλύτερο από 1.0 παχύσαρκος

Για γυναίκες:
* κάτω από 0.8: φυσιολογική
* ίσο με 0.8 μέχρι 0.85 (χωρίς το 0.85) υπέρβαρη
* ίσο ή μεγαλύτερο από 0.85 παχύσαρκη

Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρία ορίσματα:
* Το πρώτο θα είναι ένα string: `man` ή `woman`
* To δεύτερο θα είναι ένας αριθμός το οποίο θα είναι η περίμετρος της μέσης. 
* Το τρίτο θα είναι ένας αριθμός το οποίο θα είναι η περίμετρος των γοφών.

ανάλογα με τις τιμές των παραμέτρων, η συνάρτηση θα επιστρέφει ένα από τα παρακάτω string: `φυσιολογικός`, `υπέρβαρος`, `παχύσαρκος`, `φυσιολογική`, `υπέρβαρη`, `παχύσαρκη`.

### Άσκηση 9
Γράψτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 2 αριθμούς έστω a,b. Η συνάρτηση θα επιστρέφει τη λύση της εξίσωσης: ax + b = 0. Θα πρέπει να ελέγξετε αν η συνάρτηση έχει λύση (αν το a είναι 0 και το b είναι διαφορετικό του 0, η συνάρτηση δεν έχει λύση), ή αν η συνάρτηση έχει άπειρες λύσης (αν τα a και b είναι 0). Σε αυτές τις περιπτώσεις η συνάρτηση θα πρέπει να επιστρέφει το string "αδύνατο" και "άπειρες λύσεις", αντίστοιχα. 

**Σημείωση: Για τις ασκήσεις 10-18 απαγορεύεται να χρησιμοποιήσετε for, while**

### Άσκηση 10
Γράψτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία λίστα με ακέραιους αριθμούς (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα επιστρέφει μία λίστα με όλους του αριθμούς της λίστας της παραμέτρου που ανήκουν στο κλειστό διάστημα [10,20]. Για παράδειγμα θα πρέπει:

```python
l = [16, 12, 5, 13, 14, 19, 7, 8, 10, 18]
f(l) # Επιστρέφει: [16, 12, 13, 14, 19, 10, 18]
```

### Άσκηση 11
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία λίστα από strings με μικρά λατινικά γράμματα (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα επιστρέφει μία νέα λίστα με όλα τα strings της παραμέτρου τα οποία ξεκινάνε με φωνήεν ('a', 'e', 'i', 'o', 'u', 'y'). Για παράδειγμα θα πρέπει:

```python
l = ['athens', 'heraklion', 'patras', 'alexandroupoli', 'thessalonikh', 'ioannina']
f(l) # επιστρέφει: ['athens', 'alexandroupoli', 'ioannina']
```

### Άσκηση 12
Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία λίστα η οποία αποτελείται από υπο-λίστες με ακέραιους αριθμούς (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα επιστρέφει μία νέα λίστα με τα στοιχεία της λίστας της παραμέτρου των οποίων το άθροισμα είναι άρτιος (ζυγός) αριθμός. Για παράδειγμα θα πρέπει:

```python
l = [ [14, 14], [20, 6, 15], [10, 12], [5], [8, 18, 22], [13, 16], [8, 13] ]
f(l) #  Επιστρέφει: l = [ [14, 14], [10, 12], [8, 18, 22] ]
# Εξήγηση: Τα αθροίσματα των στοιχείων της κάθε υπολίστας είναι: [28, 41, 22, 5, 48, 29, 21]
# Από αυτά τα 1ο, 3ο, 5ο στοιχείο είναι ζυγά. 
# Άρα επιστρέφει το 1ο, το 3ο και το 5ο στοιχείο της λίστας της παραμέτρου.
```

### Άσκηση 13
Φτιάξτε μία συνάρτηση η οποία παίρνει μία λίστα από strings (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα επιστρέφει το στοιχείο της λίστας το οποίο έχει το μικρότερο μήκος. Για παράδειγμα θα πρέπει: 

```python
l = ['athens', 'heraklion', 'patras', 'alexandroupoli', 'thessalonikh', 'kos', 'ioannina']
f(l) # Επιστρέφει: 'kos'
# Εξήγηση: το 'kos' αποτελείται από 3 γράμματα και είναι το μικρότερο string στη λίστα.  
```

### Άσκηση 14
Φτιάξτε μία συνάρτηση η οποία παίρνει μία λίστα από strings (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα επιστρέφει έναν ακέραιο αριθμό ο οποίος θα είναι η θέση του στοιχείου της λίστας το οποίο έχει το μικρότερο μήκος. Για παράδειγμα θα πρέπει: 

```python
l = ['athens', 'heraklion', 'patras', 'alexandroupoli', 'thessalonikh', 'kos', 'ioannina']
f(l) # Επιστρέφει: 5
# Εξήγηση: το 'kos' αποτελείται από 3 γράμματα και είναι το μικρότερο string στη λίστα.
# το 'kos' είναι το 5ο στοιχείο της λίστας (ξεκινώντας από το 0)  
```

### Άσκηση 15
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία λίστα. Η λίστα θα περιέχει υπο-λίστες με 3 στοιχεία. Το πρώτο θα είναι ένα όνομα (string) ενός μαθητή, το 2o θα είναι η ηλικία του/της (ακέραιος αριθμός) και το 3ο θα είναι ο βαθμός (ακέραιος αριθμός). Η συνάρτηση θα πρέπει να επιστρέφει ένα string το οποίο θα είναι το όνομα του μαθητή με τη μεγαλύτερη βαθμολογία. Αν δύο ή παραπάνω μαθητές έχουν την ίδια μεγαλύτερη βαθμολογία, τότε επιστρέφει το όνομα του μικρότερου από αυτούς. Για παράδειγμα:

```python
l = [['Helen', 23, 8], ['Kostas', 25, 9], ['Alex', 22, 9], ['Maria', 24, 7]]
f(l) #  Επιστρέφει 'Alex'
# Εξήγηση: η καλύτερη βαθμολογία είναι το 9
# Και ο 'Kostas' και ο 'Alex' έχουν βαθμό 9. Ο 'Kostas' είναι 25 χρονών και ο 'Alex' 22. Από αυτούς ο 'Alex' είναι ο μικρότερος.
``` 

### Άσκηση 16
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα επιστρέφει τη τετραγωνική ρίζα όλων των αριθμών από το 10 μέχρι και το 100 οι οποιοι δεν δαιρούνται με το 7. Δηλαδή θα πρέπει: 
```python
f() 
# Επιστρέφει τη λίστα:
[3.1622776601683795, 3.3166247903554, 3.4641016151377544, 3.605551275463989, 3.872983346207417, 4.0, 4.123105625617661, 4.242640687119285, 4.358898943540674, 4.47213595499958, 4.69041575982343, 4.795831523312719, 4.898979485566356, 5.0, 5.0990195135927845, 5.196152422706632, 5.385164807134504, 5.477225575051661, 5.5677643628300215, 5.656854249492381, 5.744562646538029, 5.830951894845301, 6.0, 6.082762530298219, 6.164414002968976, 6.244997998398398, 6.324555320336759, 6.4031242374328485, 6.557438524302, 6.6332495807108, 6.708203932499369, 6.782329983125268, 6.855654600401044, 6.928203230275509, 7.0710678118654755, 7.14142842854285, 7.211102550927978, 7.280109889280518, 7.3484692283495345, 7.416198487095663, 7.54983443527075, 7.615773105863909, 7.681145747868608, 7.745966692414834, 7.810249675906654, 7.874007874011811, 8.0, 8.06225774829855, 8.12403840463596, 8.18535277187245, 8.246211251235321, 8.306623862918075, 8.426149773176359, 8.48528137423857, 8.54400374531753, 8.602325267042627, 8.660254037844387, 8.717797887081348, 8.831760866327848, 8.888194417315589, 8.94427190999916, 9.0, 9.055385138137417, 9.1104335791443, 9.219544457292887, 9.273618495495704, 9.327379053088816, 9.38083151964686, 9.433981132056603, 9.486832980505138, 9.591663046625438, 9.643650760992955, 9.695359714832659, 9.746794344808963, 9.797958971132712, 9.848857801796104, 9.9498743710662, 10.0]
```

Η τετραγωνική ρίζα του αριθμού `x` είναι: `x**0.5`.

### Άσκηση 17
Δίνεται η παρακάτω λίστα με τους πληθυσμούς ελληνικών πόλεων ([πηγή](https://en.wikipedia.org/wiki/List_of_cities_and_towns_in_Greece)):
```python
cities = [
    ['Athens', 772072, 664046],
    ['Thessaloniki', 383967, 315196],
    ['Patras', 152570, 167446],
    ['Piraeus', 182671, 163688],
    ['Larissa', 112777, 144651],
    ['Heraklion', 115270, 140730],
    ['Kallithea', 194233, 100641],
    ['Acharnes', 61052, 99346],
    ['Kalamaria', 80698, 91279],
]

```
Το πρώτο στοιχείο κάθε υπολίστας είναι το όνομα της πόλης. Το δεύτερο στοιχείο είναι ο πληθυσμός της με βάση την απογραφή του 1991. Το τρίτο στοιχείο είναι ο πληθυσμός της με βάση την απογραφή του 2011. 

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν όρισμα μία λίστα η οποία θα έχει την ίδια δομή με τη λίστα `cities`. Η συνάρτηση θα επιστρέφει το όνομα της πόλης η οποία σημείωσε τη μεγαλύτερη αύξηση πληθυσμού από το 1991 μέχρι το 2011. Δηλαδή θα πρέπει:

```python
f(cities) # επιστρέφει 'Acharnes'
```

### Άσκηση 18 
Δίνεται η παρακάτω λίστα με γονίδια ([πηγή](http://www.cshlp.org/ghg5_all/section/gene.shtml)):

```python

genes = [
    ['COL7A1', 118, 'Collagen'],
    ['HMCN1', 107, 'Additional Immunoglobulin-related Receptors'],
    ['RYR1', 106, 'Muscle'],
    ['SYNE1', 146, 'Spectrin and Plectin Families'],
    ['MDN1', 102, 'Nucleus and Nucleolus'],
    ['RYR3', 104, 'Muscle'],
    ['UBR4', 106, 'RB1 and Related Functions'],
    ['TTN', 312, 'Muscle'],
    ['SYNE2', 116, 'Spectrin and Plectin Families'],
    ['OBSCN', 106, 'Muscle'],
    ['RYR2', 105, 'Muscle'],
    ['SSPO', 103, 'Additional Genes in Development'],
    ['NEB', 150, 'Muscle'],
]

```

Το πρώτο στοιχείο κάθε υπο-λίστας είναι το όνομα ενός γονιδίου. Το δεύτερο είναι το πλήθος από εξώνια (exons) που περιέχει και το τρίτο είναι η κατηγορία που ανήκει. 

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία λίστα με την ίδια δομή όπως η `genes`. Η συνάρτηση θα επιστρέφει μία λίστα η οποία θα περιέχει μόνο τα ονόματα των γονιδίων που δεν ανήκουν στη κατηγορία `Muscle`, ταξινομημένα με βάση το πλήθος από exons που έχουν (από το μικρότερο στο μεγαλύτερο). Δηλαδή θα πρέπει:

```python
f(genes) # Επιστρέφει: ['MDN1', 'SSPO', 'UBR4', 'HMCN1', 'SYNE2', 'COL7A1', 'SYNE1'] 
``` 

### Άσκηση 19 
(παρόμοια με 10)

Γράψτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία λίστα με ακέραιους αριθμούς (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα επιστρέφει μία λίστα με όλους του αριθμούς της λίστας της παραμέτρου που ανήκουν στο κλειστό διάστημα [10,20]. Για παράδειγμα θα πρέπει:

```python
l = [16, 12, 5, 13, 14, 19, 7, 8, 10, 18]
f(l) # Επιστρέφει: [16, 12, 13, 14, 19, 10, 18]
```

**Σημείωση:** είναι υποχρεωτικό να χρησιμοποιήσετε list comprehension

### Άσκηση 20
(παρόμοια με 11)

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία λίστα από strings με μικρά λατινικά γράμματα (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα επιστρέφει μία νέα λίστα με όλα τα strings της παραμέτρου τα οποία ξεκινάνε με φωνήεν ('a', 'e', 'i', 'o', 'u', 'y'). Για παράδειγμα θα πρέπει:

```python
l = ['athens', 'heraklion', 'patras', 'alexandroupoli', 'thessalonikh', 'ioannina']
f(l) # επιστρέφει: ['athens', 'alexandroupoli', 'ioannina']
```

**Σημείωση:** είναι υποχρεωτικό να χρησιμοποιήσετε list comprehension


### Άσκηση 21
(παρόμοια με 12)

Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία λίστα η οποία αποτελείται από υπο-λίστες με ακέραιους αριθμούς (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα επιστρέφει μία νέα λίστα με τα στοιχεία της λίστας της παραμέτρου των οποίων το άθροισμα είναι άρτιος (ζυγός) αριθμός. Για παράδειγμα θα πρέπει:

```python
l = [ [14, 14], [20, 6, 15], [10, 12], [5], [8, 18, 22], [13, 16], [8, 13] ]
f(l) #  Επιστρέφει: l = [ [14, 14], [10, 12], [8, 18, 22] ]
# Εξήγηση: Τα αθροίσματα των στοιχείων της κάθε υπολίστας είναι: [28, 41, 22, 5, 48, 29, 21]
# Από αυτά τα 1ο, 3ο, 5ο στοιχείο είναι ζυγά. 
# Άρα επιστρέφει το 1ο, το 3ο και το 5ο στοιχείο της λίστας της παραμέτρου.
```

**Σημείωση:** είναι υποχρεωτικό να χρησιμοποιήσετε list comprehension


### Άσκηση 22
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο έναν ακέραιο αριθμό Ν. Η συνάρτηση θα θεωρεί ότι έχουμε ένα γονίδιο με Ν εξόνια και Ν-1 ιντρόνια μεταξύ των εξονίων. Η συνάρτηση θα πρέπει να επιστρέφει ένα string, στο οποίο θα φαίνεται η δομή του γονιδίου με τον εξής τρόπο:

```python
f(4) # Επιστρέφει το string: "==exon 1== | ==intron 1== | ==exon 2== | ==intron 2== | ==exon 3== | ==intron 3== | ==exon 4=="
f(3) # Επιστρέφει το string: "==exon 1== | ==intron 1== | ==exon 2== | ==intron 2== | ==exon 3=="
f(2) # Επιστρέφει το string: "==exon 1== | ==intron 1== | ==exon 2=="
f(1) # Επιστρέφει το string: "==exon 1=="
```

### Άσκηση 23
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα πρέπει να επιστρέφει την απάντηση στο ερώτημα: "Ποιο είναι το άθροισμα όλων των αριθμών από το 1 μέχρι 1000 οι οποίοι το τελευταίο ψηφίου τους είναι 7 **ή** διαιρούνται με το 3;". Θα πρέπει δηλαδή να ισχύει:

```python
f() # Επιστρέφει: 200302 
```



### Άσκηση 24
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία λίστα. H λίστα θα αποτελείται από υπο-λίστες. Το πρώτο στοιχείο της κάθε υπολίστας θα είναι το όνομα του γονιδίου. Το δεύτερο στοιχείο θα είναι το πλήθος από εξώνια που περιέχει. Η συνάρτηση θα τυπώνει όλους τους συνδυασμούς γονιδίων/εξονίων που υπάρχουν με τον εξής τρόπο:
```
gene:<όνομα γονιδίου 1> exone: 1
gene:<όνομα γονιδίου 1> exone: 2
...
gene:<όνομα γονιδίου 2> exone: 1
gene:<όνομα γονιδίου 2> exone: 2
```

Για παράδειγμα:
```python
l = [
    ['gene_aaa', 3],
    ['gene_ccc', 2],
    ['gene_ttt', 2],
]

f(l) 
# Τυπώνει:
gene: gene_aaa, exon: 1 
gene: gene_aaa, exon: 2 
gene: gene_aaa, exon: 3 
gene: gene_ccc, exon: 1 
gene: gene_ccc, exon: 2 
gene: gene_ttt, exon: 1 
gene: gene_ttt, exon: 2 
```

### Άσκηση 25
Κάντε το ίδιο με την άσκηση 24, αλλά η συνάρτηση θα τυπώνει μόνο τα γονίδια με άρτιο αριθμό από exons. Για παράδειγμα:

```python
l = [
    ['gene_aaa', 3],
    ['gene_ccc', 2],
    ['gene_ttt', 1],
    ['gene_rrr', 4],

]

f(l) 
# Τυπώνει:
gene: gene_ccc, exon: 1 
gene: gene_ccc, exon: 2 
gene: gene_rrr, exon: 1 
gene: gene_rrr, exon: 2 
gene: gene_rrr, exon: 3 
gene: gene_rrr, exon: 4 
```

### Άσκηση 26
Κάντε το ίδιο με την άσκηση 25. Αυτή τη φορά όμως η συνάρτηση θα παίρνει 2 παράμετρους. Και οι 2 θα είναι λίστες. Η πρώτη θα περιέχει τα ονόματα των γονιδίων και η 2η θα περιέχει το πλήθος από εξώνια που έχουν. Δηλαδή θα πρέπει:

```python
a = ['gene_aaa', 'gene_ccc', 'gene_ttt', 'gene_rrr']
b = [3,2,1,4]


f(a,b) 
# Τυπώνει:
gene: gene_ccc, exon: 1 
gene: gene_ccc, exon: 2 
gene: gene_rrr, exon: 1 
gene: gene_rrr, exon: 2 
gene: gene_rrr, exon: 3 
gene: gene_rrr, exon: 4 
``` 

### Άσκηση 27
Έστω ότι έχουμε μία λίστα η οποία αποτελείται από υπολίστες. Κάθε υπολίστα αποτελείται από 2 στοιχεία. Το πρώτο είναι το όνομα ενός γονιδίου και το δεύτερο είναι μία λίστα με τα μήκη των εξωνίων αυτού του γονιδίου. Για παράδειγμα η λίστα θα μπορούσε να είναι:

```python
l = [
    ['gene_1', [375, 540, 975, 579]],
    ['gene_2', [759, 852, 929, 523, 602, 912]],
    ['gene_3', [378, 256, 132]],
]
```

 Γράψτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία λίστα με την ίδια δομή όπως παρουσιάστηκε παραπάνω. Η συνάρτηση θα επιστρέφει το όνομα του γονίδιου το οποίο έχει το μεγαλύτερο εξώνιο. Δηλαδή θα πρέπει:

```python
f(l) # Επιστρέφει 'gene_1'
# Εξήγηση: Το gene_1 περιέχει ένα εξώνιο το οποίο έχει μήκος 975. Αυτό είναι και το μεγαλύτερο εξώνιο για όλα τα γονίδια της λίστας. 
```

### Άσκηση 28
Έστω ένα dictionary το οποίο έχει string κλειδιά και ακέραια values. Π.χ:

```python
d = {
    'aaa': 23,
    'bbb': 56,
    'ccc': 89, 
    'ddd': 12,
}
```

Φτιάξτε μία συνάρτηση η οποία παίρνει σαν παράμετρο ένα dictionary όπως το παραπάνω. Η συνάρτηση θα πρέπει να επιστρέφει ένα νέο dictionary με τα ίδια κλειδιά. Οι τιμές τους όμως θα είναι αλλαγμένες με τον εξής τρόπο:
* Αν η παλιά τιμή είναι άρτια ή νέα τιμή θα είναι ίση με τη παλιά + 1.
* Αν η παλιά τιμή είναι περιττή ή νέα τιμή θα είναι ίση με τη παλιά - 1.

Για παράδειγμα:
```python
f(d) # Επιστρέφει: {'aaa': 22, 'bbb': 57, 'ccc': 88, 'ddd': 13}

```

### Άσκηση 29
Έστω ένα dictionary το οποίο περιέχει για κλειδιά το όνομα ενός γονιδίου και για τιμές τα μήκη των εξονίων του (σε βάσεις). Για παράδειγμα:
```python
d = {
    'gene_1': [465, 898, 312],
    'gene_2': [232, 629, 456, 918, 122],
    'gene_3': [582, 482, 583],
}
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary όπως το παραπάνω. Η συνάρτηση θα επιστρέφει ένα νέo dictionary το οποίο θα περιέχει τα ίδια κλειδιά, αλλά οι τιμές θα είναι ένας ακέραιος αριθμός που θα είναι το μήκος τους μεγαλύτερου εξονίου του γονιδίου. Για παράδειγμα θα πρέπει:

```python
f(d) # Επιστρέφει: {'gene_1': 898, 'gene_2': 918, 'gene_3': 583} 
```



### Άσκηση 30
Έστω ένα dictionary το οποίο περιέχει για κλειδιά το όνομα ενός γονιδίου και για τιμές τα μήκη των εξονίων του (σε βάσεις). Για παράδειγμα:
```python
d = {
    'gene_1': [465, 898, 312],
    'gene_2': [232, 629, 456, 918, 122],
    'gene_3': [582, 482, 583],
}
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary όπως το παραπάνω. Η συνάρτηση θα επιστρέφει ένα string το οποίο θα είναι το όνομα του γονιδίου με το μεγαλύτερο εξόνιο. Για παράδειγμα:

```python
f(d) # Επιστρέφει 'gene_2'. Αφού το gene_2 είναι το γονίδιο με το μεγαλύτερο εξόνιο (αυτό με μήκος 918)
```

### Άσκηση 31
Ας υποθέσουμε ότι έχουμε φτιάξει μία λίστα με τα είδη του supermarket και τις τιμές τους με αυτόν τον τρόπο:
```python
sm = [
    ('ψωμί', 2.5),
    ('γιαούρτι', 1),
    ('φέτα', 2.8 ),
    ('καφές', 3.0),
    ('νουτέλα', 2.9),
    ('αλεύρι', 3.1),
    ('μπύρες', 5.5),
    ('μάσκες', 8.6),
    ('μακαρόνια', 2.6),
    ('δημητριακά', 3.2),
]
```

Επίσης υποθέτουμε ότι η θέση των προϊόντων στη λίστα έχει να κάνει με τη προτεραιότητα που έχουμε θέσει για την αγορά τους. Δηλαδή μεγαλύτερη προτεραιότητα έχει το ψωμί, μετά το γιαούρτι, μετά η φέτα κτλ. Δυστυχώς όμως υπάρχει ακρίβεια και έχουμε ένα συγκεκριμένο διαθέσιμο ποσό! Ο τρόπος με τον οποίο ψωνίζουμε είναι: παίρνουμε το πρώτο προϊόν της λίστας, μετά το 2ο, μετά το τρίτο, ... μέχρι το κόστος τους να ΜΗΝ ξεπεράσει το ποσό που διαθέτουμε. 

Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 παράμετρους. Η πρώτη θα είναι μία λίστα όπως η παραπάνω (`sm`). Η 2η θα είναι ένας ακέραιος αριθμός με το ποσό που διαθέτουμε. Η συνάρτηση θα πρέπει να επιστρέφει μία λίστα με τα περισσότερα είδη που μπορούμε να αγοράσουμε. Για παράδειγμα θα πρέπει:

```python
f(sm, 10) # Επιστρέφει; ['ψωμί', 'γιαούρτι', 'φέτα', 'καφές']
# Εξήγηση: Αυτά τα είδη κάνουν 2.5+1+2.8+3.0 = 9.3 ευρώ
# Αν πάρουμε το επόμενο προϊόμν της λίστα (νουτέλα) το κόστος των πραγμάτω που θα έχουμε πάρει θα ξεπεράσει το 10
```

**Σημείωση: Είναι υποχρεωτικό να χρησιμοποιήσετε while** 

### Άσκηση 32
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία λίστα με ακέραιους. Η συνάρτηση θα εξετάζει αν η λίστα είναι ταξινομημένη (από το μικρότερο στο μεγαλύτερο) ή όχι. Αν είναι ταξινομημένη τότε επιστρέφει `None`. Αν δεν είναι τότε επιστρέφει το πρώτο "αταξινόμητο" στοιχείο. Δηλαδή, το πρώτο στοιχείο το οποίο το πρηγούμενο του δεν είναι μικρότερο ή ίσο από αυτό. Μερικά παραδείγματα:

```python
f([3,5,7,8]) # Επιστρέφει None, αφού η λίστα είναι ταξινομημένη
f([3,5,8,7]) # Επιστρέφει 7. Το 7 είναι το πρώτο στοιχείο το οποίο "χαλάει τη ταξινόμηση", αφού δεν είναι μεγαλύτερο η ίσο από το προηγούμενό του (το 8). 
f([3,5,4,7]) # Επιστρέφει 4. 
```

**Σημείωση: Είναι υποχρεωτικό να χρησιμοποιήσετε while** 

### Άσκηση 33
Φτιάξτε μία συνάρτηση σε python με το όνομα `f`. Η συνάρτηση πρέπει να είναι έτσι υλοποιημένη ώστε αν κάνω:

```python
print (f()[f()[0]])
```
Να τυπώνει το string `Hello` 

### Άσκηση 34
Ας υποθέσουμε ότι έχουμε μία λίστα με διαστήματα. Για παράδειγμα:
```python
l = [
    (100, 200),
    (50, 150),
    (205, 300),
    (1, 98),
    (50, 90),
]
```

Σε αυτή τη λίστα έχουμε ένα διάστημα απο το 100 μέχρι το 200, ένα 2ο διάστημα από το 50 μέχρι το 150, κτλ. Αν πάρουμε όλους τους αριθμούς από το 1 μέχρι το μεγαλύτερο αριθμό που υπάρχει σε αυτή τη λίστα (στη περίπτωσή μας το 300), ποιοι είναι αυτοί που δεν υπάρχουν σε κανένα διάστημα; Για παράδειγμα θα πρέπει:
```python
f(l) # Επιστρέφει: {201, 202, 203, 204} 
# Εξήγηση: αυτοί οι αριθμοί δεν υπάρχουν σε κανένα διάστημα του l
``` 

Ένα άλλο παράδειγμσ:
```python
l = [
   (2,4),
   (7,10),
]
f(l) # Επιστρέφει: {1,5,6}
```

### Άσκηση 35
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο έναν ακέραιο αριθμό Ν. Η συνάρτηση θα κάνει τα παρακάτω:
1. Θα φτιάχνει ένα σύνολο με όλους τους αριθμούς από 1 μέχρι και το Ν.
2. Από αυτό το σύνολο θα αφαιρεί όλους τους αριθμούς του συνόλου που διαιρούνται με το 2 και το πηλίκο είναι μεγαλύτερο από 1
3. Από αυτό το σύνολο θα αφαιρεί όλους τους αριθμούς του συνόλου που διαιρούνται με το 3 και το πηλίκο είναι μεγαλύτερο από 1
4. ...
5. Από αυτό το σύνολο θα αφαιρεί όλους τους αριθμούς του συνόλου που διαιρούνται με το Ν-1 και το πηλίκο είναι μεγαλύτερο από 1 
6. Θα επιστρέφει το τελικό σύνολο που έχει μείνει. 

Στο τέλος θα πρέπει να επιστρέφει όλους τους πρώτους αριθμούς από 1 μέχρι και το Ν. 

Για παράδειγμα θα πρέπει:
```python
f(100) # Επιστρέφει:  
       # {1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} 
```

### Άσκηση 36
Έστω ότι σας δίνεται ένα dictionary το οποίο έχει πληροφορίες για κάποια γονίδια. Το dictionary έχει την εξής δομή:

```python
d = {
    'gene_name_1': {'exons': 5, 'conserved': False, 'synonyms': ['AAA', 'BBB', 'CCC']},
    'gene_name_2': {'exons': 3, 'conserved': True, 'synonyms': ['DDD', 'CCC', ]},
    'gene_name_3': {'exons': 10, 'conserved': True, 'synonyms': ['FFF', 'AAA', 'HHH' ]},
    'gene_name_4': {'exons': 8, 'conserved': False, 'synonyms': ['III', 'KKK', 'BBB' ]},
}
```

* Χρησιμοποιώντας list comprehension φτιάξτε μία λίστα με όλα τα ονόματα γονιδίων τα οποία να είναι `conserved`. Δηλαδή το αποτέλεσμα πρέπει να είναι: 
```python
['gene_name_2', 'gene_name_3']
```


* Χρησιμοποιώντας dictionary comprehension φτιάξτε ένα dictionary όπου τα κλειδιά θα είναι ονόματα γονιδίων και τιμές θα είναι μία λίστα από αριθμούς από το 1 μέχρι το πλήθος από εξόνια που έχει το γονίδιο. Δηλαδή το αποτέλεσμα πρέπει να είναι:
```python
{
    'gene_name_1': [1,2,3,4,5],
    'gene_name_2': [1,2,3],
    'gene_name_3': [1,2,3,4,5,6,7,8,9,10],
    'gene_name_4': [1,2,3,4,5,6,7,8],
}
```

* Χρησιμοποιώντας set comprehension φτιάξτε ένα set με όλα τα συνόνυμα ονόματα για όλα τα γονίδια. Δηλαδή το αποτέλεσμα πρέπει να είναι:
```python
{'AAA', 'BBB', 'CCC', 'DDD', 'FFF', 'HHH', 'III', 'KKK'}
```

### Άσκηση 37 
Σε αυτό το link: https://www.dropbox.com/s/a3yykilxwu2cxsx/words_english.txt?dl=1 μπορείτε να κατεβάσετε ένα αρχείο με  όλες (!) τις Αγγλικές λέξεις. Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει τη μεγαλύτερη Αγγλική λέξη που υπάρχει στο αρχείο. Δηλαδή θα πρέπει:

```python
f() # Επιστρέφει 'pneumonoultramicroscopicsilicovolcanoconiosis'
```


### Άσκηση 38
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει τη λέξη η οποία έχει τα περισσότερα `n` στην Αγγλική γλώσσα. Δηλαδή θα πρέπει:

```python
f() # Επιστρέφει: nonannouncement ή κάποια άλλη λέξη με 6 n
```

Σημείωση: χρησιμοποιήστε το αρχείο της άσκησης 37.

### Άσκηση 39
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει ένα dictinary όπου:
* Τα κλειδιά του dictionary θα είναι όλα τα μικρά αγγλικά γράμματα
* Η τιμη του dictionary σε κάθε κλειδί θα είναι η αγγλική λέξη που θα έχει τα περισσότερα γράμματα ίδια με το αντίστοιχο κλειδί. 

Δηλαδή θα πρέπει:

```python
f() 
# Επιστρέφει:
{'a': 'astasia-abasia',
 'b': 'bibble-babble',
 'c': 'micrococcocci',
 'd': 'diddle-daddle',
 'e': 'electrotelethermometer',
 'f': 'affusedaffusing',
 'g': 'aggregating',
 'h': 'alpha-naphthylthiourea',
 'i': 'infinito-infinitesimal',
 'j': 'jejuno-jejunostomy',
 'k': 'Akiskemikinik',
 'l': 'allochlorophyll',
 'm': 'Demi-mohammedan',
 'n': 'nonannouncement',
 'o': 'pneumonoultramicroscopicsilicovolcanoconiosis',
 'p': 'Aplopappus',
 'q': 'Abqaiq',
 'r': 'strawberry-raspberry',
 's': 'bras-dessus-bras-dessous',
 't': 'tat-tat-tat',
 'u': 'humuhumunukunukuapuaa',
 'v': 'evviva',
 'w': 'waw-waw',
 'x': 'hexahydroxycyclohexane',
 'y': 'dacryocystosyringotomy',
 'z': 'drizzle-drozzle',
 }

``` 

Σημείωση: χρησιμοποιήστε το αρχείο της άσκησης 37.


### Άσκηση 40
Σε αυτό το link: https://www.dropbox.com/s/tg4r4nn30wwlk7s/words_greek_normalized.txt?dl=1 υπάρχει ένα αρχείο με όλες τις ελληνικές λέξεις. Το αρχείο έχει υποστεί επεξεργασία έτσι ώστε όλες οι λέξεις να περιέχουν μόνο μικρά γράμματα, δεν υπάρχουν τόνοι και διαλυτικά και το τελικό σίγμα έχει αντικατασταθεί με το σίγμα. (Αν θέλετε να παίξετε με το αρχικό αρχείο μπορείτε να το βρείτε [εδώ](https://www.dropbox.com/s/b2513nzbxa37top/words_greek.txt?dl=1)). 

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. H συνάρτηση πρέπει να επιστρέφει τη μεγαλύτερη ελληνική λέξη της οποίας η σειρά των γραμμάτων μέσα στη λέξη να είναι ταξινομημένη αλφαβητικά. Για παράδειγμα αν πάρουμε όλα τα γράμματα της λέξης `δημος` και τα ταξινομήσουμε αλφαβητικά τότε θα πάρουμε τη λίστα: `['δ', 'η', 'μ', 'ο', 'ς']`, η οποία έχει την ίδια σειρά στα γράμματα με την αρχική λέξη. Ενώ αν πάρουμε τη λέξη `βιολογια`, τότε θα πάρουμε τη λίστα: `['α', 'β', 'γ', 'ι', 'ι', 'λ', 'ο', 'ο']` όπου η σειρά των γραμμάτων είναι διαφορετική με την σειρά των γραμμάτων στην αρχική λέξη. Ποια είναι λοιπόν η μεγαλύτερη ελληνική λέξη που έχει αυτή την ιδιότητα; Θα πρέπει δηλαδή:

```python
f() # Επιστρέφει μία από τις 8 ελληνικές λέξεις που έχουν αυτή την ιδιότητα. π.χ:  αγγελοσ, αγγελου, εικοστω, δεικνυω  
``` 

Σημείωση: Επειδή το αρχείο περιέχει ελληνικούς χαρακτήρες, κάποια windows εμφανίζουν πρόβλημα όταν τα ανοίγετε. Για αυτό μπορείτε να βάλετε τη παράμετρο `encoding="utf=8"` στη συνάρτηση open:

```python
with open('words_greek_normalized.txt', encoding='utf-8') as f:
    ...
```

### Άσκηση 41
Έστω ένα αρχείο το οποίο έχει τα εξής περιεχόμενα:

```
3 5 2
0 1 0 1 0
0 0 0 0 0
1 1 0 1 1
```

Σε αυτό το αρχείο η πρώτη γραμμή είναι η επικεφαλίδα και περιέχει 3 αριθμούς. Όλες οι υπόλοιπες γραμμές περιέχουν έναν διδιάστατο πίνακα από ακέραιους αριθμούς. 
* Το πλήθος από γραμμές του πίνακα θα δίνεται από τον πρώτο αριθμό της 1ης γραμμής (3 στη περίπτωσή μας)
* Το πλήθος από στήλες του πίνακα θα δίνεται απο τον δεύτερο αριθμό της 1ης γραμμής (5 στη περίπτωσή μας)
* Η μικρότερη τιμή που μπορεί να πάρουν οι τιμές του πίνακα είναι 0
* Η μεγαλύτερη τιμή που μπορούν να πάρουν οι τιμές του πίνακα είναι ίση με τον τρίτο αριθμό της 1ης γραμμής (2 στη περίπτωσή μας), μειωμένο κατά ένα. Δηλαδή αφού ο τρίτος αριθμός της 1ης γραμμής είναι 2, τότε οι τιμές του διδιάστατου πίνακα μπορούν να είναι από το 0 μέχρι και το 1.

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα string το οποίο θα περιέχει τη διαδρομή και το όνομα ενός αρχείου. Η συνάρτηση θα επιστρέφει:
* `True` αν το αρχείο περιέχει σωστά δεδομένα σύμφωνα με τη παραπάνω περιγραφή. 
* `False` αν το αρχείο δεν περιέχει σωστά δεδομένα. 

Για παράδειγμα:

Αν το αρχείο `a.txt` περιέχει:
```
2 5 2
0 1 0 1 0
0 0 0 0 0
1 1 0 1 1
```

Τότε:
```python
f('a.txt') # Επιστρέφει False (το αρχείο έχει 3 γραμμές και όχι 2, όπως δηλώνει η 1η γραμμή)
```

Αν το αρχείο `b.txt` περιέχει:
```
3 5 2
0 1 0 1
0 0 0 0
1 1 0 1
```

Τότε:
```python
f('b.txt') # Επιστρέφει False (το αρχείο έχει 4 στήλες και όχι 5, όπως δηλώνει η 1η γραμμή)
```


Αν το αρχείο `c.txt` περιέχει:
```
3 5 6
0 1 0 1 0
0 0 0 7 0
1 1 0 1 1
```

Τότε:
```python
f('c.txt') # Επιστρέφει False (ο πίνακας περιέχει τη τιμή 7 ενώ μόνο οι τιμές από το 0 μέχρι και το 5 επιτρέπονται)
```

Αν το αρχείο `d.txt` περιέχει:
```
3 5 2
0 1 0 1 0
0 0 0 0 0
1 1 0 1 1
```

Τότε:
```python
f('d.txt') # Επιστρέφει True. Το αρχείο είναι σωστά φορμαρισμένο!
```




### Άσκηση 42
Έστω ότι το αρχείο `a.txt` έχει τα εξής περιεχόμενα:
```
AA=66,BB=77,CC=88
AA=11,DD=22,EE=33
GG=44,BB=55,CC=66
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο τη διαδρομή και το όνομα ενός αρχείου με την ίδια δομή όπως αυτό που παρουσιάστηκε παραπάνω. Η συνάρτηση θα πρέπει να επεξεργάζεται το αρχείο και να επιστρέφει μία λίστα. Κάθε αντικείμενο της λίστας θα είναι ένα dictionary το οποίο θα έχει τα ζευγάρια κλειδιά/τιμές που περιέχει η αντίστοιχη γραμμή του αρχείου. Θα πρέπει δηλαδή:

```python
f('a.txt') 
# Επιστρέφει:
[
   {'AA':66, 'BB':77, 'CC':88},
   {'AA':11, 'DD':22, 'EE':33},
   {'GG':44, 'BB':55, 'CC':66},
] 
```

### Άσκηση 43
Έστω ότι το αρχείο `a.txt` έχει τα εξής περιεχόμενα:
```
AA=66,BB=77,CC=88
AA=11,BB=22,CC=33
AA=44,BB=55,CC=66
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο τη διαδρομή και το όνομα ενός αρχείου με την ίδια δομή όπως αυτό που παρουσιάστηκε παραπάνω. Η συνάρτηση θα πρέπει να επεξεργάζεται το αρχείο και να επιστρέφει ένα dictionary όπου τα κλειδιά θα είναι όλες οι τιμές στο αριστερό σκέλος του κάθε `=` και οι τιμές θα είναι λίστες με όλες τις τιμές που είναι στο δεξί μέλος του κάθε `=`. Θα πρέπει δηλαδή:

```python
f('a.txt') 
# Επιστρέφει:
{
    'ΑΑ': [66, 11, 44],
    'ΒΒ': [77, 22, 55],
    'CC': [88, 33, 66],
}
```

### Άσκηση 44
Έστω ότι το αρχείο `a.txt` έχει τα εξής περιεχόμενα:
```
AA=66,BB=77,CC=88
AA=11,BB=22,CC=33
AA=44,BB=55,CC=66
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 παράμετρους. Η πρώτη παράμετρος θα είναι η διαδρομή και το όνομα ενός αρχείου με την ίδια δομή όπως αυτό που παρουσιάστηκε παραπάνω. Η δεύτερη παράμετρος θα είναι η διαδρομή και το όνομα ενός αρχείου που δεν υπάρχει. Η συνάρτηση θα πρέπει να διαβάζει το αρχείο της 1ης παραμέτρου και να το σώζει σε μορφή CSV ([Comma-Separated Values](https://en.wikipedia.org/wiki/Comma-separated_values)) στο αρχείο με το όνομα της 2ης παραμέτρου. Θα πρέπει δηλαδή:

```python
f('a.txt', 'a_output.txt')

with open('a_output.txt') as f_output:
    output = f_output.read()
print (output) 
# Τυπώνει:
```

```
AA,BB,CC
66,77,88
11,22,33
44,55,66
```

### Άσκηση 45
Σε αυτό το link: https://ftp.ncbi.nlm.nih.gov/pub/clinvar/gene_condition_source_id περιέχονται όλες οι ασθένειες οι οποίες έχουν συσχετιστεί με κάποια γονίδια. Αποθηκεύστε τα περιεχόμενα αυτού του συνδέσμου σε ένα αρχείο και φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 παραμέτρους. Η πρώτη παράμετρος θα είναι η διαδρομή και το όνομα του αρχείου που αποθηκεύσατε το σύνδεσμο και η 2η παράμετρος θα είναι ένα string. Η συνάρτηση θα επιστρέφει ένα **σύνολο** με τα ονόματα των γονιδίων (στήλη `AssociatedGenes`) τα οποία έχουν συσχετιστεί με κάποια ασθένεια (στήλη `DiseaseName`) η οποία περιέχει τη δεύτερη παράμετρο. Δίνονται μερικά παραδείγματα:

```python
f('gene_condition_source_id.txt', 'Alzheimer')
# Επιστρέφει:
{'ABCA7',
 'ADAM10',
 'APOE',
 'APP',
 'HFE',
 'MPO',
 'NOS3',
 'PLAU',
 'PSEN1',
 'PSEN2'}

f('gene_condition_source_id.txt', 'Schizophrenia')
# Επιστρέφει
{'APOL2',
 'APOL4',
 'CHI3L1',
 'COMT',
 'DAOA',
 'DISC1',
 'DISC2',
 'DRD3',
 'HTR2A',
 'MTHFR',
 'NRG1',
 'NRXN1',
 'PRODH',
 'RBM12',
 'RTN4R',
 'SHANK3',
 'SLC1A1',
 'SYN2'}

f('gene_condition_source_id.txt', 'Rheumatoid arthritis')
# Επιστρέφει:
{'CD244', 'CIITA', 'IL10', 'IL6', 'MIF', 'NFKBIL1', 'PTPN22', 'SLC22A4'}
```

### Άσκηση 46
Υλοποιήστε την άσκηση 9 με ternary operator. Θα πρέπει πάλι να φτιάξετε συνάρτηση.

### Άσκηση 47
Υλοποιήστε την άσκηση 10 με lambda function. Θα πρέπει πάλι να φτιάξετε συνάρτηση.

### Άσκηση 48
Υλοποιήστε την άσκηση 12 με lambda function. Θα πρέπει πάλι να φτιάξετε συνάρτηση.

### Άσκηση 49
Φτιάξτε έναν generator ο οποίος δεν θα παίρνει κανένα όρισμα και θα κάνει generate αγγλικές λέξεις που έχουν 5 γράμματα (δεν έχει σημασία η σειρά). Θα πρέπει δηλαδή:

```python
a = g()
for i in range(10):
    print (next(a))
```
Τυπώνει:
```
2,4-d
30-30
aahed
aalii
Aalst
Aalto
AAMSI
AAPSS
Aarau
Aaren
```

Σημείωση: χρησιμοποιήστε το αρχείο που βρίσκεται εδώ: https://www.dropbox.com/s/a3yykilxwu2cxsx/words_english.txt?dl=1 

### Άσκηση 50
Φτιάξτε έναν generator ο οποίος θα παίρνει σαν παράμετρο ένα string με αγγλικούς χαρακτήρες. Ο generator θα κάνει generate αγγλικές λέξεις οι οποίες είναι αναγραμματισμός της λέξης της παραμέτρου. Θα πρέπει δηλαδή:

```python
for x in g('tomorrow'):
    print (x)
```
Τυπώνει:
```
moorwort
rootworm
wormroot
```

### Άσκηση 51
Φτιάξτε έναν generator οποίος θα παίρνει σαν όρισμα έναν αριθμό Ν. Ο generator θα κάνει generate τυχαίες ακολουθίες DNA μεγέθους Ν. Θα πρέπει δηλαδή:

```python
gen = g(5)
for x in range(10):
    print (next(gen))
``` 
Τυπώνει (προφανώς σε εσάς θα τυπώνει άλλες τυχαίες ακοιλουθίες):
```
TACAA
ATCCG
TCAAG
TCAAA
AACGC
AAGTT
GCTAA
TGAGT
ACTAG
AATAT
```

### Άσκηση 52

Συμπληρώστε την επόμενη έκφραση:
```python
f = lambda ...
```

Έτσι ώστε όταν γράφω:
```python
print (  f()[1]()['mitsos']  )
```
Να τυπώνει:
```
Hello
```

### Άσκηση 53
Γράψτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα ρίχνει 2 ζάρια 100.000 φορές και θα επιστρέφει το ποσοστό των φορών που το αποτέλεσμα είναι "ασσόδυο", δηλαδή το ένα ζάρι να είναι 1 και το άλλο 2. 

### Άσκηση 54
Σε αυτό το link: https://ftp.ncbi.nlm.nih.gov/pub/clinvar/gene_condition_source_id περιέχονται όλες οι ασθένειες οι οποίες έχουν συσχετιστεί με κάποια γονίδια. Αποθηκεύστε τα περιεχόμενα αυτού του συνδέσμου σε ένα αρχείο και φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα επιστρέφει μία λίστα με τα 10 γονίδια που βρίσκονται ποιο συχνά στη 2η και στη 3η στήλη (αγνοήστε το κενό string που υπάρχει σε κάποιες στήλες).  

Σημείωση: είναι υποχρεωτικό να χρησιμοποιήσετε Counter ή defaultdict ή και τα δύο μαζί!

Θα πρέπει δηλαδή:
```python
f()
# Επιστρέφει:
['LMNA',
 'COL2A1',
 'CAV3',
 'MYH6',
 'FGFR2',
 'FGFR3',
 'BRAF',
 'BRCA2',
 'KRAS',
 'TP53']
```

### Άσκηση 55
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα επιστρέφει μία τυχαια ακολουθία DNA (δηλαδή string που έχει μόνο `A`,`C`,`G`,`T`) μήκους 10 η οποία όμως θα έχει υποχρεωτικά 3 `A`, 3 `C`, 3 `G` και 1 `T`.  Θα πρέπει δηλαδή:

```python
from collections import Counter

s = f()
c = Counter(s)

print (c['A'] == 3) # Τυπώνει True
print (c['C'] == 3) # Τυπώνει True
print (c['G'] == 3) # Τυπώνει True
print (c['T'] == 1) # Τυπώνει True


```

### Άσκηση 56
Υλοποιήστε ξανα τη συνάρτηση της άσκησης 9. Η συνάρτηση θα πρέπει:
* Να πετάει το exception [TypeError](https://docs.python.org/3/library/exceptions.html#TypeError) αν ένα από τα ορίσματα δεν είναι αριθμός (int ή float)
* Να πετάει το exception [OverflowError](https://docs.python.org/3/library/exceptions.html#OverflowError) αν έχει άπειρες λύσεις
* Να πετάει το exception [ZeroDivisionError](https://docs.python.org/3/library/exceptions.html#ZeroDivisionError) αν είναι αδύνατη.

Αν δεν συμβεί τίποτα από τα παραπάνω, η συνάρτηση θα επιστρέφει το αποτέλεσμα της λύσης ax+b=0. 

Για παράδειγμα θα πρέπει:

```python
f(0, 3)

# Πετάει κάτι σαν αυτό:
ZeroDivisionError                         Traceback (most recent call last)
<ipython-input-11-255902b873a2> in <module>
----> 1 f(0, 3)
```

### Άσκηση 57
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 ορίσματα a,b. Η συνάρτηση θα καλέι την συνάρτηση της άσκησης 56 με τα ίδια ορίσματα. 
* Αν η συνάρτηση της άσκησης 56 πετάξει TypeError τότε η συνάρτηση θα επιτρέφει το string "λάθος τύπος μεταβλητής"
* Αν η συνάρτηση της άσκησης 56 πετάξει OverflowError τότε η συνάρτηση θα επιτρέφει το string "άπειρες λύσεις"
* Αν η συνάρτηση της άσκησης 56 πετάξει ZeroDivisionError τότε η συνάρτηση θα επιτρέφει το string "αδύνατη"

Διαφορετικά θα επιστρέφει τη τιμή που επέστρεψε η συνάρτηση της άσκησης 56. Για παράδειγμα θα πρέπει:

```python
f(0, 3) # Επιστρέφει: "αδύνατη"
```

### Άσκηση 58
Φτιάξτε μία συνάρτηση η οποία θα κάνει ότι και η συνάρτηση της άσκησης 42. Η διαφορά θα είναι ότι δεν θα επιστρέφει τίποτα και θα αποθηκεύει το αποτέλεσμα σε ένα αρχείο json με το όνομα: `ask_58.json`.

### Άσκηση 59
(παρόμοια με 43)

Έστω ότι το αρχείο `a.json` έχει τα εξής περιεχόμενα:
```json
[
    {
        "AA": 66,
        "BB": 77,
        "CC": 88
    },
    {
        "AA": 11,
        "BB": 22,
        "CC": 33
    },
    {
        "AA": 44,
        "BB": 55,
        "CC": 66
    }
]
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο τη διαδρομή και το όνομα ενός αρχείου του οποίου τα περιεχόμενα έχουν την ίδια δομή όπως αυτό που παρουσιάστηκε παραπάνω. Η συνάρτηση θα πρέπει να επεξεργάζεται το αρχείο και να επιστρέφει ένα dictionary όπου τα κλειδιά θα είναι όλα τα κλειδιά του κάθε dictionary στο αρχείο και οι τιμές θα είναι λίστες με όλες τις τιμές του κάθε dictionary του αρχείου. Θα πρέπει δηλαδή:

```python
f('a.json') 
# Επιστρέφει:
{
    'ΑΑ': [66, 11, 44],
    'ΒΒ': [77, 22, 55],
    'CC': [88, 33, 66],
}
```

### Άσκηση 60
Οι Ελληνικές πινακίδες οχημάτων ιδιωτικής χρήσεως αποτελούνται από:
* Τρία γράμματα τα οποία μπορούν να είναι: `ΑΒΕΖΗΙΚΜΝΟΡΤΥΧ`
* 4 αριθμούς εκ των οποίων ο πρώτος είναι από 1 μέχρι και το 9 και οι υπόλοιποι 3 από το 0 μέχρι το και το 9.

Φτιάξτε έναν generator (έστω `gen`) ο οποίος δεν θα παίρνει κανένα όρισμα. Ο generator θα πρέπει να κάνει generate όλα τα strings τα οποία αναπαριστούν ελληνικές πινακίδες οχημάτων. Για παράδειγμα θα πρέπει:

```python
g = gen()
for x in range(15):
    print (next(g))
```
Τυπώνει:
```
ΑΑΑ1000
ΑΑΑ1001
ΑΑΑ1002
ΑΑΑ1003
ΑΑΑ1004
ΑΑΑ1005
ΑΑΑ1006
ΑΑΑ1007
ΑΑΑ1008
ΑΑΑ1009
ΑΑΑ1010
ΑΑΑ1011
ΑΑΑ1012
ΑΑΑ1013
ΑΑΑ1014
```

Ένα άλλο παράδειγμα:
```python
c = 0
for x in gen():
    c += 1
print (c) # Τυπώνει 24696000 (14 * 14 * 14 * 9 * 10 * 10 * 10)  (προσοχή! αυτό κάνει γύρω στα 2 λεπτά για να τρέξει)
```

Σημείωση: αν και δεν είναι υποχρεωτικό συνίσταται (και είναι πολύ απλό!) να χρησιμοποιήσετε τη [product](https://docs.python.org/3/library/itertools.html#itertools.product)

### Άσκηση 61
Ας υποθέσουμε ότι έχουμε ένα dictionary όπως το παρακάτω:
```python
lengths = {
 'protein_1': 756,
 'protein_2': 913,
 'protein_3': 953,
 'protein_4': 337,
 'protein_5': 410,
 'protein_6': 415,
 'protein_7': 685,
 'protein_8': 603,
 'protein_9': 827,
 'protein_10': 558,
 'protein_11': 819,
 'protein_12': 412,
 'protein_13': 910,
 'protein_14': 276,
 'protein_15': 234,
 'protein_16': 219,
 'protein_17': 543,
 'protein_18': 407,
 'protein_19': 856,
 'protein_20': 139,
 'protein_21': 724,
 'protein_22': 892,
 'protein_23': 158,
 'protein_24': 136,
 'protein_25': 126,
 'protein_26': 154,
 'protein_27': 734,
 'protein_28': 133,
 'protein_29': 579,
 'protein_30': 726,
 'protein_31': 362,
 'protein_32': 583,
 'protein_33': 711,
 'protein_34': 427,
 'protein_35': 634,
 'protein_36': 240,
 'protein_37': 914,
 'protein_38': 282,
 'protein_39': 459,
 'protein_40': 715,
 'protein_41': 273,
 'protein_42': 306,
 'protein_43': 728,
 'protein_44': 382,
 'protein_45': 479,
 'protein_46': 579,
 'protein_47': 515,
 'protein_48': 112,
 'protein_49': 620,
 'protein_50': 499,
 } 
```

To dictionary αυτό περιέχει τα μήκη (σε αμινοξέα) από 50 πρωτεΐνες. Ανακαλύπτουμε ότι υπάρχει μία πρωτεΐνη η οποία έχει προέλθει από την συνένωση 3 πρωτεϊνών από το παραπάνω dictionary. Το μόνο που ξέρουμε είναι ότι το μήκος της πρωτεΐνης είναι 2300 αμινοξέα. Υπάρχει μόνο μία τριάδα από πρωτείνες που ανήκουν στο παραπάνω dictionary που αν προσθέσουμε το μήκος τους το αποτέλεσμα θα είναι 2300. Ποια είναι αυτή η τριάδα; 

Φτιάξτε μία συνάρτηση η οποία δεν θα παιρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει την απάντηση σε αυτή την ερώτηση με τη μορφή μίας λίστας. Βάλτε όλο τον κώδικά για τη λύση αυτής της άσκησης σε αυτή τη συνάρτηση (το dictionary `length` μπορεί να είναι και έξω από τη συνάρτηση).

Σημείωση: αν και δεν είναι υποχρεωτικό συνίσταται (και είναι πολύ απλό!) να χρησιμοποιήσετε τη [combinations](https://docs.python.org/3/library/itertools.html#itertools.combinations)


### Άσκηση 62
H συνάρτηση [groupby](https://docs.python.org/3/library/itertools.html#itertools.groupby), επιστρέφει έναν generator ο οποίος ομαδοποιεί σε groups τα συνεχόμενα κοινά στοιχεία μίας λίστας (ή tuple, ή string, ή generator). Για παράδειγμα ας υποθέσουμε ότι έχουμε τη λίστα: `[0,0,1,1,1,0,1,1,0]`. Μπορεί κάποιος να πει ότι αυτή η λίστα αποτελείται από τα ακόλουθα groups με ίδια στοιχεία: 
* Group 1: 2 φορές το 0
* Group 2: 3 φορές το 1
* Group 3: 1 φορά το 0
* Group 4: 2 φορές το 1
* Group 5: 1 φορά το 0

Αυτό μπορεί να γραφτεί σε python ως εξής:


```python
from itertools import groupby
l = [0,0,1,1,1,0,1,1,0]

group_number = 0
for group_item, group_gen in groupby(l):
    group_number += 1
    group_length = len(list(group_gen))
    
    print (f'Group {group_number}: {group_length} φορές το {group_item}')

```
Αυτό τυπώνει:
```
Group 1: 2 φορές το 0
Group 2: 3 φορές το 1
Group 3: 1 φορές το 0
Group 4: 2 φορές το 1
Group 5: 1 φορές το 0
```

H groupby κάνει generate ένα tuple το οποίο έχει 2 στοιχεία. Το πρώτο (`group_item` στο παράδειγμά μας) είναι μία τιμή που αναφέρεται στη ταυτότητα του group (τι διαφοροποιεί αυτό το group από τα άλλα). Το δεύτερο (`group_gen` στο παράδειγμά μας) είναι ένας generator ο οποίο κάνει generate όλα τα μέλη του group. 

Με βάση τα παραπάνω απαντήστε στην ερώτηση: Ποια είναι το μεγαλύτερο string το οποίο να αποτελείται από μόνο 1 γράμμα (μία βάση) και να υπάρχει μέσα στο DNA του γονιδίου BRCA2; Το DNA του BRCA2 είναι ([πηγή](https://www.ncbi.nlm.nih.gov/nuccore/NM_000059.4?report=fasta)):

```python
BRCA2 = '''
AGAGGCGGAGCCGCTGTGGCACTGCTGCGCCTCTGCTGCGCCTCGGGTGTCTTTTGCGGCGGTGGGTCGC
CGCCGGGAGAAGCGTGAGGGGACAGATTTGTGACCGGCGCGGTTTTTGTCAGCTTACTCCGGCCAAAAAA
GAACTGCACCTCTGGAGCGGACTTATTTACCAAGCATTGGAGGAATATCGTAGGTAAAAATGCCTATTGG
ATCCAAAGAGAGGCCAACATTTTTTGAAATTTTTAAGACACGCTGCAACAAAGCAGATTTAGGACCAATA
AGTCTTAATTGGTTTGAAGAACTTTCTTCAGAAGCTCCACCCTATAATTCTGAACCTGCAGAAGAATCTG
AACATAAAAACAACAATTACGAACCAAACCTATTTAAAACTCCACAAAGGAAACCATCTTATAATCAGCT
GGCTTCAACTCCAATAATATTCAAAGAGCAAGGGCTGACTCTGCCGCTGTACCAATCTCCTGTAAAAGAA
TTAGATAAATTCAAATTAGACTTAGGAAGGAATGTTCCCAATAGTAGACATAAAAGTCTTCGCACAGTGA
AAACTAAAATGGATCAAGCAGATGATGTTTCCTGTCCACTTCTAAATTCTTGTCTTAGTGAAAGTCCTGT
TGTTCTACAATGTACACATGTAACACCACAAAGAGATAAGTCAGTGGTATGTGGGAGTTTGTTTCATACA
CCAAAGTTTGTGAAGGGTCGTCAGACACCAAAACATATTTCTGAAAGTCTAGGAGCTGAGGTGGATCCTG
ATATGTCTTGGTCAAGTTCTTTAGCTACACCACCCACCCTTAGTTCTACTGTGCTCATAGTCAGAAATGA
AGAAGCATCTGAAACTGTATTTCCTCATGATACTACTGCTAATGTGAAAAGCTATTTTTCCAATCATGAT
GAAAGTCTGAAGAAAAATGATAGATTTATCGCTTCTGTGACAGACAGTGAAAACACAAATCAAAGAGAAG
CTGCAAGTCATGGATTTGGAAAAACATCAGGGAATTCATTTAAAGTAAATAGCTGCAAAGACCACATTGG
AAAGTCAATGCCAAATGTCCTAGAAGATGAAGTATATGAAACAGTTGTAGATACCTCTGAAGAAGATAGT
TTTTCATTATGTTTTTCTAAATGTAGAACAAAAAATCTACAAAAAGTAAGAACTAGCAAGACTAGGAAAA
AAATTTTCCATGAAGCAAACGCTGATGAATGTGAAAAATCTAAAAACCAAGTGAAAGAAAAATACTCATT
TGTATCTGAAGTGGAACCAAATGATACTGATCCATTAGATTCAAATGTAGCAAATCAGAAGCCCTTTGAG
AGTGGAAGTGACAAAATCTCCAAGGAAGTTGTACCGTCTTTGGCCTGTGAATGGTCTCAACTAACCCTTT
CAGGTCTAAATGGAGCCCAGATGGAGAAAATACCCCTATTGCATATTTCTTCATGTGACCAAAATATTTC
AGAAAAAGACCTATTAGACACAGAGAACAAAAGAAAGAAAGATTTTCTTACTTCAGAGAATTCTTTGCCA
CGTATTTCTAGCCTACCAAAATCAGAGAAGCCATTAAATGAGGAAACAGTGGTAAATAAGAGAGATGAAG
AGCAGCATCTTGAATCTCATACAGACTGCATTCTTGCAGTAAAGCAGGCAATATCTGGAACTTCTCCAGT
GGCTTCTTCATTTCAGGGTATCAAAAAGTCTATATTCAGAATAAGAGAATCACCTAAAGAGACTTTCAAT
GCAAGTTTTTCAGGTCATATGACTGATCCAAACTTTAAAAAAGAAACTGAAGCCTCTGAAAGTGGACTGG
AAATACATACTGTTTGCTCACAGAAGGAGGACTCCTTATGTCCAAATTTAATTGATAATGGAAGCTGGCC
AGCCACCACCACACAGAATTCTGTAGCTTTGAAGAATGCAGGTTTAATATCCACTTTGAAAAAGAAAACA
AATAAGTTTATTTATGCTATACATGATGAAACATCTTATAAAGGAAAAAAAATACCGAAAGACCAAAAAT
CAGAACTAATTAACTGTTCAGCCCAGTTTGAAGCAAATGCTTTTGAAGCACCACTTACATTTGCAAATGC
TGATTCAGGTTTATTGCATTCTTCTGTGAAAAGAAGCTGTTCACAGAATGATTCTGAAGAACCAACTTTG
TCCTTAACTAGCTCTTTTGGGACAATTCTGAGGAAATGTTCTAGAAATGAAACATGTTCTAATAATACAG
TAATCTCTCAGGATCTTGATTATAAAGAAGCAAAATGTAATAAGGAAAAACTACAGTTATTTATTACCCC
AGAAGCTGATTCTCTGTCATGCCTGCAGGAAGGACAGTGTGAAAATGATCCAAAAAGCAAAAAAGTTTCA
GATATAAAAGAAGAGGTCTTGGCTGCAGCATGTCACCCAGTACAACATTCAAAAGTGGAATACAGTGATA
CTGACTTTCAATCCCAGAAAAGTCTTTTATATGATCATGAAAATGCCAGCACTCTTATTTTAACTCCTAC
TTCCAAGGATGTTCTGTCAAACCTAGTCATGATTTCTAGAGGCAAAGAATCATACAAAATGTCAGACAAG
CTCAAAGGTAACAATTATGAATCTGATGTTGAATTAACCAAAAATATTCCCATGGAAAAGAATCAAGATG
TATGTGCTTTAAATGAAAATTATAAAAACGTTGAGCTGTTGCCACCTGAAAAATACATGAGAGTAGCATC
ACCTTCAAGAAAGGTACAATTCAACCAAAACACAAATCTAAGAGTAATCCAAAAAAATCAAGAAGAAACT
ACTTCAATTTCAAAAATAACTGTCAATCCAGACTCTGAAGAACTTTTCTCAGACAATGAGAATAATTTTG
TCTTCCAAGTAGCTAATGAAAGGAATAATCTTGCTTTAGGAAATACTAAGGAACTTCATGAAACAGACTT
GACTTGTGTAAACGAACCCATTTTCAAGAACTCTACCATGGTTTTATATGGAGACACAGGTGATAAACAA
GCAACCCAAGTGTCAATTAAAAAAGATTTGGTTTATGTTCTTGCAGAGGAGAACAAAAATAGTGTAAAGC
AGCATATAAAAATGACTCTAGGTCAAGATTTAAAATCGGACATCTCCTTGAATATAGATAAAATACCAGA
AAAAAATAATGATTACATGAACAAATGGGCAGGACTCTTAGGTCCAATTTCAAATCACAGTTTTGGAGGT
AGCTTCAGAACAGCTTCAAATAAGGAAATCAAGCTCTCTGAACATAACATTAAGAAGAGCAAAATGTTCT
TCAAAGATATTGAAGAACAATATCCTACTAGTTTAGCTTGTGTTGAAATTGTAAATACCTTGGCATTAGA
TAATCAAAAGAAACTGAGCAAGCCTCAGTCAATTAATACTGTATCTGCACATTTACAGAGTAGTGTAGTT
GTTTCTGATTGTAAAAATAGTCATATAACCCCTCAGATGTTATTTTCCAAGCAGGATTTTAATTCAAACC
ATAATTTAACACCTAGCCAAAAGGCAGAAATTACAGAACTTTCTACTATATTAGAAGAATCAGGAAGTCA
GTTTGAATTTACTCAGTTTAGAAAACCAAGCTACATATTGCAGAAGAGTACATTTGAAGTGCCTGAAAAC
CAGATGACTATCTTAAAGACCACTTCTGAGGAATGCAGAGATGCTGATCTTCATGTCATAATGAATGCCC
CATCGATTGGTCAGGTAGACAGCAGCAAGCAATTTGAAGGTACAGTTGAAATTAAACGGAAGTTTGCTGG
CCTGTTGAAAAATGACTGTAACAAAAGTGCTTCTGGTTATTTAACAGATGAAAATGAAGTGGGGTTTAGG
GGCTTTTATTCTGCTCATGGCACAAAACTGAATGTTTCTACTGAAGCTCTGCAAAAAGCTGTGAAACTGT
TTAGTGATATTGAGAATATTAGTGAGGAAACTTCTGCAGAGGTACATCCAATAAGTTTATCTTCAAGTAA
ATGTCATGATTCTGTTGTTTCAATGTTTAAGATAGAAAATCATAATGATAAAACTGTAAGTGAAAAAAAT
AATAAATGCCAACTGATATTACAAAATAATATTGAAATGACTACTGGCACTTTTGTTGAAGAAATTACTG
AAAATTACAAGAGAAATACTGAAAATGAAGATAACAAATATACTGCTGCCAGTAGAAATTCTCATAACTT
AGAATTTGATGGCAGTGATTCAAGTAAAAATGATACTGTTTGTATTCATAAAGATGAAACGGACTTGCTA
TTTACTGATCAGCACAACATATGTCTTAAATTATCTGGCCAGTTTATGAAGGAGGGAAACACTCAGATTA
AAGAAGATTTGTCAGATTTAACTTTTTTGGAAGTTGCGAAAGCTCAAGAAGCATGTCATGGTAATACTTC
AAATAAAGAACAGTTAACTGCTACTAAAACGGAGCAAAATATAAAAGATTTTGAGACTTCTGATACATTT
TTTCAGACTGCAAGTGGGAAAAATATTAGTGTCGCCAAAGAGTCATTTAATAAAATTGTAAATTTCTTTG
ATCAGAAACCAGAAGAATTGCATAACTTTTCCTTAAATTCTGAATTACATTCTGACATAAGAAAGAACAA
AATGGACATTCTAAGTTATGAGGAAACAGACATAGTTAAACACAAAATACTGAAAGAAAGTGTCCCAGTT
GGTACTGGAAATCAACTAGTGACCTTCCAGGGACAACCCGAACGTGATGAAAAGATCAAAGAACCTACTC
TATTGGGTTTTCATACAGCTAGCGGGAAAAAAGTTAAAATTGCAAAGGAATCTTTGGACAAAGTGAAAAA
CCTTTTTGATGAAAAAGAGCAAGGTACTAGTGAAATCACCAGTTTTAGCCATCAATGGGCAAAGACCCTA
AAGTACAGAGAGGCCTGTAAAGACCTTGAATTAGCATGTGAGACCATTGAGATCACAGCTGCCCCAAAGT
GTAAAGAAATGCAGAATTCTCTCAATAATGATAAAAACCTTGTTTCTATTGAGACTGTGGTGCCACCTAA
GCTCTTAAGTGATAATTTATGTAGACAAACTGAAAATCTCAAAACATCAAAAAGTATCTTTTTGAAAGTT
AAAGTACATGAAAATGTAGAAAAAGAAACAGCAAAAAGTCCTGCAACTTGTTACACAAATCAGTCCCCTT
ATTCAGTCATTGAAAATTCAGCCTTAGCTTTTTACACAAGTTGTAGTAGAAAAACTTCTGTGAGTCAGAC
TTCATTACTTGAAGCAAAAAAATGGCTTAGAGAAGGAATATTTGATGGTCAACCAGAAAGAATAAATACT
GCAGATTATGTAGGAAATTATTTGTATGAAAATAATTCAAACAGTACTATAGCTGAAAATGACAAAAATC
ATCTCTCCGAAAAACAAGATACTTATTTAAGTAACAGTAGCATGTCTAACAGCTATTCCTACCATTCTGA
TGAGGTATATAATGATTCAGGATATCTCTCAAAAAATAAACTTGATTCTGGTATTGAGCCAGTATTGAAG
AATGTTGAAGATCAAAAAAACACTAGTTTTTCCAAAGTAATATCCAATGTAAAAGATGCAAATGCATACC
CACAAACTGTAAATGAAGATATTTGCGTTGAGGAACTTGTGACTAGCTCTTCACCCTGCAAAAATAAAAA
TGCAGCCATTAAATTGTCCATATCTAATAGTAATAATTTTGAGGTAGGGCCACCTGCATTTAGGATAGCC
AGTGGTAAAATCGTTTGTGTTTCACATGAAACAATTAAAAAAGTGAAAGACATATTTACAGACAGTTTCA
GTAAAGTAATTAAGGAAAACAACGAGAATAAATCAAAAATTTGCCAAACGAAAATTATGGCAGGTTGTTA
CGAGGCATTGGATGATTCAGAGGATATTCTTCATAACTCTCTAGATAATGATGAATGTAGCACGCATTCA
CATAAGGTTTTTGCTGACATTCAGAGTGAAGAAATTTTACAACATAACCAAAATATGTCTGGATTGGAGA
AAGTTTCTAAAATATCACCTTGTGATGTTAGTTTGGAAACTTCAGATATATGTAAATGTAGTATAGGGAA
GCTTCATAAGTCAGTCTCATCTGCAAATACTTGTGGGATTTTTAGCACAGCAAGTGGAAAATCTGTCCAG
GTATCAGATGCTTCATTACAAAACGCAAGACAAGTGTTTTCTGAAATAGAAGATAGTACCAAGCAAGTCT
TTTCCAAAGTATTGTTTAAAAGTAACGAACATTCAGACCAGCTCACAAGAGAAGAAAATACTGCTATACG
TACTCCAGAACATTTAATATCCCAAAAAGGCTTTTCATATAATGTGGTAAATTCATCTGCTTTCTCTGGA
TTTAGTACAGCAAGTGGAAAGCAAGTTTCCATTTTAGAAAGTTCCTTACACAAAGTTAAGGGAGTGTTAG
AGGAATTTGATTTAATCAGAACTGAGCATAGTCTTCACTATTCACCTACGTCTAGACAAAATGTATCAAA
AATACTTCCTCGTGTTGATAAGAGAAACCCAGAGCACTGTGTAAACTCAGAAATGGAAAAAACCTGCAGT
AAAGAATTTAAATTATCAAATAACTTAAATGTTGAAGGTGGTTCTTCAGAAAATAATCACTCTATTAAAG
TTTCTCCATATCTCTCTCAATTTCAACAAGACAAACAACAGTTGGTATTAGGAACCAAAGTGTCACTTGT
TGAGAACATTCATGTTTTGGGAAAAGAACAGGCTTCACCTAAAAACGTAAAAATGGAAATTGGTAAAACT
GAAACTTTTTCTGATGTTCCTGTGAAAACAAATATAGAAGTTTGTTCTACTTACTCCAAAGATTCAGAAA
ACTACTTTGAAACAGAAGCAGTAGAAATTGCTAAAGCTTTTATGGAAGATGATGAACTGACAGATTCTAA
ACTGCCAAGTCATGCCACACATTCTCTTTTTACATGTCCCGAAAATGAGGAAATGGTTTTGTCAAATTCA
AGAATTGGAAAAAGAAGAGGAGAGCCCCTTATCTTAGTGGGAGAACCCTCAATCAAAAGAAACTTATTAA
ATGAATTTGACAGGATAATAGAAAATCAAGAAAAATCCTTAAAGGCTTCAAAAAGCACTCCAGATGGCAC
AATAAAAGATCGAAGATTGTTTATGCATCATGTTTCTTTAGAGCCGATTACCTGTGTACCCTTTCGCACA
ACTAAGGAACGTCAAGAGATACAGAATCCAAATTTTACCGCACCTGGTCAAGAATTTCTGTCTAAATCTC
ATTTGTATGAACATCTGACTTTGGAAAAATCTTCAAGCAATTTAGCAGTTTCAGGACATCCATTTTATCA
AGTTTCTGCTACAAGAAATGAAAAAATGAGACACTTGATTACTACAGGCAGACCAACCAAAGTCTTTGTT
CCACCTTTTAAAACTAAATCACATTTTCACAGAGTTGAACAGTGTGTTAGGAATATTAACTTGGAGGAAA
ACAGACAAAAGCAAAACATTGATGGACATGGCTCTGATGATAGTAAAAATAAGATTAATGACAATGAGAT
TCATCAGTTTAACAAAAACAACTCCAATCAAGCAGTAGCTGTAACTTTCACAAAGTGTGAAGAAGAACCT
TTAGATTTAATTACAAGTCTTCAGAATGCCAGAGATATACAGGATATGCGAATTAAGAAGAAACAAAGGC
AACGCGTCTTTCCACAGCCAGGCAGTCTGTATCTTGCAAAAACATCCACTCTGCCTCGAATCTCTCTGAA
AGCAGCAGTAGGAGGCCAAGTTCCCTCTGCGTGTTCTCATAAACAGCTGTATACGTATGGCGTTTCTAAA
CATTGCATAAAAATTAACAGCAAAAATGCAGAGTCTTTTCAGTTTCACACTGAAGATTATTTTGGTAAGG
AAAGTTTATGGACTGGAAAAGGAATACAGTTGGCTGATGGTGGATGGCTCATACCCTCCAATGATGGAAA
GGCTGGAAAAGAAGAATTTTATAGGGCTCTGTGTGACACTCCAGGTGTGGATCCAAAGCTTATTTCTAGA
ATTTGGGTTTATAATCACTATAGATGGATCATATGGAAACTGGCAGCTATGGAATGTGCCTTTCCTAAGG
AATTTGCTAATAGATGCCTAAGCCCAGAAAGGGTGCTTCTTCAACTAAAATACAGATATGATACGGAAAT
TGATAGAAGCAGAAGATCGGCTATAAAAAAGATAATGGAAAGGGATGACACAGCTGCAAAAACACTTGTT
CTCTGTGTTTCTGACATAATTTCATTGAGCGCAAATATATCTGAAACTTCTAGCAATAAAACTAGTAGTG
CAGATACCCAAAAAGTGGCCATTATTGAACTTACAGATGGGTGGTATGCTGTTAAGGCCCAGTTAGATCC
TCCCCTCTTAGCTGTCTTAAAGAATGGCAGACTGACAGTTGGTCAGAAGATTATTCTTCATGGAGCAGAA
CTGGTGGGCTCTCCTGATGCCTGTACACCTCTTGAAGCCCCAGAATCTCTTATGTTAAAGATTTCTGCTA
ACAGTACTCGGCCTGCTCGCTGGTATACCAAACTTGGATTCTTTCCTGACCCTAGACCTTTTCCTCTGCC
CTTATCATCGCTTTTCAGTGATGGAGGAAATGTTGGTTGTGTTGATGTAATTATTCAAAGAGCATACCCT
ATACAGTGGATGGAGAAGACATCATCTGGATTATACATATTTCGCAATGAAAGAGAGGAAGAAAAGGAAG
CAGCAAAATATGTGGAGGCCCAACAAAAGAGACTAGAAGCCTTATTCACTAAAATTCAGGAGGAATTTGA
AGAACATGAAGAAAACACAACAAAACCATATTTACCATCACGTGCACTAACAAGACAGCAAGTTCGTGCT
TTGCAAGATGGTGCAGAGCTTTATGAAGCAGTGAAGAATGCAGCAGACCCAGCTTACCTTGAGGGTTATT
TCAGTGAAGAGCAGTTAAGAGCCTTGAATAATCACAGGCAAATGTTGAATGATAAGAAACAAGCTCAGAT
CCAGTTGGAAATTAGGAAGGCCATGGAATCTGCTGAACAAAAGGAACAAGGTTTATCAAGGGATGTCACA
ACCGTGTGGAAGTTGCGTATTGTAAGCTATTCAAAAAAAGAAAAAGATTCAGTTATACTGAGTATTTGGC
GTCCATCATCAGATTTATATTCTCTGTTAACAGAAGGAAAGAGATACAGAATTTATCATCTTGCAACTTC
AAAATCTAAAAGTAAATCTGAAAGAGCTAACATACAGTTAGCAGCGACAAAAAAAACTCAGTATCAACAA
CTACCGGTTTCAGATGAAATTTTATTTCAGATTTACCAGCCACGGGAGCCCCTTCACTTCAGCAAATTTT
TAGATCCAGACTTTCAGCCATCTTGTTCTGAGGTGGACCTAATAGGATTTGTCGTTTCTGTTGTGAAAAA
AACAGGACTTGCCCCTTTCGTCTATTTGTCAGACGAATGTTACAATTTACTGGCAATAAAGTTTTGGATA
GACCTTAATGAGGACATTATTAAGCCTCATATGTTAATTGCTGCAAGCAACCTCCAGTGGCGACCAGAAT
CCAAATCAGGCCTTCTTACTTTATTTGCTGGAGATTTTTCTGTGTTTTCTGCTAGTCCAAAAGAGGGCCA
CTTTCAAGAGACATTCAACAAAATGAAAAATACTGTTGAGAATATTGACATACTTTGCAATGAAGCAGAA
AACAAGCTTATGCATATACTGCATGCAAATGATCCCAAGTGGTCCACCCCAACTAAAGACTGTACTTCAG
GGCCGTACACTGCTCAAATCATTCCTGGTACAGGAAACAAGCTTCTGATGTCTTCTCCTAATTGTGAGAT
ATATTATCAAAGTCCTTTATCACTTTGTATGGCCAAAAGGAAGTCTGTTTCCACACCTGTCTCAGCCCAG
ATGACTTCAAAGTCTTGTAAAGGGGAGAAAGAGATTGATGACCAAAAGAACTGCAAAAAGAGAAGAGCCT
TGGATTTCTTGAGTAGACTGCCTTTACCTCCACCTGTTAGTCCCATTTGTACATTTGTTTCTCCGGCTGC
ACAGAAGGCATTTCAGCCACCAAGGAGTTGTGGCACCAAATACGAAACACCCATAAAGAAAAAAGAACTG
AATTCTCCTCAGATGACTCCATTTAAAAAATTCAATGAAATTTCTCTTTTGGAAAGTAATTCAATAGCTG
ACGAAGAACTTGCATTGATAAATACCCAAGCTCTTTTGTCTGGTTCAACAGGAGAAAAACAATTTATATC
TGTCAGTGAATCCACTAGGACTGCTCCCACCAGTTCAGAAGATTATCTCAGACTGAAACGACGTTGTACT
ACATCTCTGATCAAAGAACAGGAGAGTTCCCAGGCCAGTACGGAAGAATGTGAGAAAAATAAGCAGGACA
CAATTACAACTAAAAAATATATCTAAGCATTTGCAAAGGCGACAATAAATTATTGACGCTTAACCTTTCC
AGTTTATAAGACTGGAATATAATTTCAAACCACACATTAGTACTTATGTTGCACAATGAGAAAAGAAATT
AGTTTCAAATTTACCTCAGCGTTTGTGTATCGGGCAAAAATCGTTTTGCCCGATTCCGTATTGGTATACT
TTTGCTTCAGTTGCATATCTTAAAACTAAATGTAATTTATTAACTAATCAAGAAAAACATCTTTGGCTGA
GCTCGGTGGCTCATGCCTGTAATCCCAACACTTTGAGAAGCTGAGGTGGGAGGAGTGCTTGAGGCCAGGA
GTTCAAGACCAGCCTGGGCAACATAGGGAGACCCCCATCTTTACAAAGAAAAAAAAAAGGGGAAAAGAAA
ATCTTTTAAATCTTTGGATTTGATCACTACAAGTATTATTTTACAAGTGAAATAAACATACCATTTTCTT
TTAGATTGTGTCATTAAATGGAATGAGGTCTCTTAGTACAGTTATTTTGATGCAGATAATTCCTTTTAGT
TTAGCTACTATTTTAGGGGATTTTTTTTAGAGGTAACTCACTATGAAATAGTTCTCCTTAATGCAAATAT
GTTGGTTCTGCTATAGTTCCATCCTGTTCAAAAGTCAGGATGAATATGAAGAGTGGTGTTTCCTTTTGAG
CAATTCTTCATCCTTAAGTCAGCATGATTATAAGAAAAATAGAACCCTCAGTGTAACTCTAATTCCTTTT
TACTATTCCAGTGTGATCTCTGAAATTAAATTACTTCAACTAAAAATTCAAATACTTTAAATCAGAAGAT
TTCATAGTTAATTTATTTTTTTTTTCAACAAAATGGTCATCCAAACTCAAACTTGAGAAAATATCTTGCT
TTCAAATTGGCACTGATTCTGCCTGCTTTATTTTTAGCGCTATCACAGGACCCAGAGCCTATGCCCTTTT
AAACTTACCACAAAAGCAGAAGATTAATTCAATTTAAGATGATACTCTCATTTGTTACGTCCTTTTTTTT
TTTTTTTGGAGATGGAGTCTTGCTTTGTCGCCCATGCTGGAGTGCAGTGGCATGATCCTGGCTCACTGCA
GCCTCCACTTCCCGGGTTCACGTAATTCTCCCACCTCAAGCCTCCCTAGTAGCTGGGATTACAGGGACGC
ACCACCATGCCCAGCTAATTTTTGCATTTTTAGTAGAGACTGGGTTTTACCATGTTGGCCAAGCTGGTCT
CAAACTCCTGATGTCAGGTGATCCATCTGCCTCAGCCTCCCAAAGTGCTGGGATTATAGGCGTGAGCCAC
TGTGCCCGGCCAATATTTGTTACTTTCTTAGGTTTAATAGAGAAAAGGGATAAAACATTTCTAACTGGGA
GTTAATTGCATGGAGAAGGTCTTAAATCAGATGTTTTAATGCCTTAAATGTCTGTATAATATCATGTTTT
CAAATCTAATTATAAATACGTTTAAAGCCAAGAATAAATCTTTTAAAAAATTGA
'''

BRCA2 = BRCA2.replace('\n', '').strip()
```

Φτιάξτε μία συνάρτηση η οποία δεν θα παιρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει την απάντηση σε αυτή την ερώτηση. Βάλτε όλο τον κώδικα για τη λύση αυτής της άσκησης σε αυτή τη συνάρτηση (εκτός από το DNA του BRCA2 !!).

### Άσκηση 63
Γράψτε ένα πρόγραμμα σε python. Ας υποθέσουμε ότι παίρνω αυτό το πρόγραμμα και το σώζω σε ένα αρχείο με τον όνομα `ask_63.py`. Από τη γραμμή εντολών θα πρέπει να μπορώ να γράφω:

```bash
python ask_63.py 6 4 5 7 8 9 8 6 4 1 2 3 5 
```
Και να τυπώνει το μικρότερο από τους αριθμούς της παραμέτρου. 

Επίσης μέσα από το jupyter θα πρέπει να μπορώ να γράφω:
```python
from ask_63 import get_minimum
m = get_minimum([6, 4, 5, 7, 8, 9, 8, 6, 4, 1, 2, 3, 5])
print (m) # Τυπώνει 1, που είναι και το μικρότερο στοιχείο της λίστας
```

Για αυτή την άσκηση στο μείλ που θα παραδώσετε βάλτε το περιεχόμενο του αρχείου `ask_63.py`.


### Άσκηση 64
Σύμφωνα με [τις οδηγίες της βάσης δεδομένων UniProt για το Entry Name](https://www.uniprot.org/help/entry_name):

The UniProtKB/Swiss-Prot entry name consists of up to 11 uppercase alphanumeric characters with a naming convention that can be symbolized as X_Y, where:

*    X is a mnemonic protein identification code of at most 5 alphanumeric characters;
*    The '\_' sign serves as a separator;
*    Y is a mnemonic species identification code of at most 5 alphanumeric characters.

Συμπληρώστε το regular expression της ακόλουθης συνάρτησης ώστε:
* Αν το `name` είναι σωστό entry name της Uniprot να επιστρέφει `True`.
* Διαφορετικά θα επιστρέφει `False`.  

```python
import re
def f(name):

    m = re.fullmatch(r'<ΒΑΛΤΕ ΕΔΩ ΤΟ Regular Expression>', name)
    return bool(m)

```

Δίνονται μερικά σωστά entry names: 
```
BRCA2_HUMAN
PALB2_HUMAN
BRCC3_BOVIN
BRCC3_RAT
BCCIP_MOUSE
```


### Άσκηση 65
Στη βάση δεδομένων UniProt μπορούμε να αναζητήσουμε ένα μέρος της ακολουθίας μία πρωτεΐνης ως εξής: `<Κωδικός_πρωτεΐνης>[<Αρχή ακολουθίας>-<Τέλος ακολουθίας>]`. Για παράδειγμα το `P00750[39-81]` δηλώνει ότι θέλουμε την ακολουθία της πρωτεΐνης `P00750` από το 39ο μέχρι το 81ο αμινοξύ. Θεωρούμε ότι ο κωδικός μίας πρωτεΐνης αρχίζει πάντα από `P` ακολουθούμενο από έναν αριθμό. Συμπληρώστε το regular expression της ακόλουθης συνάρτηση έτσι ώστε όταν εισάγουμε στην παράμετρο έναν κωδικό σαν αυτό που περιγράφηκε τότε η συνάρτηση να επιστρέφει ένα dictionary με τα ακόλουθα κλειδιά/τιμές:
* 'protein_id': Ο κωδικός της πρωτεΐνης (π.χ.: `P00750`)
* 'start': Η αρχή της ακολουθίας (π.χ. `39`)
* 'end': Το τέλος της ακολουθίας (π.χ. `81`)

```python
import re

def f(code):

    m = re.fullmatch(r'<ΒΑΛΤΕ ΕΔΩ ΤΟ Regular Expression>', code)
    if not m:
        raise Exception('Invalid code')
    return m.groupdict()

```

Δίνονται μερικά παραδείγματα:

```python
f('P00750[39-81]') # επιστρέφει:
{
    'protein_id': 'P00750',
    'start': '39',
    'end': '81'
}



f('E00750[39-81]') # Πετάει exception (invalid code)
f('PABC[39-81]') # Πετάει exception (invalid code)
f('P00750') # Πετάει exception (invalid code)
f('P00750[aa-100]') # Πετάει exception (invalid code)
```

Σημείωση: Το `[` και το `]` είναι ειδικοί χαρακτήρες και πρέπει να τα κάνετε escape (`\]`, `\[`).


### Άσκηση 66
Σε [αυτό το link](https://www.dropbox.com/s/166z1c527k575gi/vgnc_gene_set_All.txt?dl=1) μπορείτε να κατεβάσετε ένα CSV αρχείο με όλα τα γονίδια όλων των σπονδυλωτών οργανισμών ([πηγή](https://vertebrate.genenames.org/)). Η τρίτη στήλη του αρχείου περιέχει τον κωδικό του γονιδίου (π.χ. `BRCA2`). Συμπληρώστε το regular expression της παρακάτω συνάρτηση ώστε όταν την τρέχουμε να τυπώνει τα γονίδια τα οποία περιέχουν ακριβώς 2 αριθμούς στο όνομά τους. Κάθε αριθμός μπορεί να έχει παραπάνω από 1 ψηφία. Για παράδειγμα το γονίδιο: `COL13A1` περιέχει 2 αριθμούς (τον 13 και το 1), άρα θα πρέπει να το τυπώνει. Το γονίδιο `ATP6V0A4` περιέχει 3 αριθμούς (το 6 το 0 και το 4), άρα δεν πρέπει να το τυπώνει. Το γονίδιο `ABCB10` περιέχει 1 αριθμό (το 10) αρα δεν πρέπει να το τυπώνει

```python
import re

def f():
    with open('vgnc_gene_set_All.txt') as f:
        f.readline() # Η πρώτη γραμμή είναι η επικεφαλίδα
        
        for l in f:
            ls = l.split()
            symbol = ls[2] # Το σύμβολο του γονιδίου είναι η 3η στήλη
            
            m = re.search(r'<ΒΑΛΤΕ ΕΔΩ ΤΟ Regular Expression>', symbol)
            if m:
                print (symbol)
```

Παραδείγματα από γονίδια τα οποία πρέπει να τυπώνει:
```
ATP13A4
P3H2
PPP1R2C
```

### Άσκηση 67
Σε [αυτό το link](https://www.ncbi.nlm.nih.gov/books/NBK8808/#A197). Διαβάζουμε (edited):

> The name of a taxon between subclass and genus is formed by the addition of the appropriate suffix to the stem of the name of the type genus. These suffixes are as follows:

| Rank | Suffix | Example |
| --- | --- | --- |
| Order | _-ales_ | Pseudomonadales |
| Suborder | _-ineae_ | Pseudomonadineae |
| Family | _-aceae_ | Pseudomonadaceae |
| Subfamily | _-oideae_ | Pseudomonadoideae |
| Tribe | _-eae_ | Pseudomonadeae |
| Subtribe | _-inae_ | Pseudomonadinae |

Ας υποθέσουμε ότι έχουμε το παρακάτω dictionary το οποίο για keys περιέχει το Suffix και για values περιέχει to Rank:

```python
rank = {
 'ales': 'Order',
 'ineae': 'Suborder',
 'aceae': 'Family',
 'oideae': 'Subfamily',
 'eae': 'Tribe',
 'inae': 'Subtribe',
}
```

Συμπληρώστε το regular expression στη παρακάτω συνάρτηση ώστε όταν της δίνουμε στη παράμετρο το όνομα μίας ταξινόμησης να μας επιστρέφει το rank:

```python
def f(name):
    m = re.search(r'<ΒΑΛΤΕ ΕΔΩ ΤΟ Regular Expression>', name)
    if not m:
        raise Exception('Invalid name')
    return rank[m.group(0)]
```

Για παράδειγμα θα πρέπει:
```python
print (f('Pseudomonadales'))   # Τυπώνει: 'Order'
print (f('Pseudomonadineae'))  # Τυπώνει: 'Suborder'
print (f('Pseudomonadaceae'))  # Τυπώνει: 'Family'
print (f('Pseudomonadoideae')) # Τυπώνει: 'Subfamily'
print (f('Pseudomonadeae'))    # Τυπώνει: 'Tribe'
print (f('Pseudomonadinae'))   # Τυπώνει: 'Subtribe'
print (f('Kanterakis')) # Πετάει exception "invalid name"
```

### Άσκηση 68
Σε [αυτό το link](https://www.ncbi.nlm.nih.gov/Class/MLACourse/Original8Hour/Genetics/chrombanding.html) διαβάζουμε για την ονοματολογία των χρωμοσωμικών θέσεων στο ανθρώπινο γονιδίωμα:

Each human chromosome has a short arm ("p" for "petit") and long arm ("q" for "queue"), separated by a centromere. The ends of the chromosome are called telomeres.

Each chromosome arm is divided into regions, or cytogenetic bands, that can be seen using a microscope and special stains. The cytogenetic bands are labeled p1, p2, p3,   q1, q2, q3, etc., counting from the centromere out toward the telomeres. At higher resolutions, sub-bands can be seen within the bands. The sub-bands are also numbered from the centromere out toward the telomere.

For example, the cytogenetic map location of the CFTR gene is 7q31.2, which indicates it is on chromosome 7, q arm, band 3, sub-band 1, and sub-sub-band 2.

The ends of the chromosomes are labeled ptel and qtel. For example, the notation 7qtel refers to the end of the long arm of chromosome 7.

Συμπληρώστε λοιπόν το regular expression στη παρακάτω συνάρτηση έτσι ώστε:
* Αν η παράμετρος αποτελεί μία έγκυρη χρωμοσωμική θέση, θα πρέπει να επιστρέφει `True`.
* Διαφορετικά θα επιστρέφει `False`

```python
import re
def f(position):
   m = re.search(r'<ΒΑΛΤΕ ΕΔΩ ΤΟ Regular Expression>', position)
   return bool(m)
```

Παραδείγματα:
```python
f('7q') # Επιστρέφει True
f('7q31') # Επιστρέφει True
f('7q31.32') # Επιστρέφει True
f('7qtel') # Επιστρέφει True

f('7q31tel') # Επιστρέφει False
f('7s31') # Επιστρέφει False
f('7q31.32.33') # Επιστρέφει False
```

### Άσκηση 69
Σε [αυτό το link](http://hla.alleles.org/nomenclature/naming.html) διαβάζουμε για το.. κάπως πολύπλοκο τρόπο με τον οποίο κωδικοποιούνται οι μεταλλάξεις στη περιοχή [HLA](https://en.wikipedia.org/wiki/Human_leukocyte_antigen) του ανθρώπινου γονιδιώματος. Για να το κάνουμε πιο απλό εδώ θα πούμε ότι υπάρχουν 4 ειδών τρόποι για να ορίσουμε ένα σύνολο από γενετικές μεταλλάξεις (αλλήλια) σε αυτή τη περιοχή:


* `HLA-DRB1*13` :  a group of alleles that encode the DR13 antigen or sequence homology to other DRB1\*13 alleles
* `HLA-DRB1*13:01` : a specific HLA allele 
* `HLA-DRB1*13:01:02`  : an allele that differs by a synonymous mutation from DRB1\*13:01:01
* `HLA-DRB1*13:01:01:02` : an allele which contains a mutation outside the coding region from DRB1\*13:01:01:01 


Το σύνολο από τα γονίδια που βρίσκονται στη περιοχή HLA βρίσκεται [εδώ](http://hla.alleles.org/genes/index.html). Σε αυτή την άσκηση όμως θα θεωρήσουμε μόνο τα γονίδια: `HLA-A`, `HLA-B`, `HLA-C`, `HLA-DRB1`, `HLA-DQB1` και `HLA-DPB1` . Ο λόγος που το κάνουμε αυτό είναι ότι αυτά τα γονίδια έχει βρεθεί ότι παίζουν σημαντικό ρόλο στην ιστοσυμβατότητα κατά τη μεταμόσχευση οργάνων ([πηγή](https://en.wikipedia.org/wiki/Human_leukocyte_antigen#In_graft_rejection)). 

Συμπληρώστε λοιπόν το regular expression της παρακάτω συνάρτησης ώστε:
* Αν η παράμετρος περιέχει ένα σωστό HLA αλλήλιο σύμφωνα με τους 4 παραπάνω κανόνες και έχει ένα από τα 6 γονίδια που θεωρούμε σημαντικά στην ιστοσυμβατότα να επιστρέφει `True`.
* Διαφορετικά να επιστρέφει `False`.

```python
import re
def f(hla_allele):
    m = re.search(r'<ΒΑΛΤΕ ΕΔΩ ΤΟ Regular Expression>', hla_allele)
    return bool(m)
```

Μερικά παραδείγματα:
```python
f('HLA-DRB1*13') # Επιστρέφει True
f('HLA-A*13:01') # Επιστρέφει True
f('HLA-B*13:01:02') # Επιστρέφει True
f('HLA-DPB1*13:01:01:02') # Επιστρέφει True

f('HLA-DSB1*13') # Επιστρέφει False
f('HLA-A*') # Επιστρέφει False
f('B*13:01:02') # Επιστρέφει False
f('HLA-DPB1*13:01:01:02:03') # Επιστρέφει False

```

### Άσκηση 70 
Ένας από τους πολλούς τρόπους για να περιγράψουμε μία μετάλλαξη είναι η χρήση της HGVS ονομοταλογίας. Σύμφωνα με αυτή την ονοματολογία η μετάλλαξη `NM_012486.3:c.100G>A` συνέβει στο 100ο νουκλεοτίδιο της κωδικεύουσας θέσης του μετάγραφου `NM_012486.3`. Η μετάλλαξη είναι η αλλαγή του `G` σε `A`. Ένας απρόσεκτος ερευνητής έγραψε ένα σύνολο από μεταλλάξεις αλλά ξέχασε να βάλει το `c.`! Για παράδειγμα αντι να γράψει `NM_012486.3:c.100G>A` έγραψε: `NM_012486.3:100G>A`. 

Συμπληρώστε τη παρακάτω συνάρτηση έτσι ώστε να επιδιορθώνει το λάθος HGVS:

```python
import re

def correction(hgvs):

    return re.sub(r'<ΒΑΛΤΕ ΚΑΤΙ ΕΔΩ>', r'ΚΑΙ ΚΑΤΙ ΕΔΩ', hgvs)

```

Θα πρέπει:
```python
f('NM_012486.3:100G>A') # Επιστρέφει: NM_012486.3:c.100G>A
f('NM_001297605.2:50A>G') # Επιστρέφει: NM_001297605.2:c.50A>G
```

### Άσκηση 71 

Συμπληρώστε τη παρακάτω συνάρτηση έτσι ώστε όταν την καλούμε να εμφανίζει ένα barplot. Κάθε μπάρα θα δείχνει το πλήθος απο γραμμές που έχει το γνωστό μας αρχείο [gene_condition_source_id](https://ftp.ncbi.nlm.nih.gov/pub/clinvar/gene_condition_source_id) για όλες τις διαφορετικές τιμές της στήλης `SourceName`.

```python
import pandas as pd
def f():
    df = pd.read_csv('https://ftp.ncbi.nlm.nih.gov/pub/clinvar/gene_condition_source_id', sep='\t')
    df.<ΣΥΜΠΛΗΡΩΣΤΕ ΕΔΩ> 
```

Δίνεται εδώ το plot που έβγαλε σε εμένα:
![img](https://i.imgur.com/iT7ueRo.png)


### Άσκηση 72

Συμπληρώστε τη παρακάτω συνάρτηση έτσι ώστε όταν την καλούμε να επιστρέφει ένα Series το οποία θα περιέχει το πλήθος από διαφορετικά γονίδια της στήλης `AssociatedGenes` που υπάρχουν για κάθε διαφορετική τιμή της στήλης `SourceName`.

```python
import pandas as pd
def f():
    df = pd.read_csv('https://ftp.ncbi.nlm.nih.gov/pub/clinvar/gene_condition_source_id', sep='\t')
    return df.<ΣΥΜΠΛΗΡΩΣΤΕ ΕΔΩ> 
```

Δίνεται ο πίνακας που θα πρέπει να επιστρέφει:
```
SourceName
GeneReviews                    7
Human Phenotype Ontology     238
MONDO                       4228
NCBI curation                187
OMIM                         138
OMIM phenotypic series        64
Orphanet                      92
Name: AssociatedGenes, dtype: int64
```

### Άσκηση 73 
Αν φορτώσουμε το αγαπημένο μας αρχείο [gene_condition_source_id](https://ftp.ncbi.nlm.nih.gov/pub/clinvar/gene_condition_source_id) σε ένα pandas DataFrame και ελέγξουμε τη στήλη `LastUpdated`, θα δούμε (με τρόμο), ότι κάποιες ημερομηνίες έχουν γραφτεί ως εξής: Μήνας Μέρα Χρονιά (π.χ. `Feb 16 2016`) και άλλες έχουν γραφεί ως εξής: Μέρα Μήνας Χρονιά (π.χ. `16 Feb 2016`). Φτιάξτε μία συνάρτηση με το όνομα `correct_date` η οποία θα είναι τέτοια ώστε η παρακάτω συνάρτηση να επιστρέφει ένα DataFrame όπου θα υπάρχει μία επιπλέον στήλη με το όνομα `LastUpdated_corrected`, τέτοια ώστε όλες οι ημερομηνίες να έχουν τη μορφή Μέρα Μήνας Χρονιά (π.χ. `16 Feb 2016`). Προαιρετικά μπορείτε να εφαρμόσεται και τη συνάρτηση [to_datetime](https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html) έτσι ώστε η στήλη να μην είναι τύπου string αλλά τύπου date. 

```python
import pandas as pd
def f():
    df = pd.read_csv('https://ftp.ncbi.nlm.nih.gov/pub/clinvar/gene_condition_source_id', sep='\t')
    df['LastUpdated_corrected'] = df.apply(correct_date, axis=1)

    return df
```

### Άσκηση 74
Χρησιμοποιώντας το αγαπημένο μας αρχείο [gene_condition_source_id](https://ftp.ncbi.nlm.nih.gov/pub/clinvar/gene_condition_source_id), φτιάξτε μία συνάρτηση η οποία θα φτιάχνει ένα DataFrame το οποίο θα περιέχει μόνο τις γραμμές που η στήλη `SourceName` έχει τη τιμή `MONDO`. Στη συνέχεια θα επιστρέφει ένα DataFrame το οποίο θα περιέχει  το πλήθος από γραμμές που υπάρχουν για κάθε διαφορετικό χρόνο της στήλης `LastUpdated`. Η στήλη που θα περιέχει τα πλήθη πρέπει να λέγεται `counts`. Δίνεται το DataFrame που έφτιαξε η δική μου συνάρτηση:

![img](https://i.imgur.com/h4pghdc.png)

Σημείωση: [Εδώ](https://stackoverflow.com/questions/19078325/naming-returned-columns-in-pandas-aggregate-function) μπορείτε να βρείτε οδηγίες για το πως μπορείτε να δώσετε ένα όνομα σε μία στήλη του grouping.


### Άσκηση 75
Υλοποιήστε την άσκηση 43, έτσι ώστε αντί για dictionary να επιστρέφει ένα DataFrame. 

Δηλαδή θα πρέπει:


![img](https://i.imgur.com/Zr8Fhd3.png)To

### Άσκηση 76
Χρησιμοποιώντας το αγαπημένο μας αρχείο [gene_condition_source_id](https://ftp.ncbi.nlm.nih.gov/pub/clinvar/gene_condition_source_id), φτιάξτε μία συνάρτηση η οποία θα:
* Φορτώνει το αρχείο σε ένα dataframe
* Θα προσθέτει μία νέα στήλη με το όνομα `SourceName_2` η οποία:
   * Αν η στήλη `SourceName` της γραμμής περιέχει το string `OMIM` τότε η τιμή της στήλης θα είναι `ΟΜΙΜ`
   * Διαφορετικά θα περιέχει τη τιμή της στήλης `SourceName`
* Θα πρσθέτει μία νέα στήλη με το όνομα `year` η οποία θα περιέχει τη χρονιά που έγινε update η κάθε γραμμή με βάση τη τιμή της στήλης: `LastUpdated` (δες και άσκηση 74)
* Θα κρατάει μόνο τις γραμμές που η στήλη `SourceName_2` δεν είναι `MONDO`
* Θα κρατάει μόνο τις γραμμές που η στήλη `year` δεν είναι 2016
* Θα κάνει group με βάση τις στήλες `SourceName_2` και `year` 
* Για κάθε group θα μετράει το πλήθος των γραμμών που περιέχει το κάθε group. (aggregate με βάση το `count`)
* Θα παράγει ένα barplot `(kind='bar')` με το αποτέλεσμα. 

Το αποτέλεσμα που παρήγαγε σε μένα είναι:
![img](https://i.imgur.com/eFLjqKA.png)

Σημείωση: δείτε στις σημειώσεις για το "unstacking"

### Άσκηση 77
To [1000 Genomes Project](https://www.internationalgenome.org/) ([wikipedia](https://en.wikipedia.org/wiki/1000_Genomes_Project)) ήταν ένα πρωτοποριακό project το οποίο έκανε πλήρη αλληλούχιση σε 3500 ανθρώπους από διάφορα μέρη του πλανήτη. Με τον παρακάτω κώδικα μπορείτε να φτιάξετε ένα dataframe το οποίο περιέχει πληροφορίες για αυτούς τους ανθρώπους. 

```python
import pandas as pd

def f():
    df = pd.read_excel('ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/technical/working/20130606_sample_info/20130606_sample_info.xlsx')
    return df
```

2 από τις βασικές στήλες που περιέχει αυτό το dataframe είναι:
* `Population`: ένα string μεγέθους 3 χαρακτήρες το οποίο είναι ο κωδικός του πληθυσμού. Για παράδειγμα `GBR` σημαίνει ότι το δείγμα έχει καταγωγή: "British in England and Scotland", ενώ `GIH` σημαίνει ότι το δείγμα έχει καταγωγή: `Gujarati Indian in Houston,TX`
* `Gender`: παίρνει δύο δυνατές τιμές: `male` και `female`

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει ένα string τριών χαρακτήρων το οποίο θα είναι η απάντηση στην ερώτηση: Ποιος κωδικός πληθυσμού έχει το μεγαλύτερο ποσοστό γυναικών; Για παράδειγμα ο πληθυσμός `ACB` έχει 61 γυναίκες και 62 άντρες. Άρα το ποσοστό των γυναικών στον πληθυσμό `ACB` είναι: 61/(61+62)=0.496 ή 49.6%. Ποιος είναι ο πληθυσμός με το μεγαλύτερο ποσοστό γυναικών;

Δίνεται η απάντηση: `FIN`

* Απαγορεύεται να χρησιμοποιήσετε for, while, if. Επιτρέπονται μόνο συναρτήσεις της pandas.
* Hints: groupby, unstack, idxmax

### Άσκηση 78
Η παρακάτω συνάρτηση:

```python
def f():
    '''
    Κατεβάζει ένα αρχείο το οποίο είναι σε bed format με τη μορφή DataFrame
    Τα ονόματα των στηλών του bed αρχείου τα έχω πάρει από εδώ:
    https://genome.ucsc.edu/FAQ/FAQformat.html#format1
    '''

    df = pd.read_csv(
        'https://lncipedia.org/downloads/lncipedia_5_2/full-database/lncipedia_5_2_hg38.bed', 
        sep='\t',
        header=None,
        names=['chrom', 'chromStart', 'chromEnd', 'name', 'score', 'strand', 'thickStart', 'thickEnd',
           'itemRgb', 'blockCount', 'blockSizes', 'blockStarts'],
    )
    return df
```

Επιστρέφει ένα DataFrame με όλα τα [long non-coding RNAs](https://en.wikipedia.org/wiki/Long_non-coding_RNA) (ή αλλιώς lncRNAs). H πηγή των δεδομένων είναι από τη βάση δεδομένων [LNCipedia](https://lncipedia.org/download). 

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση:
* Θα φορτώνει το DataFrame
* Θα προσθέτει μία νέα στήλη η οποία θα περιέχει το μέγεθος του κάθε lncRNA. Το μέγεθος ορίζεται ως η διαφορά της τιμής της στήλης `chromEnd` με τη τιμή της στήλης `chromStart`.
* Θα υπολογίζει το άθροισμα των μεγεθών όλων των lncRNAs για κάθε χρωμόσωμα (στήλη `chrom`)
* Θα τα ταξινομεί από το μεγαλύτερο (χρωμόσωμα) μέχρι το μικρότερο (hint: [sort_values(ascending=False)](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_values.html))
* Φτιάχνει ένα barplot με το αποτέλεσμα. 

Η συνάρτηση δεν θα επιστρέφει τίποτα. 
Δίνεται το plot το οποίο βγήκε σε εμένα:

![img](https://i.imgur.com/OhLYM0V.png)

* Απαγορεύεται να χρησιμοποιήσετε for, while, if. Επιτρέπονται μόνο συναρτήσεις της pandas.

### Άσκηση 79
Ο σκοπός αυτής της άσκησης είναι να φτιάξετε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα φτιάχνει ένα plot με τη χωρητικότητα των μεγαλύτερων σταδίων του κόσμου. To plot που θα πρέπει να φτιάξετε θα είναι σαν αυτό:

![img](https://i.imgur.com/rPODsTh.png)


Οπότε η συνάρτησή σας θα πρέπει:

* Να χρησιμοποιεί τη `read_html` για να πάρει όλους τους πίνακες της σελίδας: https://en.wikipedia.org/wiki/List_of_stadiums_by_capacity με τη μορφή DataFrames. 
* Για το plot θα κρατήσετε τους 2 πρώτους πίνακες. Ο πρώτος περιέχει τα στάδια με χωρητικότητα 100.000 ή παραπάνω και ο 2ος τα στάδια με χωριτικότητα 90,000–100,000. 
* Θα πρέπει να επεξεργατείτε τη στήλη `Capacity` ώστε να περιέχει ακέραιες τιμές. Για παράδειγμα θα πρέπει η τιμή `132,000[2][3]` να γίνει `132000`. Χρησιμοποιήστε είτε τη συνάρτηση [apply](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.apply.html) ή τη [map](https://pandas.pydata.org/docs/reference/api/pandas.Series.map.html) για να γίνει αυτό (hint, εδώ βολεύουν πολύ τα regular expressions). 
* Θα πρέπει να εννώσετε τα 2 DataFrames σε ένα. Αυτό γίνεται με τη συνάρτηση [concat](https://pandas.pydata.org/docs/reference/api/pandas.concat.html). Π.χ: `pd.concat([df1, df2, ignore_index=True)`
* Στη συνέχεια θα πρέπει να κάνετε sort το DataFrame από το μεγαλύτερο στο μικρότερο με βάση τη στήλη `Capacity`.
* Μετά θα πρέπει να κάνετε ένα vertical barplot (`kind='barh'`), όπου το x θα είναι η στήλη `Stadium` και y θα είναι η στήλη `Capacity`
* Θα πρέπει να φροντίσετε ώστε το χρώμα της κάθε μπάρας να είναι διαφορετικό ανάλογα με την ήπειρο που βρίσκεται το στάδιο (στήλη: `Region`). Για να το κάνετε αυτό μπορείτε να φτιάξετε μια επιπλέον στήλη στο DataFrame το οποίο να έχει το όνομα του χρώματος (π.χ. 'red', 'yellow', ...) για κάθε γραμμή ανάλογα με τη τιμή της στήλης `Region`. Εγώ χρησιμοποιήσα αυτά τα τυχαία χρώματα, αλλά εσείς μπορείτε να διαλέξετε τα δικά σας:

```python
c = {
    'South Asia': 'green',
    'East Asia': 'red',
    'North America': 'blue',
    'Europe': 'pink',
    'Africa': 'yellow',
    'Oceania': 'black',
    
}
```

* Αν υποθέσουμε ότι η νέα στήλη με τα χρώματα ονομάζεται `region_colors` τότε μπορείτε να δηλώσετε στην εντολή plot να χρησιμοποιήσει αυτά τα χρώματα ως εξής: `.plot(... , color=df['region_colors'])`


### Άσκηση 80
H παρακάτω συνάρτηση επιστρέφει ένα DataFrame με τον πίνακα [Table 1](https://www.nature.com/articles/s41588-022-01034-x/tables/1) της δημοσίευσης [Exome sequencing in bipolar disorder identifies AKAP11 as a risk gene shared with schizophrenia](https://www.nature.com/articles/s41588-022-01034-x). 

```python
def f():
    dfs=pd.read_html('https://www.nature.com/articles/s41588-022-01034-x/tables/1', encoding='utf8')
    return dfs[0]
```

Αν εμφανίσουμε αυτό το DataFrame παρατηρούμε ότι οι στήλες ανήκουν σε ομάδες. Υπάρχει η ομάδα `BD (BipEx)` η οποία περιέχει τη στήλη `P value` και η ομάδα `Schizophrenia (SCHEMA)` η οποία επίσης περιέχει τη στήλη `P value`.

Μποροούμε να προσπελάσουμε αυτές τις στήλες ως εξής:
```python
df = f()

df['BD (BipEx)']['P value']

# και:
df['Schizophrenia (SCHEMA)']['P value']
```

Παρατηρούμε επίσης ότι οι τιμές των στηλών είναι της μορφής: `1.15 × 10−5`. Δίνεται η παρακάτω συνάρτηση η οποία μετατρέπει αυτές τις τιμές σε `float`:

```python
import re
def convert(s):
    s = re.search(r'(\d+\.\d+) × 10\−(\d+)', s)
    return float(s.group(1)) * 10**(-int(s.group(2)))

# Για παράδειγμα:
print (convert('2.02 × 10−5')) # Τυπώνει: 2.0200000000000003e-05 

```


Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα φτιάχνει ένα scatter plot. Στον x άξονα θα είναι οι τιμές της στήλης `P value` της "οικογένειας" `BD (BipEx)` και στον άξονα y θα είναι οι τιμές της στήλης `P value` της "οικογένειας" `Schizophrenia (SCHEMA)`.

Για τη δική μου υλοποίηση έφτιαξα δύο διαφορετικές στήλες για τη κάθε `P value` στήλη. Η μία είχε το όνομα `P value_1` και η άλλη το όνομα `P value_2`. Το.. απλοϊκό scatter plot που βγήκε είναι:

![img](https://i.imgur.com/WU8EKts.png)

Σημείωση: αυτή η άσκηση δείχνει ένα παράδειγμα με το οποίο μπορούμε να κατεβάσουμε δεδομένα απευθείας από papers και να τα επεξεργαστούμε.

### Άσκηση 81 
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα πρέπει να εμφανίζει ένα γράφημα το οποίο θα έχει τη μορφή "Α". Δηλαδή θα αποτελείται από 3 γραμμές οι οποίες θα σχηματίζουν το γράμματα Α.

Δίνεται ένα παράδειγμα:
![img](https://i.imgur.com/qBpFGSB.png)

Σημείωση: Είναι υποχρεωτικό να χρησιμοποιήσετε matplotlib και τη συνάρτηση ax.plot


### Άσκηση 82 
Φτιάξτε μία συνάρτηση με το όνομα f_82_a η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα κάνει plot τη συνάρτηση f(x)=1/sin(x) για Χ από -1 έως 1 με 100 συνολικά βήματα.

Φτιάξτε μία συνάρτηση με το όνομα f_82_b η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα κάνει plot τη συνάρτηση f(x)=1/sin(x) για Χ από -0.01 έως 0.01 με 10000 συνολικά βήματα.

Hint: Χρησιμοποιήστε τη linspace:
```python
import nympy as np
X = np.linspace(-1, 1, 100) # Ένας πίνακας από το -1 έως το 1 με 100 βήματα
```

Σημείωση 1: Είναι υποχρεωτικό να χρησιμοποιήσετε matplotlib και τη συνάρτηση ax.plot
Σημείωση 2: Η συνάρτηση np.sin υπολογίζει το ημίτονο.
Σημείωση 3: Σχετικά με το `import numpy as np`, [αυτός είναι ο προτεινόμενος τρόπος για να κάνουμε import της numpy](https://numpy.org/doc/stable/user/absolute_beginners.html#how-to-import-numpy). 

### Άσκηση 83 

Η παρακάτω λίστα περιέχει το πλήθος από κρούσματα COVID-19 τα οποία έχουν αναφερθεί στην Ελλάδα από την αρχή της πανδημίας για κάθε μέρα από τις 22 Ιανουαρίου 2020 μέχρι 25 Μαΐου 2022  ([πηγή](https://github.com/CSSEGISandData/COVID-19/blob/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv)).  

```python
greece_covid_cases = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,4,4,7,7,7,9,31,45,46,73,73,89,99,99,190,228,331,331,387,418,418,495,530,624,695,743,835,835,835,835,1156,1156,1156,1156,1156,1613,1673,1735,1755,1832,1884,1955,2009,2081,2081,2145,2170,2192,2207,2224,2235,2245,2245,2401,2408,2463,2490,2506,2517,2534,2566,2576,2591,2612,2620,2626,2632,2642,2663,2678,2691,2710,2716,2726,2744,2760,2770,2810,2819,2834,2836,2840,2850,2853,2873,2876,2878,2882,2889,2903,2906,2909,2915,2917,2918,2937,2952,2952,3049,3049,3049,3049,3058,3068,3088,3108,3112,3121,3134,3148,3203,3227,3237,3256,3266,3287,3302,3310,3321,3343,3366,3376,3390,3409,3432,3458,3486,3511,3519,3562,3589,3622,3672,3732,3772,3803,3826,3883,3910,3939,3964,3983,4007,4012,4048,4077,4110,4135,4166,4193,4227,4279,4336,4401,4477,4587,4662,4737,4855,4973,5123,5270,5421,5623,5749,5942,6177,6381,6632,6858,7075,7222,7472,7684,7934,8138,8381,8664,8819,8987,8987,9531,9800,9977,10134,10317,10524,10757,10998,11200,11386,11524,11663,11832,12080,12452,12734,13036,13240,13420,13730,14041,14400,14738,14978,15142,15595,15928,16286,16627,16913,17228,17444,17707,18123,18475,18886,19346,19613,19842,20142,20541,20947,21381,21772,22078,22358,22652,23060,23495,23947,24450,24932,25370,25802,26469,27334,28216,29057,29992,30782,31496,32752,34299,35510,37196,39251,40929,42080,44246,46892,49807,52254,54809,56698,58187,60570,63321,66637,69675,72510,74205,76403,78825,82034,85261,87812,90121,91619,93006,95137,97288,99306,101287,103034,104227,105271,107470,109655,111537,113185,114568,115471,116721,118045,119720,121253,122648,123842,124534,125173,126372,127557,128710,129584,130485,131072,131597,132430,133365,134235,134852,135114,135456,135931,136976,137918,138850,139447,139709,140099,140526,141453,142267,142777,143494,144293,144738,145179,146020,146688,147283,147860,148370,148607,148925,149462,149973,150479,151041,151646,151980,152412,153226,154083,154796,155678,156473,156957,157495,158716,159866,160935,162107,163213,163946,164575,166067,167549,168872,170244,171466,172128,172824,173905,174659,176059,177494,178918,179802,180672,182783,184686,186469,188201,189831,191100,192270,194582,197279,199496,201677,203978,205120,206281,209462,212091,214661,217018,219521,221147,222281,223789,227247,230317,233079,235611,237125,238830,242347,245405,247992,249458,252590,254031,255755,260077,263689,267172,270230,273459,275414,277277,281570,285015,288230,290964,293763,295480,297086,301103,304184,308006,311033,313444,315273,316879,320629,323639,326395,329134,331730,333129,334436,337723,340493,342908,345033,346422,346422,348568,349936,352027,355445,358116,360577,362004,363904,367076,369554,371693,373881,375831,377090,378485,381266,383558,385444,387426,388929,389804,391181,393583,395094,396970,398898,400395,401301,402306,404163,405542,406751,407857,408789,409368,410166,411534,412420,413170,413954,414636,414933,415401,416195,416741,417253,417706,418095,418342,418548,418943,419455,419909,420295,420670,420905,421266,421829,422456,423185,424165,425347,425964,426963,429144,430960,433021,435018,437345,438809,440872,444783,447718,450512,453200,455754,457312,459146,463473,466441,469042,471894,474366,475919,477975,482145,485015,487709,490552,493304,494907,497061,501030,503885,506672,509596,512342,514192,516785,521399,524871,528474,531967,535237,537125,539337,543749,547186,550459,554055,557239,559186,561812,566812,570077,573605,576672,579734,581315,583658,587964,590832,593668,596383,598667,599951,601716,605158,607356,609519,611648,613838,615157,616765,620355,622761,625083,627314,629498,630784,632908,636596,638921,641022,643055,644869,645969,648091,651378,653535,655767,658368,660166,661308,663433,666517,668811,671040,673317,675479,676799,679157,682394,684706,687278,689896,692197,693886,697033,700959,704211,707587,711128,714283,716358,720295,724571,728210,731167,734778,739448,742170,747595,754451,760592,767376,774265,780621,784904,792239,801208,808297,815068,821900,828032,831874,838824,847188,853841,861117,868868,874812,878920,886207,894555,901661,908222,914824,920683,924506,931183,938903,945095,951351,957552,962695,966221,971148,978402,984301,989814,994901,999652,1002877,1006706,1012659,1017445,1022141,1026902,1031239,1034070,1037759,1044301,1049936,1056583,1064243,1070833,1074869,1084153,1105885,1134713,1170293,1210853,1240862,1258495,1294741,1344923,1388309,1422020,1451354,1489024,1507616,1535382,1568215,1592460,1612869,1632641,1650088,1660871,1679705,1703396,1723496,1742363,1762870,1781203,1793311,1812384,1830263,1848223,1867935,1890296,1909880,1920992,1940723,1965719,1984544,2002206,2020846,2036869,2047849,2066696,2090383,2109999,2129153,2146798,2163240,2174093,2194453,2216411,2235920,2255421,2274025,2289330,2298926,2317014,2336615,2353577,2369396,2385304,2397187,2405401,2421664,2438872,2454429,2470212,2486262,2499259,2508472,2517111,2538168,2561503,2583366,2604626,2623628,2635614,2658296,2684916,2708610,2732866,2756487,2776192,2788654,2812182,2838891,2861993,2884100,2900334,2916892,2930321,2957810,2986882,3009333,3030429,3051531,3067354,3077711,3096135,3114591,3126856,3137714,3152477,3164995,3173630,3180556,3195887,3206948,3216256,3224479,3232496,3238169,3242037,3252248,3259613,3266368,3273382,3277557,3277557,3285970,3290895,3302382,3309962,3317425,3323922,3328623,3331288,3335550,3343565,3348756,3353886,3358584,3361779,3364598,3371051,3375812,3380594,3384982,3389306,3392575,3395641,3401927,3406553,3410481,3414189,3417613,3419998,3422233,3427857,3431998]
```

Η παρακάτω λίστα περιέχει το πλήθος από θανάτους λόγω COVID-19 που έχουν αναφερθεί στην Ελλάδα από την αρχή της πανδημίας για κάθε μέρα από τις 22 Ιανουαρίου 2002 μέχρι το 25 Μαΐου 2022 ([πηγή](https://github.com/CSSEGISandData/COVID-19/blob/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv))

```python
greece_covid_deaths = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,3,4,4,5,5,6,8,13,15,17,20,22,22,22,22,38,38,38,38,38,59,68,73,79,81,83,86,90,93,93,99,101,102,105,108,110,116,116,121,121,125,130,130,134,136,138,139,140,140,143,144,146,146,147,148,150,151,151,151,152,155,156,160,162,163,165,165,166,168,169,171,171,172,173,173,175,175,175,175,179,179,180,180,182,182,182,182,183,183,183,183,183,183,184,185,187,188,189,190,190,190,190,190,191,191,191,191,191,192,192,192,192,192,192,192,193,193,193,193,193,193,193,193,193,193,194,194,194,195,197,200,201,201,201,202,202,203,203,203,206,206,208,209,209,210,210,210,211,212,213,214,216,221,223,226,228,230,232,235,235,238,240,242,242,243,243,254,259,260,262,266,271,273,278,279,280,284,289,290,293,297,300,302,305,310,313,316,325,327,331,338,344,352,357,366,369,376,379,383,388,391,393,398,405,409,417,420,424,430,431,436,449,456,462,469,482,490,500,509,520,528,534,549,559,564,574,581,593,603,615,620,626,635,642,655,673,702,715,749,784,825,866,909,959,997,1035,1106,1165,1228,1288,1347,1419,1527,1630,1714,1815,1902,2001,2102,2223,2321,2406,2517,2606,2706,2804,2902,3003,3092,3194,3289,3370,3472,3540,3625,3687,3785,3870,3948,4044,4102,4172,4257,4340,4402,4457,4507,4553,4606,4672,4730,4788,4838,4881,4921,4957,5011,5051,5099,5146,5195,5227,5263,5302,5329,5354,5387,5421,5441,5469,5488,5518,5545,5570,5598,5622,5646,5671,5692,5724,5742,5764,5779,5796,5829,5851,5878,5903,5922,5951,5972,5997,6017,6034,6056,6077,6103,6126,6152,6181,6194,6221,6249,6272,6297,6321,6343,6371,6410,6439,6468,6504,6534,6557,6597,6632,6664,6705,6758,6797,6843,6886,6937,6986,7038,7091,7137,7196,7252,7297,7361,7421,7462,7531,7582,7649,7701,7754,7826,7880,7945,8017,8093,8160,8232,8302,8380,8453,8532,8607,8680,8758,8833,8885,8961,9054,9135,9239,9330,9397,9462,9540,9627,9713,9788,9864,9950,10007,10087,10179,10242,10315,10381,10453,10453,10587,10668,10764,10847,10910,10978,11029,11089,11141,11211,11266,11322,11365,11415,11471,11534,11587,11641,11697,11734,11772,11822,11872,11916,11955,11995,12024,12054,12095,12122,12145,12184,12218,12253,12277,12301,12331,12346,12370,12381,12405,12422,12443,12465,12478,12494,12514,12534,12548,12565,12581,12595,12613,12634,12646,12664,12682,12695,12706,12710,12722,12731,12737,12743,12754,12763,12773,12785,12787,12792,12802,12806,12813,12819,12833,12840,12850,12858,12867,12870,12875,12882,12890,12898,12903,12911,12926,12935,12948,12965,12975,12983,12997,13013,13026,13048,13058,13075,13097,13118,13138,13158,13182,13206,13223,13237,13253,13278,13298,13328,13351,13384,13422,13466,13509,13539,13561,13599,13636,13656,13691,13743,13777,13813,13843,13886,13933,13971,14014,14060,14102,14141,14169,14223,14268,14311,14354,14394,14433,14466,14505,14548,14575,14606,14639,14655,14679,14727,14751,14795,14828,14860,14889,14920,14956,14991,15012,15042,15069,15105,15135,15177,15210,15241,15289,15317,15348,15375,15418,15447,15485,15519,15555,15598,15628,15682,15707,15770,15801,15856,15894,15938,15990,16050,16109,16151,16200,16243,16295,16361,16414,16493,16560,16616,16686,16766,16838,16923,17012,17075,17168,17237,17313,17425,17517,17612,17693,17779,17861,17959,18067,18157,18234,18325,18427,18516,18595,18716,18815,18901,18982,19085,19157,19248,19345,19475,19553,19651,19736,19799,19891,19976,20055,20126,20198,20292,20350,20429,20496,20557,20636,20708,20790,20849,20910,20990,21053,21115,21185,21263,21328,21394,21479,21559,21637,21732,21809,21888,21984,22087,22197,22285,22366,22476,22549,22635,22748,22852,22970,23083,23195,23275,23372,23500,23608,23721,23833,23927,23999,24094,24210,24322,24410,24507,24609,24679,24754,24836,24917,25001,25095,25183,25260,25327,25417,25485,25538,25603,25668,25719,25785,25860,25914,25972,26036,26092,26143,26194,26246,26303,26366,26424,26473,26513,26562,26635,26686,26730,26792,26847,26893,26937,26995,27029,27083,27125,27160,27216,27268,27341,27392,27454,27510,27571,27623,27684,27746,27816,27892,27968,28025,28076,28130,28205,28274,28344,28406,28488,28537,28588,28652,28701,28765,28808,28839,28867,28867,28933,28976,29022,29073,29114,29153,29175,29205,29249,29284,29315,29349,29369,29392,29417,29444,29471,29491,29521,29536,29547,29576,29599,29619,29642,29658,29679,29690,29711,29725,29743]
```


Φτιάξτε μία συνάρτηση η οποία θα φτιάχνει ένα plot.
* στον Χ άξονα θα είναι αριθμοί από το 0 μέχρι το πλήθος των ημερών που έχουν οι λίστες `greece_covid_cases` και `greece_covid_deaths`. 
* Στον αριστερό Y άξονα θα είναι οι τιμές της λίστας `greece_covid_cases` με μπλε χρώμα.
* Στον δεξί Υ άξονα θα είναι οι τιμές τις λίστας `greece_covid_deaths` με κόκκινο χρώμα. 

Δίνεται το plot που βγήκε σε μένα (ξέχασα να βάλω xlabels και ylabels, please βάλτε εσείς):

![img](https://i.imgur.com/Yxl5y3J.png)

Hint: `ax.twinx()`

### Άσκηση 84 
Δίνεται η παρακάτω συνάρτηση:

```python
import datetime

def get_date(days):

    start = datetime.datetime(2020, 1, 22)
    new_date = start + datetime.timedelta(days=days)
    return new_date.strftime('%d/%m/%Y')
```

Η συνάρτηση αυτή παίρνει μία παράμετρο (`days`) και επιστρέφει ένα string το οποίο είναι η ημερομηνία μετά από `days` μέρες από τις 22 Ιανουαρίου 2020. Για παράδειγμα η ημερομηνία μετά από 100 μέρες από τις 22 Ιανουαρίου 2020 είναι:
```python
print (get_date(100)) # Επιστρέφει: "01/05/2020"
``` 

Χρησιμοποιώντας τη συνάρτηση `get_date` αλλάξτε τη συνάρτηση της άσκησης 83 έτσι ώστε τα tick labels του γραφήματος να είναι ημερομηνίες. Τα tick labels θα πρέπει να έχουν τυπωθεί κάθετα. Δίνεται το γράφημα όπως βγήκε σε μένα (ξέχασα να βάλω xlabels και ylabels, please βάλτε εσείς):

![img](https://i.imgur.com/2iX1awM.png)

### Άσκηση 85 
Φτίαξτε μία συνάρτηση η οποία θα κάνει το ίδιο plot με την άσκηση 83 με τη διαφορά ότι θα κάνει 2 subplots, ένα πάνω και ένα κάτω. Στο πάνω θα είναι οι τιμές της λίστας `greece_covid_cases`  με μπλε και στο κάτω θα είναι οι τιμές τις λίστας `greece_covid_deaths` με κόκκινο. Στο πάνω plot θα υπάρχει το ylabel: `Cases`, το κάτω plot θα υπάρχει το ylabel: `Deaths`  και στον x θα υπάρχει το xlabel `Days since 22/1/2022`

Δίνεται το plot όπως βγήκε σε μένα:

![img](https://i.imgur.com/wt3W663.png)

### Άσκηση 86

Φτίαξτε μία συνάρτηση η οποία θα κάνει το ίδιο plot με την άσκηση 83 με τη διαφορά ότι θα φτιάχνει ένα plot μέσα σε ένα άλλο plot. Στο "έξω" plot θα είναι οι τιμές της λίστας `greece_covid_cases`  με μπλε και στο "μέσα" θα είναι οι τιμές τις λίστας `greece_covid_deaths` με κόκκινο. Μπορείτε να τοποθετήσετε το μέσα plot σε όποιο σημείο νομίζετε ότι είναι καλύτερα σε σχέση με το έξω plot. Προαιρετικά προσθέστε labels.

Δίνεται το plot όπως βγήκε σε μένα:

![img](https://i.imgur.com/rfu71lF.png)


### Άσκηση 87 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 4 παραμέτρους a1, b1, a2, b2. Η συνάρτηση θα πρέπει:

* Να υπολογίζει το σημείο τομής των ευθειών: Y = a1\*X + b1 και Υ = a2\*X + b2. Δίνεται ότι το σημείο αυτό έχει Χ<sub>t</sub> = (b1-b2)/(a2-a1) και Υ<sub>t</sub>=a1\*X<sub>t</sub> + b1
* Να κάνει ένα plot της 1ης ευθείας (Υ = a1\*x+b1) από το Χ<sub>t</sub>-10 μέχρι το Χ<sub>t</sub>+10 σε χρώμα μπλε
* Να κάνει ένα plot της 2ης ευθείας (Υ = a2\*x+b2) από το Χ<sub>t</sub>-10 μέχρι το Χ<sub>t</sub>+10 σε χρώμα κόκκινο
* Να εμφανίζει μία πράσινη κουκίδα στο σημείο τομής.

Δίνεται ένα παράδειγμα:

```python
f(3, -1, 1.5, 10)
# Εμφανίζει:
```


![img](https://i.imgur.com/yovUQne.png)



### Άσκηση 88 
Προσθέστε στην άσκηση 86 ένα legend όπου θα φαίνονται οι εξισώσεις των ευθειών. Για παράδειγμα θα πρέπει:

```python
f(3, -1, 1.5, 10)
# Εμφανίζει:
```


![img](https://i.imgur.com/yOYl3py.png)

### Άσκηση 89 
Δίνεται ο παρακάτω κώδικας:

```python
import pandas as pd

df = pd.read_excel(
    'https://www.biorxiv.org/highwire/filestream/90334/field_highwire_adjunct_files/1/259390-2.xlsx', 
    sheet_name='Table S11',
    skiprows=[0],
)
df.plot(kind='scatter', x='metaSVM_rank', y='REVEL_rank')
```


Αυτός ο κώδικας κατεβάζει ένα excel με sheet name `Table S11` από τα supplementary tables [αυτού του paper](https://www.biorxiv.org/content/10.1101/259390v2). Στη συνέχεια φτιάχνει ένα scatter plot όπου στον άξονα Χ είναι η στήλη `metaSVM_rank` και στον άξονα y είναι η στήλη `REVEL_rank`. Μπορούμε τώρα να μετατρέψουμε όλο το excel sheet σε μία λίστα:

```python
my_list = df.to_dict('records')
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία λίστα με την ίδια δομή όπως η `my_list`. Η συνάρτηση θα φτιάχνει ένα scatter plot μέσω της matplotlib όπως αυτό που παράγει ο κώδικας που δόθηκε παραπάνω. 


### Άσκηση 90  
Ο παρακάτω κώδικας φτιάχνει ένα dataframe το οποίο περιέχει το πλήθος από ανθρώπους που έχουν μεταναστεύσει από την Ελλάδα για το εξωτερικό από το 2008 μέχρι και το 2019:

```python
def get_data_90():
    df = pd.read_csv(
        'https://raw.githubusercontent.com/ariansajina/master-thesis/main/data/ELSTAT-greece-emigration.csv',
        thousands=',',
    )
    df.rename(columns={'Unnamed: 0': 'age_group'}, inplace=True)
    
    return df
```

Από αυτό το DataFrame μπορούμε να φτιάξουμε ένα stacked barplot (δηλαδή η κάθε μπάρα περιέχει πολλές κατηγορίες) γκρουπάροντας τις διάφορες ηλικιακές ομάδες:

```python
def make_plot_90(df):

    df = df[df['age_group'] != 'TOTAL'].copy()
    
    
    def get_age_group(x):
        if x in {'0-4', '5-9', '10-14', '15-19'}:
            return 'Non adults (0-19)'
        if x in {'20-24', '25-29', '30-34', '35-39',}:
            return 'young (20-39)'
        if x in {'40-44', '45-49', '50-54', '55-59'}:
            return 'senior (40-59)'
        if x in {'60-64', '65-69', '70-74', '75-79', '80-84', '85+'}:
            return 'old (>59)'

        assert False, f'{x} was not matched'
        
    df['group'] = df['age_group'].map(get_age_group)
    
    years = [str(x) for x in range(2008, 2020)]
    df_grp = df.groupby(['group'])[years].aggregate('sum').T
    df_col = df_grp[['Non adults (0-19)', 'young (20-39)', 'senior (40-59)', 'old (>59)']]
    df_col.plot(kind='bar', stacked=True, figsize=(10, 6))
```

Οπότε ο παρακάτω κώδικας:

```python
data = get_data_90()
make_plot_90(data)

```

Παράγει το παρακάτω αρκετά λυπηρό plot:

![img](https://i.imgur.com/4GHaKDN.png)

Μπορούμε τώρα να μετατρέψουμε τα δεδομένα από το DataFrame `data` σε μία λίστα:

```python
my_list = data.to_dict('records')
```

Φτιάξτε λοιπόν μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία λίστα με την ίδια δομή σαν τη λίστα `my_list`. Η συνάρτηση θα πρέπει να παράγει ένα barplot παρόμοιο με αυτό της συνάρτησης `make_plot_90` χρησιμοποιώντας όμως συναρτήσεις της matplotlib. 

Ένα παράδειγμα για το πως φτιάχνεται stacked barplot με τη matplotlib [φαίνεται εδώ](https://matplotlib.org/stable/gallery/lines_bars_and_markers/bar_stacked.html).







