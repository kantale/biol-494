
# Λίστα με ασκήσεις

## Σημειώσεις για όλες τις ασκήσεις
* **ΑΠΑΓΟΡΕΥΕΤΑΙ** να κάνετε: ```a = input("...")``` (και γενικότερα μην το κάνετε ποτέ αυτό..)
* Όταν η εκφώνηση λέει ότι πρέπει να φτιάξετε συνάρτηση.. πρέπει να φτιάξετε συνάρτηση!
* Αν η εκφώνηση λέει ότι η συνάρτηση πρέπει να επιστρέφει κάτι.. τότε μέσα στη συνάρτησή σας πρέπει κάπου να κάνετε ```return```.


## Σημειώσεις για τις ασκήσεις: 1-10
* **ΑΠΑΓΟΡΕΥΕΤΑΙ** η χρήση της ```if``` (αν τη χρησιμοποιείσετε χάνετε τη μισή άσκηση)
* **AΠΑΓΟΡΕΥΕΤΑΙ** να κάνετε: ```return True```  ή ```return False```  (αν το χρησιμοποιείσετε χάνετε τη μισή άσκηση)

Για παράδειγμα, έστω ότι η άσκηση λέει: 

Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν αριθμό. Η συνάρτηση θα πρέπει να επιστρέφει:
* ```True``` αν ο αριθμός είναι μονός
* ```False``` αν ο αριθμός είναι ζυγός (άρτιος).

Τι να **ΜΗΝ** κάνετε:
```python
def f(n):
    if n%2 == 1:
        return True
    else:
        return False

```

Τι να κάνετε:
```python
def f(n):
    return n%2 == 1
```

### Άσκηση 1
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν αριθμό. 
* Αν το υπόλοιπο της διαίρεσης του αριθμού με το 7 είναι μονός θα απιτρέφει: ```True```
* Αν το υπόλοιπο της διαίρεσης του αριθμού με το 7 είναι ζυγός (άρτιος) θα επιστρέφει ```False```

Λύση:
```python
def f(x):
    return (x%7) % 2 == 1
```

### Άσκηση 2
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν αριθμό. 
* Αν ο αριθμός ανήκει στο διάστημα \[100,200\] (δηλαδή είναι μεγαλύτερος ή ίσος από το 100 και μικρότερος ή ίσος από το 200) η συνάρτηση θα επιστρέφει ```True```.
* Aν o αριθμός ΔΕΝ ανήκει στο διάστημα \[100, 200\] η συνάρτηση θα επιστρέφει ```False```.

Λύση:
```python
# 1st solution
def f(x):
    return x>=100 and x<=200

# 2nd solution
def f(x):
    return 100 <= x <= 200
```



### Άσκηση 3
Υπολογίστε και τυπώστε τις τιμές της συνάρτησης:

f(x)=-8x<sup>2</sup> + 5x - 2

Για x=5, x=6, x=7


```python
def f(x):
    return (-8*(x**2)) + (5*x) -2

print (f(5))
print (f(6))
print (f(7))
```

### Άσκηση 4
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν string το οποίο αναπαριστάει μία ακολουθία DNA. Η συνάρτηση θα επιστρέφει ένα string το οποίο θα αποτελείται από το δεύτερο γράμμα κάθε τριπλέτας.

Για παράδειγμα:

Έστω η ακολουθία: ```CAGTGACGTACCGTAGGGCGTAGCGTAACG```

```
Η ακολουθία:
CAGTGACGTACCGTAGGGCGTAGCGTAACG

Σε τριπλέτες:
CAG TGA CGT ACC GTA GGG CGT AGC GTA ACG

Το δεύτερο γράμμα κάθε τριπλέτας είναι:
CAG TGA CGT ACC GTA GGG CGT AGC GTA ACG
 |   |   |   |   |   |   |   |   |   |
 A   G   G   C   T   G   G   G   T   C


Άρα αν f είναι το όνομα της συνάρτησης που θα φτιάξετε, το αποτέλεσμα της εντολής:
f('CAGTGACGTACCGTAGGGCGTAGCGTAACG')

Θα πρέπει να είναι:
'AGGCTGGGTC'
```

Λύση:
```python
def f(x):
    return x[1::3]
```

### Άσκηση 5
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν string το οποίο αναπαριστάει μία ακολουθία DNA. Η συνάρτηση θα επιστρέφει το [CG content](https://en.wikipedia.org/wiki/GC-content) της ακολουθίας. Το GC content υπολογίζεται με βάση τον παρακάτω τύπο:

![img](https://i.imgur.com/oRNebOT.png)

Όπου A,C,G,T είναι το πλήθος των A,C,G,T που υπάρχουν στην ακολουθίας. 

Λύση:
```python
def f(x):
    C = x.count('C')
    G = x.count('G')
    return (C+G) / len(x)
```

### Άσκηση 6
Φτάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα 2 αριθμούς. Ο πρώτος αναπαριστάει τον βαθμό ενός μαθητή στη πρόοδο ενός μαθήματος και ο δεύτερος τον βαθμό στο τελικό διαγώνισμα. Η πρόοδος μετράει για το 40% του τελικού βαθμού και το τελικό διαγώνισμα μετράει για το 60%. Η βάση του μαθήματος είναι το 5. Η συνάρτηση θα πρέπει να επιστρέφει:
* ```True``` αν ο μαθητής περνάει το μάθημα. 
* ```False``` αν ο μαθητής ΔΕΝ περνάει το μάθημα. 


Λύση:
```python
def f(a,b):
    return 0.6*a + 0.4*b > 0.5
```

### Άσκηση 7
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα ένα string το οποίο θα αναπαριστάει μία ακολουθία DNA. Η συνάρτηση θα πρέπει να επιστρέφει:
* ```True``` αν η ακολουθία αποτελείται από 2 αντίγραφα
* ```False``` αν η ακολουθία ΔΕΝ αποτελείται από 2 αντίγραφα.

Μία ακολουθία αποτελείται από δύο αντίγραφα αν το 1ο μισό της είναι ίδιο με το δεύτερο μισό της. Για παράδειγμα:

```
f('AAACCCGGGAAACCCGGG') # Επιστρέφει True
το 1ο μισό της είναι: AAACCCGGG
Το 2ο μισό της είναι: AAACCCGGG


f('AAACCCGGGAAACCCGGT') # Επιστρέφει False
το 1ο μισό της είναι:  AAACCCGGG
το 2ο μισό της είναι:  AAACCCGGT

```

Υποθέστε ότι πάντα η ακολουθία έχει ζυγό (άρτιο) αριθμό από βάσεις. 

Λύση:
```python
def f(x):

    l = len(x)//2
    return x[:l] == x[l:]
```


### Άσκηση 8
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα ένα string το οποίο θα αναπαριστάει μία ακολουθία DNA. Η συνάρτηση θα επιστρέφει:
* ```True``` , Αν οι πουρίνες (A ή G) είναι περισσότερες ή ίσες με τις πυριμιδίνες (T ή C). 
* ```False``` , Aν οι πουρίνες είναι λιγότερες από τις πυριμιδίνες. 

Λύση:
```python
def f(x):

    A = x.count('A')
    C = x.count('C')
    G = x.count('G')
    T = x.count('T')

    return A+G >= G+T 
```

### Άσκηση 9
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα ένα string το οποίο θα αναπαριστάει μία ακολουθία DNA η οποία σε κάποιο υπο-string της περιέχει ένα (και μόνο ένα) ORF ([Open Reading Frame](https://en.wikipedia.org/wiki/Open_reading_frame)). Η συνάρτηση θα επιστρέφει το ORF που περιέχει η ακολουθία. Για αυτή την άσκηση θα θεωρήσουμε ότι το stop codon μπορεί να είναι μόνο ```TAA```. Το start codon είναι: ```ATG```. 

Για παράδειγμα έστω η ακολουθία: 
```
TGCACTGGGGAAAATGTTACCAGGTCCGAACTTATTGAGGTAAGACAGA
```
Παρατηρούμε ότι:
```
TGCACTGGGGAAAATGTTACCAGGTCCGAACTTATTGAGGTAAGACAGA
             ^^^                        ^^^
              |                          |
            start                       stop
            codon                       codon
```


Θα πρέπει η συνάρτησή σας να επιστρέψει το ORF: ```ATGTTACCAGGTCCGAACTTATTGAGGTAA```

Σημείωση: Θεωρούμε ότι τα ```ATG``` και ```ΤΑΑ``` βρίσκονται πάντα σε θέσεις τριπλέτων, δεν χρειάζεται να το ελέγξετε αυτό. 

Λύση:
```python
def f(x):

    start = x.index('ATG')
    end = x.index('TAA') + 3
    return x[start:end]
```

### Άσκηση 10
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα ένα string το οποίο θα αναπαριστάει μία ακολουθία DNA. H συνάρτησή σας θα πρέπει να επιστρέφει:
* ```True``` αν υπάρχει το start codon (```ATG```) στην ακολουθία **KAI** αν αυτό βρίσκεται σε θέση που να διαρείται με το 3 (δηλαδή όντως αποτελεί κωδικόνιο)
* ```False``` αν δεν ισχύει η παραπάνω συνθήκη. 

Για παράδειγμα:

```
f('AAAATGGGG') # Επιστρέφει True: To ATG είναι στη 3η θέση (μετρώντας από το 0) 
f('TAAAATGGGG') # Επιστρέφει False: To ATG είναι στη 4η θέση (μετρώντας από το 0)
f('AAACCCGGG') # Επιστρέφει False: Δεν υπάρχει το ATG μέσα στην ακολουθία
```

Λύση:
```python
# 1st solution 
def f(x):
    return x.count('ATG') > 0 and x.index('ATG')%3 == 0

# 2nd solution 
def f(x):
    return 'ATG' in x and x.index('ATG')%3 == 0

# 3rd solution 
def f(x):
    return x.find('ATG')%3 == 0

```


## Ασκήσεις 11-20

### Άσκηση 11
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν όρισμα δύο παραμέτρους: το ΒΜΙ και το gender. Η συνάρτηση θα κάνει τους εξής υπολογισμούς:
* Αν το gender είναι ```"male"``` τότε:
   * Αν το BMI > 32 επιστρέφει ```"overweight"```
   * Αν το BMI <= 32 επιστρέφει ```"not overweight"```
* Αν το gender είναι ```"female"``` τότε:
   * Αν το BMI > 30 επιστρέφει ```"overweight"```
   * Αν το BMI <= 30 επιστρέφει ```"not overweight"```

Λύση:
```python
# 1st solution
def f(BMI, gender):
    if gender == 'male':
        if BMI > 32:
            return "overweight"
        return "not overweight"
    if gender == "female":
        if BMI > 30:
            return "overweight"
        return "not overweight"


#2nd solution
def f(BMI, gender):

    overweight = (gender == 'male' and BMI > 32) or (gender == 'female' and BMI > 30)
    if overweight:
        return 'overweight'

    return "not overweight"
```

### Άσκηση 12
Σύμφωνα με [αυτό το site](https://alen.space/basic-guide-nanosatellites/) υπάρχει μία κατηγοριοποίηση των δορυφόρων σε σχέση με το βάρος τους. Η κατηγοριοποίηση αυτή είναι:

```
    Large satellites: More than 1,000 kg
    Medium-sized satellites: 500-1,000 kg
    Small satellites:
        Minisatellite: 100-500 kg
        Microsatellite: 10-100 kg
        Nanosatellite: 1-10 kg
        Picosatellite: Less than 1 kg
```

Βλέπουμε λοιπόν ότι υπάρχουν τρεις βασικές κατηγορίες: ```"Large satellites"```, ```"Medium-sized satellites"``` και ```"Small satellites"```. Οι Small satellites χωρίζονται σε 4 υποκατηγορίες: ```Minisatellite```, ```Microsatellite```, ```Nanosatellite``` και ```Picosatellite```. 

Φτιάξτε λοιπόν μία συνάρτηση η οποία θα παίρνει σαν παράμετρο τη μεταβλήτή: ```weight```. Ανάλογα με τον πίνακα παραπάνω η συνάρτηση θα επιστρέφει σε **ένα** string με τη κατηγορία και την υποκατηγορία (αν υπάρχει) του δορυφόρου με αυτή το βάρος. Για παράδειγμα:

```
f(1500) # Επιστρέφει: "Large satellite"
f(750)  # Επιστρέφει: "Medium-sized satellite"
f(200)  # Επιστρέφει: "Small satellite - Minisatellite"
f(0.5)  # Επιστρέφει: "Small satellite - Picosatellite"
``` 

Για τις οριακές τιμές επιστρέφουμε τη μικρότερη δυνατή κατηγορία. 

Λύση:
```python
def f(x):
    if x > 1000:
        return 'Large satellit'

    if x > 500:
        return 'Medium-sized satellites'

    if x > 100:
        return 'Small satellites - Minisatellite'

    if x > 10:
        return 'Small satellites - Microsatellite'

    if x > 1:
        return 'Small satellites - Nanosatellite'

    return 'Small satellites - Picosatellite'
```

### Άσκηση 13
Σε [αυτό το site](https://life-greece.gr/prostima-kok-gia-alkool-2019) υπάρχει ένας πίνακας με τα χρηματικά πρόστιμα για την οδήγηση υπό την επήρεια αλκοόλ. Αφού αναλογιστείτε πόσο επικίνδυνο είναι για εσάς και τους υπόλοιπους η οδήγηση υπό την επήρεια αλκοόλ φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν παράμετρο τη μεταβλητή alcohol. Η συνάρτηση θα επιστρέφει:

* Αν το alcohol < 0.25, επιστρέφει τον ακέραιο 0
* Αν το alcohol είναι από 0.25 μέχρι και 0.4 επιστρέφει τον ακέραιο 200
* Αν το alcohol είναι μεγαλύτερο από 0.4 μέχρι και 0.6 επιστρέφει τον ακέραιο 700
* Αν το alcohol είναι μεγαλύτερο από 0.6, επιστρέφει τον ακέραιο 3000

Λύση:
```python
def f(x):
    if alcohol < 0.25:
        return 0

    if alcohol <= 0.4:
        return 200

    if alcohol <= 0.6:
        return 700

    return 3000
```

### Άσκηση 14
Φτιάξτε μία συνάρτηση σε python, τέτοια ώστε όταν γράφω:
```
f(1)
```

Να επιστρέφει ```"Hello"```

Όταν γράφω:
```
f(f(1))
```
Να επιστρέφει ```"Mitsos"```

Όταν γράφω:
```
f(f(f(1)))
```
Να επιστρέφει: ```"Maria"```

```python
def f(x):

    if x == 1:
        return 'Hello'

    if x == 'Hello':
        return 'Mitsos'

    if x == 'Mitsos':
        return 'Maria'
```

### Άσκηση 15
Φτιάξτε δύο συναρτήσεις σε python με το όνομα ```f``` και ```g```. Και οι δύο συναρτήσεις θα πρέπει να παίρνουν σαν παράμετρο έναν ακέραιο και να επιστρέφουν έναν ακέραιο. Οι συναρτήσεις θα πρέπει να είναι τέτοιες ώστε η τιμή της έκφρασης:

```
f(g(1)+g(2)) + g(f(1)+f(2))
```

να είναι 3. 

Λύση:
```python
def f(x):
    return x

def g(x):
    return x-1
```

### Άσκηση 16
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν παράμετρο 2 αριθμούς: a,b. H συνάρτηση θα πρέπει να λύνει την εξίσωση ```ax+b=0``` με τον εξής τρόπο:

* Αν το a είναι 0 τότε:
   * Αν το b είναι 0 τότε επιστρέφει ```"TAYTOTHTA"```
   * Αν το b δεν είναι 0 τότε επιστρέφει: ```"ADYNATH"```
* Αν το a δεν είναι 0 τότε επιστρέφει τη τιμή: ```-b/a```.

Λύση:
```python
def f(a,b):
    if a == 0:
        if b == 0:
            return 'TAYTOTHTA'
        return 'ADYNATH'

    return -b/a
```

### Άσκηση 17
Ισχύει το εξής:

* Ένα ναυτικό μίλι είναι 1.852 χιλιόμετρα. 
* Ένα χιλιόμετρο είναι 0.62137 μίλια.

Φτιάξτε τη συνάρτηση ```nautical_miles_to_km``` η οποία θα παίρνει σαν παράμετρο έναν αριθμό ο οποίος θα αναπαριστά μία απόσταση σε ναυτικά μίλια και θα επιστρέφει την ίδια απόσταση εκφρασμένη σε χιλιόμετρα.

Φτιάξτε τη συνάρτηση ```km_to_miles``` η οποία θα παίρνει σαν παράμετρο έναν αριθμό ο οποίος θα αναπαριστά μία απόσταση σε χιλιόμετρα και θα επιστρέφει την ίδια απόσταση εκφρασμένη σε μίλια.

Φτιάξτε τη συνάρτηση ```nautical_miles_to_miles``` η οποία θα παίρνει σαν παράμετρο έναν αριθμό ο οποίος θα αναπαριστά μία απόσταση σε ναυτικά μίλια και θα επιστρέφει την ίδια απόσταση εκφρασμένη σε μίλια. Σε αυτή τη συνάρτηση είναι υποχρεωτικό να χρησιμοποιήσετε τις συναρτήσεις ```nautical_miles_to_km``` και ```km_to_miles```.

Λύση:
```python
def nautical_miles_to_km(x):
    return x*1.852

def km_to_miles(x):
    return x*0.62137

def nautical_miles_to_miles(x):
    return km_to_miles(nautical_miles_to_km(x))
```

### Άσκηση 18
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει 3 παραμέτρους. Και οι 3 θα είναι αριθμοί. Η συνάρτηση θα επιστρέφει τον μεσαίο. Για παράδειγμα:

```
f(5,3,6) # Επιστρέφει: 5
f(3,4,5) # Επιστρέφει: 4
f(3,3,4) # Επιστρέφει: 3
f(3,3,3) # Επιστρέφει: 3
```

**Απαγορεύεται να χρησιμοποιήσετε ```max```, ```min```, ```sort```.**

Λύση:
```python
def f(x):
    if (b<=a and a<=c) or (c<=a and a<=b):
        return a
    if (a<=b and b<=c) or (c<=b and b<=a):
        return b

    return c

```

### Άσκηση 19
Φτιάξτε μία συνάρτηση με το όνομα ```reverse``` η οποία θα παίρνει σαν παράμετρο μία ακολουθία DNA. H συνάρτηση θα επιστρέφει την αντίστροφή της (reverse). Για παράδειγμα:

```
reverse('ACGT') # Επιστρέφει: "TGCA"
reverse('AGTCCG') # Επιστρέφει: "GCCTGA"
```

Φτιάξτε μία συνάρτηση με το όνομα ```complement``` η οποία θα παίρνει σαν παράμετρο μία ακολουθία DNA. H συνάρτηση θα επιστρέφει την συμπληρωματική ακολουθία της. Για να φτιάξετε τη συμπληρωματική ακολουθία πρέπει να κάνετε τις εξής αντικαταστάσεις:

* Αντικαταστήστε τα ```A``` με ```T```
* Αντικαταστήστε τα ```T``` με ```A```
* Αντικαταστήστε τα ```C``` με ```G```
* Αντικαταστήστε τα ```G``` με ```C```

* **ΑΠΑΓΟΡΕΥΕΤΑΙ** να χρησιμοποιήσετε biopython ή κάποια βιβλιοθήκη που κάνει αυτό. 
* Hint: 

Έστω το string ```"mitsos"```. Πως θα αντικαταστούσατε το "s" με "ο" και τα "ο" με "s" ;
Αν κάνετε:
```
a = 'mitsos'
a = a.replace('s', 'o')
a = a.replace('o', 's')
print (a)
```
Το αποτέλεσμα είναι: ```"mitsss"``` (γιατί;)

Ένα κόλπο είναι το εξής:
```
a = 'mitsos'
a = a.replace('s', '1')
a = a.replace('o', '2')
a = a.replace('1', 'o')
a = a.replace('2', 's')
print (a)
```

Λύση:
```python

def reverse(x):
    return x[::-1]

def complement(x):
    t = x.replace('A', '1').replace('C', '2').replace('G', '3').replace('T', '4')
    t = t.replace('1', 'T').replace('2', 'G').replace('3', 'C').replace('4', 'A')

    return t
```

### Άσκηση 20
Φτιάξτε μία συνάρτηση με το όνομα ```reverse_complement``` η οποία θα παίρνει σαν όρισμα μία ακολουθία DNA. H συνάρτηση θα επιστρέφει την αντίστροφη συμπληρωματική ακολουθία της. Για παράδειγμα:

```
f('AGTCCG') # Επιστρέφει: "CGGACT" 
```

Μπορείτε να επιβεβαίωσετε τα αποτελέσματά σας με [αυτό το online tool](http://arep.med.harvard.edu/labgc/adnan/projects/Utilities/revcomp.html).

Συνίσταται (δεν είναι υποχρεωτικό) να χρησιμοποιήσετε τις συναρτήσεις ```reverse``` και ```complement``` της άσκησης 19. 

Λύση:
```python
def reverse_complement(x):
    return complement(reverse(x))
```

## Ασκήσεις 21-30

**Για τις ασκήσεις 21-25 δίνεται η παρακάτω συνάρτηση**

```python
import requests

def get_tumor_gene_names():
    r = requests.get('http://mygene.info/v3/query?q=tumor&fields=symbol&size=1000&species=human')
    j = r.json()

    return [x['symbol'] for x in j['hits']]
```

Η συνάρτηση αυτή χρειάζεται το πακέτο requests της python. Αν δεν είναι εγκαταστημένο στον υπολογιστή σας μπορείτε να το εγκαταστήσετε τρέχoντας σε ένα κελί στο jupyter:

```bash
!pip install requests
```

Η συνάρτηση ```get_tumor_gene_names()``` επιστρέφει μία λίστα με γονίδια τα οποία έχουν εντοπιστεί ότι εμπλέκονται στον καρκίνο.

### Άσκηση 21
Φτιάξτε μία συνάρτηση η οποία παίρνει μία παράμετρο. Η παράμετρος είναι μία λίστα με strings. Η συνάρτηση θα επιστρέφει μία νέα λίστα η οποία θα περιέχει τα strings της παραμέτρου τα οποία ξεκινάνε από ```"IL"```

Χρησιμοποιώντας τη συνάρτηση την οποία φτιάξατε και τη συνάρτηση ```get_tumor_gene_names()``` απαντήστε στην ερώτηση: Ποια γονίδια που εμπλέκονται στον καρκίνο είναι ιντερλευκίνες;

Λύση:
```python
def starts_with_IL(x):
    return x[:2] == 'IL'

def ask_21(l):
    return list(filter(starts_with_IL, l))

print (ask_21(get_tumor_gene_names()))
```

### Άσκηση 22
Φτιάξτε μία συνάρτηση με το όνομα ```ask_22_a``` η οποία θα παίρνει μία παράμετρο. Αυτή η παράμετρος είναι μία λίστα από strings. Η συνάρτηση θα επιστρέφει μία νέα λίστα η οποία θα έχει τα στοιχεία της περαμέτρου αλλά θα είναι ταξινομημένη με βάση το μήκος του string (από το μικρότερο στο μεγαλύτερο). 

Χρησιμοποιώντας τη συνάρτηση που μόλις φτιάξατε (τη ```ask_22_a```) και τη ```get_tumor_gene_names()```, φτιάξτε μία άλλη συνάρτηση με το όνομα ```ask_22_b``` η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει την απάντηση στην ερώτηση: Ποια είναι τα 10 γονίδια με το μεγαλύτερο όνομα τα οποία εμπλέκονται στον καρκίνο;

Λύση:
```python
def ask_22_a(l):
    return sorted(l, key=len)

def ask_22_b():
    l = get_tumor_gene_names()
    s = ask_22_a(l)
    return s[-10:]
```

### Άσκηση 23
Φτιάξτε μία συνάρτηση με το όνομα ```ask_23_a``` η οποία θα παίρνει μία παράμετρο. Αυτή η παράμετρος είναι μία λίστα από strings. Η συνάρτηση θα επιστρέφει τη λίστα της περαμέτρου όπου όμως σε κάθε στοιχείο της θα έχετε αφαιρέσει όλους τους αριθμούς. Για παράδειγμα θα πρέπει:

```python
l = ['C1QTNF3', 'CD274', 'TNFRSF21']
f(l) # Επιστρέφει: ['CQTNF', 'CD', 'TNFRSF']
```
Χρησιμοποιώντας τη συνάρτηση ```ask_23_a```, τη συνάρτηση ```ask_22_a``` της άσκησης 22 και τη συνάρτηση ```get_tumor_gene_names()```, φτιάξτε μία νέα συνάρτηση με το όνομα ```ask_23_b``` η οποία δεν θα παίρνει κάποιο όρισμα. Η συνάρτηση θα επιστρέφει την απαντήση στην ερώτηση: Αν αφαιρέσουμε τους αριθμούς από τα ονόματα των γονιδίων, ποια είναι τα 10 γονίδια με το μεγαλύτερο όνομα τα οποία εμπλέκονται στον καρκίνο; (Τυπώστε τα αλλαγμένα ονόματα)

Λύση:
```python
def remove_digits(s):
    ret = ''
    for letter in s:
        if not letter in '0123456789':
            ret += letter
            
    return ret

def ask_23_a(l):
    return list(map(remove_digits, l))

def ask_23_b():
    l = get_tumor_gene_names()
    l_no_digits = ask_23_a(l)
    l_no_digits_sorted = ask_22_a(l_no_digits)
    return l_no_digits_sorted[-10:]

ask_23_b()
```

### Άσκηση 24
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα επιστρέφει έναν αριθμό ο οποίος θα είναι το πλήθος των γονιδίων που εμπλέκονται στον καρκίνο και ΔΕΝ έχουν κάποιον αριθμό στον όνομά τους. 

Λύση:
```python
def does_not_has_digit(s):
    for x in s:
        if x in '0123456789':
            return False
    return True

def ask_24():
    l = get_tumor_gene_names()
    
    return sum(list(map(does_not_has_digit, l)))
```

### Άσκηση 25
Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι μία λίστα από strings. Η συνάρτηση θα επιστρέφει το στοιχείο της λίστας που έχει το μικρότερο μήκος. Αν δύο ή περισσότερα στοιχεία έχουν το ίδιο μικρότερο μήκος, τότε θα επιστρέφει αυτό που είναι μικρότερο αλφαβητικά. Για παράδειγμα:

```python
a =['lll', 'kkk', 'aaaa']

f(a) # Επιστρέφει "kkk" (είναι το μικρότερα αλφαβητικά και έχει το μικρότερο δυνατό μήκος)
f(get_tumor_gene_names()) # Επιστρέφει: ANG 

```

Αν χρησιμοποιήσετε 2 φορές τη sorted στην Άσκηση 25, χάνετε 2 μονάδες (8/10)

Λύση:
```python
def ask_25(l):
    def sort_sort_according_to_this(x):
        return [len(x), x]
    
    return min(l, key=sort_sort_according_to_this)

ask_25(get_tumor_gene_names())
```

**Για τις ασκήσεις 26-30 δίνεται η παρακάτω συνάρτηση:**

```python
import requests

def get_tumour_genes_pos():
    url = 'http://mygene.info/v3/query?q=tumor'
    url += '&fields=symbol,genomic_pos.chr,genomic_pos.start,genomic_pos.end'
    url += '&size=1000&species=human'
    
    r = requests.get(url)
    j = r.json()

    list_1 = [
        [
            x['symbol'], 
            (x['genomic_pos'][0] if type(x['genomic_pos']) is list else x['genomic_pos']),
        ] for x in j['hits'] if 'genomic_pos' in x]

    list_2 = [
        [
            x[0], x[1]['chr'], x[1]['start'], x[1]['end']
        ] for x in list_1 if not 'CHR' in x[1]['chr']]

    return list_2
```

Αν τρέξετε αυτή τη συνάρτηση θα επιστρέψει πάλι τα γονίδια τα οποία έχουν εμπλακεί στον καρκίνο αλλά αυτή τη φορά για κάθε γονίδιο θα έχουμε μία λίστα. 

Για παράδειγμα, ας τυπώσουμε τα πρώτα δέκα γονίδια:
```python
genes = get_tumour_genes_pos()
genes[:10]
```
Τυπώνει (ίσως σε εσάς να τυπώσει διαφορετική λίστα):
```
[['TPD52', '8', 80034745, 80231232],
 ['TP53', '17', 7661779, 7687538],
 ['TSG101', '11', 18468336, 18526951],
 ['TP63', '3', 189631389, 189897276],
 ['TP73', '1', 3652516, 3736201],
 ['TUSC3', '8', 15417215, 15766649],
 ['TUSC7', '3', 116709235, 116723581],
 ['PTTG2', '4', 37960398, 37961128],
 ['TUSC8', '13', 44400250, 44405984],
 ['TUSC1', '9', 25676389, 25678440]]
```

* το 1ο στοιχείο είναι το όνομα ενός γονιδίου
* το 2ο στοιχείο είναι το χρωμόσωμα στο οποίο ανήκει
* το 3ο στοιχείο είναι η αρχή του γονιδίου πάνω στο χρωμόσωμα
* το 4ο στοιχείο είναι το τέλος του γονιδίου πάνω στο χρωμόσωμα 


### Άσκηση 26
Φτιάξτε μία συνάρτηση η οποία παίρνει μία παράμετρο. Η παράμετρος είναι μία λίστα όπως η λίστα που επιστρέφει η ```get_tumour_genes_pos()```. Η συνάρτηση θα επιστρέφει το όνομα του γονιδίου με το μεγαλύτερο μήκος. Το μήκος ενός γονιδίου είναι η διαφορά του τέλους από την αρχή του. Για παράδειγμα το μήκος του γονιδίου TPD52 είναι: 80231232-80034745=196487

Λύση:
```python
def get_length(gene):
    return gene[3]-gene[2]

def ask_26(l):
    return max(l, key=len)

ask_26(get_tumour_genes_pos())
```

### Άσκηση 27
Φτιάξτε μία συνάρτηση η οποία παίρνει μία παράμετρο. Η παράμετρος είναι μία λίστα όπως η λίστα που επιστρέφει η ```get_tumour_genes_pos()```. Η συνάρτηση θα επιστρέφει μία λίστα με τα ονόματα των γονιδίων της λίστας της παραμέτρου ταξινομημένα ανάλογα με τη θέση τους στο γονιδίωμα. Πρώτα πάνε τα γονίδια που είναι στο χρωμόσωμα 1, μετά τα γονίδια που είναι στο χρωμόσωμα 2, ... μετά το χρωμόσωμα 22 μετά το Χ και στο τέλος το Υ. Τα γονίδια που είναι στο ίδιο χρωμόσωμα ταξινομούνται με βάση την θέση της αρχής τους στο χρωμόσωμά τους. 

Λύση:
```python
def ask_27(l):
    
    def get_chromosome_number(chromosome):
        if chromosome == 'X':
            return 23
        if chromosome == 'Y':
            return 24
        if chromosome == 'MT':
            return 25
        
        return int(chromosome)
    
    def sort_according_to_this(gene):
        return [get_chromosome_number(gene[1]), gene[2]]
    
    return sorted(l, key=sort_according_to_this)

ask_27(get_tumour_genes_pos())
```

### Άσκηση 28
Φτιάξτε μία συνάρτηση η οποία παίρνει μία παράμετρο. Η παράμετρος είναι μία λίστα όπως η λίστα που επιστρέφει η ```get_tumour_genes_pos()```. Η συνάρτηση θα επιστρέφει το μέσο όρο του μήκους των γονιδίων που περιέχει. 

Μέσος όρος της λίστας ```a = [4,5,6,6]``` είναι ```sum(a)/len(a)```

Λύση
```python
def ask_28(l):
    def get_length(gene):
        return gene[3]-gene[2]
    
    return sum(map(get_length, l))/len(l)

ask_28(get_tumour_genes_pos())
```

### Άσκηση 29
Φτιάξτε μία συνάρτηση η οποία θα παίρνει δύο παράμετρους. Η πρώτη θα είναι μία λίστα όπως η λίστα που επιστρέφει η ```get_tumour_genes_pos()``` και η δεύτερη θα είναι το όνομα ενός χρωμοσώματος (π.χ. ```"4"```). H συνάρτηση θα επιστρέφει το πλήθος των γονιδίων της λίστας που ανήκουν σε αυτό το χρωμόσωμα.


π.χ.
```python
f(genes, '4') # Επιστρέφει 32
f(genes, '1') # Επιστρέφει 94 
f(genes, '21') # Επιστρέφει 8
```

Λύση:
```python
def ask_29(l, chromosome):

    def belongs_to_chromosome(gene):
        return gene[1] == chromosome
    
    return len(list(filter(belongs_to_chromosome, l)))

l = get_tumour_genes_pos()
ask_29(l, '1')
```

**Προσοχή:** Σε εσάς ίσως επιστρέφει λίγο διαφορετικές τιμές. Η συνάρτηση ```get_tumour_genes_pos()``` ενδέχεται να επιστρέφει ένα ελαφρώς διαφορετικό σετ από γονίδια κάθε φορά που τη καλείτε. Αυτό είναι ΟΚ! Απλά το site από όπου "τραβάει" τα δεδομένα αυτή η συνάρτηση δεν εγγυάται ότι θα επιστρέφει πάντα τα ίδια.
 

### Άσκηση 30
Φτιάξτε μία συνάρτηση η οποία παίρνει μία παράμετρο. Η παράμετρος είναι μία λίστα, όπως αυτή που επιστρέφει η συνάρτηση ```get_tumour_genes_pos()```. Η συνάρτηση θα επιστρέφει το όνομα του γονίδιου του οποίου το μήκος έχει τη μικρότερη απόσταση από το μέσο όρο του μήκους όλων των γονιδίων. 

Πως βρίσκουμε την απόσταση μεταξύ των αριθμών ```a``` και ```b```: ```abs(a-b)```. 

```python
def ask_30(l):
    
    def get_length(gene):
        return gene[3]-gene[2]

    mo = sum(map(get_length, l))/len(l)

    def sort_according_to_this(gene):
        return abs(mo-get_length(gene)),
    
    return min(l, key=sort_according_to_this)[0]

ask_30(get_tumour_genes_pos())
```

### Άσκηση 31
Γράψτε μία συνάρτηση η οποία θα παίρνει ως όρισμα 3 ακέραιους αριθμούς τους a,b,c. Η συνάρτηση θα επιστρέφει το άθροισμα όλων των αριθμών από το a μέχρι και το b οι οποίοι διαιρούνται με το c. Για παράδειγμα:

```
f(23, 258, 7) # επιστρέφει 4620
```

```python
# 1st solution
def ask_31(a,b,c):
    
    s = 0
    for x in range(a,b+1):
        if x%c==0:
            s += 1
    return s

# 2nd solution
def ask_31(a,b,c):
    return sum(x%c==0 for x in range(a,b+1))
```


### Άσκηση 32
Γράψτε μία συνάρτηση η οποία θα παίρνει ένα όρισμα. Το όρισμα θα είναι μία λίστα με αριθμούς. Η συνάρτηση θα επιστρέφει το γινόμενο των αντίστροφων των στοιχείων της λίστας τα οποία δεν είναι 0. Ο αντίστροφος ενός αριθμού a είναι το 1/a.  

Για παράδειγμα:

f([2, 4, 0, 0.1]) # επιστρέφει 1/2 * 1/4 * 1/0.1 = 1.25 

Λύση:
```python
def ask_32(l):
    p = 1
    
    for x in l:
        if x == 0:
            continue
            
        p *= 1/x # p = p * 1/x
        
    return p
```

### Άσκηση 33
Ένας πληθυσμός με το όνομα Α αποτελείται από 20 ανθρώπους. Σε αυτούς τους ανθρώπους κάναμε γονοτύπηση σε 10 γενετικούς τόπους. Όλοι οι γονότυποι είναι δι-αλληλικοί (biallelic). Κάθε ένας από τους 10 γενετικούς τόπους έχει όνομα Μ1, Μ2, ... Μ10. Τα αποτελέσματα που πήραμε υπάρχουν σε αυτή τη λίστα:

```python
pop_A = [
    ['M1', 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 2, 1, 0, 1, 1, 1, 0, 1],
    ['M2', 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 1, 0],
    ['M3', 1, 1, 1, 0, 0, 2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 1, 0, 2, 1],
    ['M4', 1, 1, 0, 0, 0, 0, 1, 2, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
    ['M5', 0, 0, 2, 2, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 0, 2],
    ['M6', 0, 0, 1, 0, 2, 0, 0, 0, 1, 1, 2, 2, 2, 0, 0, 0, 1, 0, 0, 0],
    ['M7', 0, 0, 2, 1, 1, 1, 0, 2, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0],
    ['M8', 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 0, 0, 2],
    ['M9', 0, 0, 1, 0, 0, 1, 2, 1, 0, 0, 1, 1, 1, 1, 0, 2, 1, 0, 2, 1],
    ['M10', 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1]
]
```

Σε αυτή τη λίστα οι αριθμοί 0,1,2 σημαίνουν:
* 0: Ο γονότυπος είναι ομόζυγος στο πρωτεύον αλλήλιο
* 1: Ο γονότυπος είναι ετερόζυγος
* 2: Ο γονότυπος είναι ομόζυγος στο δευτερεύον αλλήλιο.

Ή αλλιώς τα 0,1,2 είναι το πλήθος των δευτερεύοντων αλλήλιων που έχει ο αντίστοιχος γονότυπος. 

Φτιάξτε μία συνάρτηση ο οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι μία λίστα όπως η ```pop_A```. Η συνάρτηση θα επιστρέφει το όνομα του γονότυπου με τη μεγαλύτερη αλληλική συχνότητα του δευτερεύοντος αλλήλιου. Για παράδειγμα θα πρέπει:

```python
f(pop_A) # Επιστρέφει 'Μ9'
```

Λύση:
```python

def ask_33(pop):
    def get_freq(m):
        return sum(m[1:])/(2*len(m[1:]))
    
    m = max(pop, key=get_freq)
    return m[0]

print (ask_33(pop_A))

```

### Άσκηση 34
Κάνουμε τον ίδιο πείραμα σε έναν άλλο πληθυσμό ο οποίος όμως τώρα έχει 25 άτομα. Τα αποτελέσματα της γονοτύπησης υπάρχουν στη παρακάτω λίστα: 

```python
pop_B = [
    ['M1', 2, 1, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 1, 0, 1, 0, 2, 0, 1, 0, 2, 0, 1], 
    ['M2', 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 2, 0, 0, 0],
    ['M3', 1, 1, 0, 2, 1, 1, 0, 0, 2, 0, 2, 0, 0, 1, 0, 1, 0, 0, 0, 2, 0, 0, 0, 1, 1],
    ['M4', 0, 0, 1, 0, 2, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 2, 1, 1, 0, 0, 2],
    ['M5', 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 2, 0, 1, 0, 0, 2, 1, 1, 0, 1, 0, 0, 0, 0],
    ['M6', 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 1, 2, 1, 0, 2, 1, 0],
    ['M7', 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 2, 0, 2, 2],
    ['M8', 0, 2, 0, 0, 1, 0, 1, 2, 0, 0, 0, 2, 0, 0, 1, 1, 0, 0, 0, 1, 2, 0, 1, 0, 0],
    ['M9', 1, 1, 1, 0, 0, 2, 0, 1, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 2, 1, 0],
    ['M10', 1, 0, 0, 2, 0, 0, 0, 1, 0, 0, 2, 2, 0, 2, 1, 0, 1, 2, 0, 0, 1, 0, 0, 1, 1]
]

```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει δύο παράμετρους Α και Β. Κάθε παράμετρος θα είναι μία λίστα όπως η pop_A και pop_B. Η συνάρτηση θα επιστρέφει το όνομα του γενετικού τόπου του οποίου η αλληλική συχνότητα του δευτερεύοντος αλλήλιου έχει τη μεγαλύτερη απόλυτη διαφορά μεταξύ των πληθυσμών Α και Β. 

Λύση:
```python
def ask_34(pop_1, pop_2):
    def get_freq(m):
        return sum(m[1:])/(2*len(m[1:]))
    
    def compare_freq(m):
        return abs(get_freq(m[0]) - get_freq(m[1]))
            
    max_diff = max(zip(pop_1, pop_2), key=compare_freq)
    return max_diff[0][0]

ask_34(pop_A, pop_B) 
```

### Άσκηση 35
[Αυτό το άρθρο της wikipedia](https://en.wikipedia.org/wiki/Genetic_distance) έχει έναν κατάλογο με μετρικές για την μέτρηση της γενετικής απόστασης μεταξύ δύο πληθυσμών με βάση τις αλληλικές τους συχνότητες. Αυτό το άρθρο είναι αρκετά κακογραμμένο και μπορείτε να το αγνοήσετε!

Καταρχήν θα ορίσουμε τη αλληλική συχνότητα P<sub>γ,α,π</sub> ως τη συχνότητα του αλλήλιου α στον γενετικό τόπο γ στον πλυθυσμό π. Για παράδειγμα ο πληθυσμός pop_A (θα τον αναφέρουμε σαν Α) έχει για κάθε έναν από τους 10 γενετικούς τόπους, 2 διαφορετικά αλλήλια (το πρωτεύον και το δευτερεύον). Στον γενετικό τόπο ```Μ1``` έχουμε τον γονότυπο από 20 ανρθώπους:

```python
print (pop_A[0][1:])
[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 2, 1, 0, 1, 1, 1, 0, 1]
```

Εδώ παρατηρούμε οτι έχουμε 11 φορές το 0, 8 φορές το 1 και μία φορά το 2. Άρα:
* Το πρωτεύον αλλήλιο υπάρχει: 11\*2 + 8\*1 = 30 φορές.
* Το δευτερεύον αλλήλιο υπάρχει: 8\*1 + 1\*2 = 10 φορές. 

Άρα το P<sub>1,πρωτεύον,Α</sub> είναι 30/40 . Ή αλλιώς η συχνότητα του πρωτεύοντος αλλήλιου στον γενετικό τόπο 1 στον πληθυσμό Α είναι 30/40. Ομοίως: P<sub>1,δευτερεύον,Α</sub> είναι 10/40. Ή αλλιώς η συχνότητα του δευτερεύοντος αλλήλιου στον γενετικό τόπο 1 στον πληθυσμό Α είναι 10/40.

Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 παραμέτρους. Και οι δύο παράμετροι θα είναι λίστες με το όνομα Α και Β. Οι λίστες θα έχουν την ίδια μορφή όπως και οι λίστες ```pop_A``` και ```pop_B```. Η συνάρτηση θα επιστρέφει την ευκλίδεια απόσταση (Rogers Euclidean distance) μεταξύ των πληθυσμών ```A``` και ```B```, η οποία ορίζεται ως εξής:

* Για κάθε γενετικό τόπο j (Μ1 έως Μ10) υπολογίστες τα P<sub>j,δευτερεύον,Α</sub> και P<sub>j,δευτερεύον,Β</sub>. Στη συνέχεια υπολογίστε τη διαφορά τους και στη συνέχεια υπολογίστε το τετράγωνο αυτής της διαφοράς.
* Υπολογίστε το άθροισμα αυτού του τετραγώνου για όλους τους γενετικούς τόπους (Μ1 έως Μ10).
* Υπολογίστε (και επιστρέψτε) τη τετραγωνική ρίζα αυτού του αθροίσματος 

H τετραγωνική ρίζα του a είναι: ```a**0.5```


Δίνεται ότι:
```python
f(pop_A, pop_B) # Επιστρέφει: 0.265 
```


Λύση:
```python
def ask_35(pop_1, pop_2):
    def get_freq(m):
        return sum(m[1:])/(2*len(m[1:]))
    
    s = 0
    for m1, m2 in zip(pop_1, pop_2):
        fr_1 = get_freq(m1)
        fr_2 = get_freq(m2)
        
        s += (fr_1-fr_2)**2
        
    return s**0.5

ask_35(pop_A, pop_B)
```

### Άσκηση 36
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 παραμέτρους. Και οι δύο παράμετροι θα είναι λίστες με το όνομα X και Y. Οι λίστες θα έχουν την ίδια μορφή όπως και οι λίστες ```pop_A``` και ```pop_B```.  Η συνάρτηση θα επιστρέφει την "Nei's minimum genetic distance 1973" μεταξύ των πληθυσμών ```X``` και ```Y``` η οποία υπολογίζεται ως εξής [πηγή](https://dyerlab.github.io/applied_population_genetics/genetic-distances.html):


<!-- OLD ![img](https://i.imgur.com/qde8a4d.png) -->
<!-- 
I=\frac{\sum_{i=1}^{L} \left ( \sum_{j=1}^{l_{i}} \left ( p_{ij,x}p_{ij,y} \right ) \right ) }{\sqrt{\sum_{i=1}^{L} \left ( \sum_{j=1}^{l_{i}} \left ( p_{ij,x}^{2} \right ) \right )}\sqrt{\sum_{i=1}^{L} \left ( \sum_{j=1}^{l_{i}} \left ( p_{ij,y}^{2} \right ) \right )}}
-->
![img](https://i.imgur.com/kpYmmcp.png)


Όπου:
* L είναι το πλήθος από γενετικούς τόπους (10 στη περίπτωσή μας)
* l<sub>i</sub> είναι το πλήθος από αλλήλια στον γενετικό τόπο i. Στη δική μας περίπτωση έχουμε πάντα 2 (bi-allelic)
* p<sub>ij,x</sub> είναι η συχνότητα του αλληλίου j στον γενετικό τόπο i, στον πληθυσμό X
* p<sub>ij,y</sub> είναι η συχνότητα του αλληλίου j στον γενετικό τόπο i, στον πληθυσμό Y

Δίνεται ότι:
```python
f(pop_A, pop_B) # Επιστρέφει: 0.9886664715207936
```

Λύση:
```python
def ask_36(pop_1, pop_2):
    def get_freq(m):
        return sum(m[1:])/(2*len(m[1:]))  
    
    freq_pop_1_allele_1 = [get_freq(x) for x in pop_1]
    freq_pop_1_allele_2 = [1-x for x in freq_pop_1_allele_1]
    freq_pop_2_allele_1 = [get_freq(x) for x in pop_2]
    freq_pop_2_allele_2 = [1-x for x in freq_pop_2_allele_1]
    
    alleles = [
        [freq_pop_1_allele_1, freq_pop_2_allele_1], 
        [freq_pop_1_allele_2, freq_pop_2_allele_2],
    ]
    
    s1 = 0
    s2 = 0
    s3 = 0
    for mutation in range(len(pop_1)):
        for allele in [0,1]:
            s1 += alleles[allele][0][mutation] * alleles[allele][1][mutation]
            s2 += alleles[allele][0][mutation]**2
            s3 += alleles[allele][1][mutation]**2
    
    return s1 / (s2**0.5 * s3**0.5)

ask_36(pop_A, pop_B)
```

### Άσκηση 37
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 παραμέτρους. Και οι δύο παράμετροι θα είναι λίστες με το όνομα X και Y. Οι λίστες θα έχουν την ίδια μορφή όπως και οι λίστες ```pop_A``` και ```pop_B```. Η συνάρτηση θα επιστρέφει την "Cavalli-Sforza chord distance" μεταξύ των πληθυσμών ```pop_A``` και ```pop_B```, σύμφωνα με τον μαθηματικό τύπο ([πηγή](https://www.montana.edu/kalinowski/documents/2002_Genetic_distances_review_MolecularEcology.pdf)):

<!-- 
    D=1-\sum_{j=1}^{2}\left ( \sum_{i=1}^{L} \left ( \frac{\sqrt{p_{ij,x}\cdot p_{ij,y}}}{L} \right ) \right )
-->
![img](https://i.imgur.com/jFdqr3e.png)

<!-- ![img](https://i.imgur.com/qm3WRxQ.png) -->

Όπου:
* L είναι το πλήθος από γενετικούς τόπους (10 στη περίπτωσή μας)
* p<sub>ij,x</sub> είναι η συχνότητα του αλληλίου j στον γενετικό τόπο i, στον πληθυσμό X
* p<sub>ij,y</sub> είναι η συχνότητα του αλληλίου j στον γενετικό τόπο i, στον πληθυσμό Y

Δίνεται ότι:
```python
f(pop_A, pop_B) # Επιστρέφει 0.004909335749700872
```

Λύση:
```python
def ask_37(pop_1, pop_2):
    def get_freq(m):
        return sum(m[1:])/(2*len(m[1:]))  
    
    freq_pop_1_allele_1 = [get_freq(x) for x in pop_1]
    freq_pop_1_allele_2 = [1-x for x in freq_pop_1_allele_1]
    freq_pop_2_allele_1 = [get_freq(x) for x in pop_2]
    freq_pop_2_allele_2 = [1-x for x in freq_pop_2_allele_1]
    
    alleles = [
        [freq_pop_1_allele_1, freq_pop_2_allele_1], 
        [freq_pop_1_allele_2, freq_pop_2_allele_2],
    ]
    
    s = 0
    for allele in [0,1]:
        for mutation in range(len(pop_1)):
            s += (alleles[allele][0][mutation]*alleles[allele][1][mutation]) ** 0.5
            
    s /= len(pop_1) # s = s / len(pop_1)
    
    return 1-s

ask_37(pop_A, pop_B)
```

### Άσκηση 38
Αφού έχετε φτιάξει τις φανταστικές συναρτήσεις σας, ζητάτε από έναν συνάδελφο να σας στείλει τα δεδομένα του. Ο συνάδελφος σας στέλνει την εξής λίστα:

```python
pop_C= [
   ['M1', 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 2, 0, 1, 1, 0, 0, 2, 0, 1, 1, 0],
   ['Μ2', 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 2, 0],
   ['M3', 1, 0, 2, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 2, 1, 0, 0, 0, 1, 1, 0, 2, 1, 0],
   ['M4', 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 2, 0, 0, 1, 0, 1, 0, 0, 0, 2, 0, 0, 0], 
   ['M5', 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 0, 2, 0, 1, 0, 0, 1, 0],
   ['M6', 0, 0, 0, 0, 2, 0, 1, 1, 0, 1, 0, 4, 2, 1, 0, 1, 1, 0, 1, 1, 0, 1, 2, 0, 1],
   ['M7', 0, 0, 0, 2, 1, 0, 1, 0, 2, 0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 1, 0, 1, 0, 0],
   ['M8', 2, 0, 0, 0, 0, 2, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2],
   ['M9', 1, 0, 0, 0, 1, 0, 2, 0, 0, 2, 0, 1, 2, 0, 1, 0, 0, 1, 2, 0, 0, 0, 1, 1, 0],
   ['M10', 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 2, 1],
   ['M11', 0, 1, 0, 2, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 1, 2],
   ['M12', 0, 1, 0, 1, 1, 2, 1, 1, 0, 2, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0]

]

```  

Με τρόμο παρατηρείτε ότι η λίστα έχει προβλήματα! Υπάρχει γονότυπος με αριθμό 4 και ένας άλλος με αριθμό 5! Επίσης ο γενετικός τόπος ```'Μ11'``` έχει λιγότερους γονότυπους από ότι οι υπόλοιποι γενετικοί τόποι! 

Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρο θα είναι μία λίστα (με τη μορφή που έχουν οι λίστες pop_A, pop_B, pop_C). H συνάρτηση σας θα επιστρέφει:
* ```False``` αν όλοι οι γενετικοί τόποι δεν έχουν το ίδιο πλήθος από γονότυπους.
* ```False``` αν υπάρχει έστω και ένας γονότυπος του οποίου οι τιμές ΔΕΝ είναι 0,1,2
* ```True``` αν δεν ισχύει καμία από τις παραπάνω συνθήκες. 

Για παράδειγμα θα πρέπει:
```python
f(pop_A) # Επιστρέφει True
f(pop_B) # Επιστρέφει True
f(pop_C) # Επιστρέφει False
```

Λύση:
```python
def ask_38(pop):
    lengths = {len(x) for x in pop}
    if len(lengths) != 1:
        return False
    
    for mutation in pop:
        for sample in mutation[1:]:
            if not sample in [0,1,2]:
                return False
            
    return True

```

### Άσκηση 39
Αφού επικοινωνείτε με τον συνάδελφό σας, του καταδεικνύετε τα λάθη που έχει κάνει! Ο συνάδελφος σας ζητάει συγγνώμη και σας στέλνει διορθωμένη τη λίστα. Η νέα λίστα είναι η εξής:

```python
pop_D = [
    ['M1', 'M2', 'M3', 'M4', 'M5', 'M6', 'M7', 'M8', 'M9', 'M10'], 
    [0, 2, 0, 0, 1, 1, 1, 0, 1, 0], 
    [1, 1, 1, 0, 0, 0, 0, 0, 0, 1], 
    [0, 0, 2, 0, 1, 2, 0, 0, 0, 1], 
    [0, 0, 0, 2, 2, 0, 0, 0, 0, 0], 
    [0, 0, 0, 2, 1, 0, 1, 0, 0, 0], 
    [1, 2, 0, 0, 0, 2, 0, 0, 2, 0], 
    [0, 1, 0, 0, 0, 1, 0, 0, 0, 0], 
    [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], 
    [1, 2, 0, 0, 0, 0, 1, 0, 0, 0], 
    [0, 1, 0, 1, 0, 0, 1, 0, 0, 2], 
    [0, 0, 0, 1, 0, 0, 0, 0, 0, 1], 
    [1, 1, 2, 0, 2, 0, 1, 0, 0, 0], 
    [0, 1, 2, 0, 2, 1, 1, 0, 0, 2], 
    [0, 0, 1, 0, 0, 1, 2, 1, 0, 2], 
    [0, 0, 1, 0, 2, 1, 0, 1, 1, 0], 
    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0], 
    [0, 0, 1, 0, 0, 1, 1, 0, 1, 1], 
    [0, 0, 0, 0, 2, 2, 0, 2, 0, 0], 
    [1, 1, 0, 1, 1, 0, 1, 0, 1, 0], 
    [1, 0, 0, 2, 1, 1, 0, 1, 2, 2], 
    [1, 2, 0, 1, 0, 1, 0, 0, 1, 0], 
    [0, 0, 1, 0, 1, 1, 0, 1, 0, 0], 
    [0, 0, 2, 0, 2, 0, 0, 0, 1, 0], 
    [0, 1, 0, 1, 2, 0, 1, 0, 1, 0], 
    [0, 0, 2, 1, 1, 0, 0, 2, 1, 0],
]
```

Πάλι παρατηρείτε ότι κάτι δεν πάει καλά.. Παίρνετε τηλέφωνο τον συνάδελφο και σας εξηγεί ότι η νέα λίστα έχει σε κάθε υπολίστα έναν άνθρωπο. Η πρώτη υπολίστα έχει τα ονόματα των γενετικών τόπων. Η 2η έχει τους γονότυπους για τον 1ο άνθρωπο, η 3η για τον δεύτερο, η 4η για τον τρίτο κτλ. Για παράδειγμα η δεύτερη υπολίστα: ```[0, 2, 0, 0, 1, 1, 1, 0, 1, 0]``` περιέχει τους γονότυπους για τον 1ο άνθρωπο. Οπότε ο 1ος άνθρωπος στον γενετικό τόπο ```Μ1``` έχει γονότυπο 0, στον γενετικό τόπο ```Μ2``` έχει γονότυπο 2, στον γενετικό τόπο ```Μ3``` έχει γονότυπο 0 κτλ.. 

Εξηγείτε στον συνάδελφο ότι οι αλγόριθμοί σας δέχονται λίστες με διαφορετική διάταξη. Ο συνάδελφός σας όμως δηλώνει ότι δεν έχει ιδέα πως να μετατρέψει τη λίστα στη μορφή που πρέπει γιατί δεν έχει παρακολουθήσει το μάθημα ΒΙΟΛ-494. Ευτυχώς εσείς έχετε! 

Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι μία λίστα όπως είναι η pop_D. Η συνάρτηση θα κάνει τους ανάλογους μετασχηματισμούς έτσι ώστε η λίστα να έχει τη μορφή που έχει η λίστα pop_A ή η λίστα pop_B. 

Για παράδειγμα: 
```python
f(pop_D) 
# Θα πρέπει να επιστρέφει τη λίστα:
[
    ['M1', 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], 
    ['M2', 2, 1, 0, 0, 0, 2, 1, 0, 2, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 1, 0], 
    ['M3', 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 1, 0, 1, 0, 0, 0, 0, 1, 2, 0, 2], 
    ['M4', 0, 0, 0, 2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 0, 0, 1, 1], 
    ['M5', 1, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0, 2, 2, 0, 2, 0, 0, 2, 1, 1, 0, 1, 2, 2, 1], 
    ['M6', 1, 0, 2, 0, 0, 2, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 2, 0, 1, 1, 1, 0, 0, 0], 
    ['M7', 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 2, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0], 
    ['M8', 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 1, 0, 1, 0, 0, 2], 
    ['M9', 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 2, 1, 0, 1, 1, 1], 
    ['M10', 0, 1, 1, 0, 0, 0, 0, 0, 0, 2, 1, 0, 2, 2, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0],
]

```

Λύση:
```python
def ask_39(pop):
    ret = []
    
    samples = len(pop)-1
    mutations = len(pop[0])
    for mutation in range(mutations):
        new_line = [pop[0][mutation]]
        for sample in range(samples):
            new_line.append(pop[1+sample][mutation])
            
        ret.append(new_line)
        
    return ret
```

### Άσκηση 40 
Η λίστα:
```python
genes = ['Gene_1', 'Gene_2', 'Gene_3', 'Gene_4', 'Gene_5', 'Gene_6', 'Gene_7', 'Gene_8', 'Gene_9', 'Gene_10']
```
Περιέχει τα ονόματα από 10 γονίδια.

Η λίστα:
```python
sizes = [2957, 8379, 9365, 5377, 9243, 5636, 4984, 9238, 6779, 7745]
```
Περιέχει το μέγεθός τους. 

H λίστα:
```python
cancer = [True, True, True, True, True, True, True, False, True, False]
```
περιέχει το αν εμπλέκονται σε μελέτες με καρκίνο (True) ή όχι (False).

Φτιάξτε μία συνάρτηση η οποία θα παίρνει 3 παραμέτρους. Και οι τρεις παράμετροι θα είναι λίστες με το ίδιο μέγεθος όπως οι λίστες ```genes```, ```sizes``` και ```cancer```. Η συνάρτηση θα επιστρέφει μία λίστα με τους αριθμούς από τα ονόματα των γονιδίων που εμπλέκονται στον καρκίνο και το μέγεθός τους είναι μεγαλύτερο από 5000. Για παράδειγμα:

```python
f(genes, sizes, cancer) # Επιστρέφει [2, 3, 4, 5, 6, 9]
```

Λύση:
```python
genes = ['Gene_1', 'Gene_2', 'Gene_3', 'Gene_4', 'Gene_5', 'Gene_6', 'Gene_7', 'Gene_8', 'Gene_9', 'Gene_10']
sizes = [2957, 8379, 9365, 5377, 9243, 5636, 4984, 9238, 6779, 7745]
cancer = [True, True, True, True, True, True, True, False, True, False]

def ask_40(genes, sizes, cancer):
    
    ret = []
    for g,s,c in zip(genes, sizes, cancer):
        if s<5000:
            continue
            
        if not c:
            continue
            
        ret.append(int(g[g.index('_')+1:]))
        
    return ret

ask_40(genes, sizes, cancer)
```

**Κάποιες σημειώσεις για τις υπόλοιπες ασκήσεις**
* Απαγορεύεται να χρησιμοποιήσετε μεταβλήτές με το όνομα: max, min, sum, type, id, str, chr, int, list, dict, tuple, set. Αυτά είναι ονόματα συναρτήσεων της python. Αν και η python αφήνει τη χρήση τους (κακώς..) σαν ονόματα μεταβλητών, αυτό έχει τη συνέπεια ότι μετά ΔΕΝ μπορείτε να τις χρησιμοποιήσετε. Δοκιμάστε:

```python
print (min([4,5,3])) #  Δουλεύει κανονικά 
min=5
print (min([4,5,3])) # Ουπς !
```

* Απαγορεύεται να χρησιμοποιήσετε μεταβλητή που ΔΕΝ ((έχει οριστεί στη συνάρτηση που ανήκει) 'Η (είναι παράμετρος της συνάρτησης)). Και αυτό σας αφήνει η python να το κάνετε, αλλά ειδικά σε αρχάριους προγραμματιστές δημιουργεί σύγχηση όσον αφορά τι πρέπει να βάλετε σε μία συνάρτηση και τι όχι. Για παράδειγμα: Μία συνάρτηση η οποία επιστρέφει αν o τελευταίος χαρακτήρας ενός string είναι αριθμός: 

Λάθος:
```python
a = 'asdfasdf3'
last = a[-1]

def f(x):
    is_it = last.is_digit() # To last έχει οριστεί έξω από τη συνάρτηση. Επίσης τι το κάνουμε το x της παραμέτρου;
    return is_it

```

Σωστό:
```python
def f(x):
    last = x[-1]
    is_it = last.is_digit()
    return is_it
```

Παρόλα αυτά εννοείται ότι επιτρέπεται να χρησιμοποιήσουμε συναρτήσεις που έχουν οριστεί έξω από τη συνάρτησή μας. 

### Άσκηση 41
Φτιάξτε μία συνάρτηση η οποία να παίρνει δύο παράμετρους. Οι παράμετροι είναι και οι δύο dictionaries, τα Α και το Β. Η συνάρτηση θα πρέπει να επιστρέφει ένα νέο dictionary το οποίο θα έχει τα κλειδιά του Α που δεν υπάρχουν στο Β και τα κλειδιά του Β που δεν υπάρχουν στο Α, με τις αντίστοιχες τιμές τους. Για παράδειγμα:

```python
A = {
    'kwstas': 1,
    'george': 2,
    'elenh': 3,
}

B = {
    'mitsos': 2,
    'kwstas': 3,
    'elenh': 1,
}


f(A,B) 
# Επιστρέφει:

{
    'george': 2,
    'mitsos': 2,
}
# Το "kwstas" και το "mitsos" υπάρχουν και στα δύο dictionaries (A και Β) για αυτό δεν 
# υπάρχουν στο dictionary που επέστρεψε η συνάρτηση.
``` 

Λύση:
```python
def f(A,B):
    ret = {}
    for x in A:
        if not x in B:
            ret[x]=A[x]
            
    for x in B:
        if not x in A:
            ret[x]=B[x]
            
    return ret
```

### Άσκηση 42
Φτιάξτε μία συνάρτηση η οποία να παίρνει δύο παράμετρους. Οι παράμετροι είναι και οι δύο dictionaries, τα Α και το Β. Τα dictionaries είναι τέτοια που οι τιμές τους είναι ακέραιοι. Η συνάρτηση θα πρέπει να επιστρέφει ένα νέο dictionary το οποία θα πρέπει να έχει ΜΟΝΟ τα κλειδιά που ανήκουν και στο Α και στο Β. Η τιμή του κάθε κλειδιού θα είναι ο μέσος όρος των τιμών αυτού του κλειδιού στα dictionary Α και Β. Για παράδειγμα:

```python
A = {
    'kwstas': 1,
    'george': 2,
    'elenh': 3,
}

B = {
    'mitsos': 2,
    'kwstas': 3,
    'elenh': 2,
}


f(A,B)
# Επιστρέφει:
{
    'kwstas': 2.0, # (1+3)/2
    'elenh': 2.5 # (2+3)/2
}



```


Λύση:
```python

def f(A,B):
    
    common_keys = set(A.keys()) & set(B.keys())
    
    return {x: (A[x]+B[x])/2 for x in common_keys}
```

### Άσκηση 43
Η λίστα:
```python
genes = ['Gene_1', 'Gene_2', 'Gene_3', 'Gene_4', 'Gene_5', 'Gene_6', 'Gene_7', 'Gene_8', 'Gene_9', 'Gene_10']
```
Περιέχει τα ονόματα από 10 γονίδια.

Η λίστα:
```python
sizes = [2957, 8379, 9365, 5377, 9243, 5636, 4984, 9238, 6779, 7745]
```
Περιέχει το μέγεθός τους. 

H λίστα:
```python
cancer = [True, True, True, True, True, True, True, False, True, False]
```
περιέχει το αν εμπλέκονται σε μελέτες με καρκίνο (True) ή όχι (False).

Φτιάξτε μία συνάρτηση η οποία θα παίρνει 3 παραμέτρους. Και οι τρεις παράμετροι θα είναι λίστες με το ίδιο μέγεθος όπως οι λίστες ```genes```, ```sizes``` και ```cancer```. Η συνάρτηση θα επιστρέφει ένα dictionary όπου:
* τα κλειδιά θα είναι τα genes
* Οι τιμές θα είναι ένα dictionary με τα εξής ζευγάρια κλειδί/τιμή:
   * 'size': περιέχει τις τιμές του sizes
   * 'cancer': περιέχει τις τιμές του cancer 

Για παράδειγμα:
```python
genes = ['Gene_1', 'Gene_2', 'Gene_3', 'Gene_4', 'Gene_5', 'Gene_6', 'Gene_7', 'Gene_8', 'Gene_9', 'Gene_10']
sizes = [2957, 8379, 9365, 5377, 9243, 5636, 4984, 9238, 6779, 7745]
cancer = [True, True, True, True, True, True, True, False, True, False]

f(genes, sizes, cancer) 
# Επιστρέφει:
{
    'Gene_1': {'size': 2957, 'cancer': True},
    'Gene_2': {'size': 8379, 'cancer': True},
    ...
    'Gene_10': {'size': 7745, 'cancer': False},
}
```

Λύση:
```python
def f(genes, sizes, cancer):
    
    return {
        g:{'size': s, 'cancer': c}
        for g,s,c in zip(genes, sizes, cancer)
    }
```

### Άσκηση 44
Φτιάξτε μία συνάρτηση η οποία θα κάνει το αντίθετο από ότι η άσκηση 43. Η συνάρτηση θα δέχεται μία παράμετρο. Η παράμετρος θα είναι ένα dictionary όπως αυτό που επιστρέφει η άσκηση 43. Η συνάρτηση θα επιστρέφει τρεις λίστες:
* Η πρώτη θα είναι τα κλειδιά του dictionary της παραμέτρου.
* Η δεύτερη θα είναι η τιμή του κλειδιού "size", της κάθε τιμής του dictionary της παραμέτρου.
* Η τρίτη θα είναι η τιμή του κλειδιού "cancer", της κάθε τιμής του dictionary της παραμέτρου.

Παράδειγμα:
```python
A = {
    'Gene_1': {'size': 2957, 'cancer': True},
    'Gene_2': {'size': 8379, 'cancer': True},
    'Gene_10': {'size': 7745, 'cancer': False},
}

f(A)

k,l,m  = f(A)

print (k) # τυπώνει: ['Gene_1', 'Gene_2', 'Gene_10']
print (l) # τυπώνει [2957, 8379, 7745]
print (m) # τυπώνει [true, True, False]

```

Λύση:
```python
def f(A):
    genes = []
    sizes = []
    cancer = []
    for k,v in A.items():
        genes.append(k)
        sizes.append(v['size'])
        cancer.append(v['cancer'])
        
    return genes, sizes, cancer
```

### Άσκηση 45 
Το [MESH](https://en.wikipedia.org/wiki/Medical_Subject_Headings) είναι ένα λεξικό το οποίο περιέχει ιατρικούς και βιολογικούς όρους. Το Mesh υπάρχει από τη δεκαετία του 1960, και τα τελευταία 10 χρόνια περίπου είναι διαθέσιμο μόνο από το διαδίκτυο. Μία εγγραφή στο MESH είναι ένα string όπως το παρακάτω:

```python

MESH_record = '''
RECTYPE = D
MH = Calcimycin
AQ = AA AD AE AG AI AN BI BL CF CH CL CS EC HI IM IP ME PD PK PO RE SD ST TO TU UR
ENTRY = A-23187|T109|T195|LAB|NRW|NLM (1991)|900308|abbcdef
ENTRY = A23187|T109|T195|LAB|NRW|UNK (19XX)|741111|abbcdef
ENTRY = Antibiotic A23187|T109|T195|NON|NRW|NLM (1991)|900308|abbcdef
ENTRY = A 23187
ENTRY = A23187, Antibiotic
MN = D03.633.100.221.173
PA = Anti-Bacterial Agents
PA = Calcium Ionophores
MH_TH = FDA SRS (2014)
MH_TH = NLM (1975)
ST = T109
ST = T195
N1 = 4-Benzoxazolecarboxylic acid, 5-(methylamino)-2-((3,9,11-trimethyl-8-(1-methyl-2-oxo-2-(1H-pyrrol-2-yl)ethyl)-1,7-dioxaspiro(5.5)undec-2-yl)methyl)-, (6S-(6alpha(2S*,3S*),8beta(R*),9beta,11alpha))-
RN = 37H9VM9WZL
RR = 52665-69-7 (Calcimycin)
PI = Antibiotics (1973-1974)
PI = Carboxylic Acids (1973-1974)
MS = An ionophorous, polyether antibiotic from Streptomyces chartreusensis. It binds and transports CALCIUM and other divalent cations across membranes and uncouples oxidative phosphorylation while inhibiting ATPase of rat liver mitochondria. The substance is used mostly as a biochemical tool to study the role of divalent cations in various biological systems.
OL = use CALCIMYCIN to search A 23187 1975-90
PM = 91; was A 23187 1975-90 (see under ANTIBIOTICS 1975-83)
HN = 91(75); was A 23187 1975-90 (see under ANTIBIOTICS 1975-83)
MR = 20160527
DA = 19741119
DC = 1
DX = 19840101
UI = D000001
'''

```

Παρατηρούμε ότι αυτό το string έχει πολλές γραμμές. Κάθε γραμμή αρχίζει με το όνομα ενός πεδίου. Στη συνέχεια υπάρχει ένα ``` = ``` και στη συνέχεια η τιμή αυτού του πεδίου.

Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι ένα string το οποίο θα αναπαριστάει μία εγγραφή στη MESH (όπως το παράδειγμα παραπάνω). Η συνάρτηση θα επιστρέφει ένα dictionary. Τα κλειδιά του dictionary θα είναι τα ονόματα των πεδίων της εγγραφής και οι τιμές του dictionary θα είναι οι τιμές αυτών των πεδίων. Για παράδειγμα:

```python
f(A)
# Επιστρέφει:

{
     'RECTYPE': 'D',
     'MH': 'Calcimycin',
     'AQ': 'AA AD AE AG AI AN BI BL CF CH CL CS EC HI IM IP ME PD PK PO RE SD ST TO TU UR',
     'ENTRY': 'A23187, Antibiotic',
     'MN': 'D03.633.100.221.173',
     'PA': 'Calcium Ionophores',
     'MH_TH': 'NLM (1975)',
     'ST': 'T195',
     'N1': '4-Benzoxazolecarboxylic acid, 5-(methylamino)-2-((3,9,11-trimethyl-8-(1-methyl-2-oxo-2-(1H-pyrrol-2-yl)ethyl)-1,7-dioxaspiro(5.5)undec-2-yl)methyl)-, (6S-(6alpha(2S*,3S*),8beta(R*),9beta,11alpha))-',
     'RN': '37H9VM9WZL',
     'RR': '52665-69-7 (Calcimycin)',
     'PI': 'Carboxylic Acids (1973-1974)',
     'MS': 'An ionophorous, polyether antibiotic from Streptomyces chartreusensis. It binds and transports CALCIUM and other divalent cations across membranes and uncouples oxidative phosphorylation while inhibiting ATPase of rat liver mitochondria. The substance is used mostly as a biochemical tool to study the role of divalent cations in various biological systems.',
     'OL': 'use CALCIMYCIN to search A 23187 1975-90',
     'PM': '91; was A 23187 1975-90 (see under ANTIBIOTICS 1975-83)',
     'HN': '91(75); was A 23187 1975-90 (see under ANTIBIOTICS 1975-83)',
     'MR': '20160527',
     'DA': '19741119',
     'DC': '1',
     'DX': '19840101',
     'UI': 'D000001'
 }

```

Λύση:
```python
def f(A):
    
    ret = {}
    for x in A.split('\n'):
        if not x.strip():
            continue
            
        eq_pos = x.index('=')
        first_part = x[:eq_pos].strip()
        second_part= x[eq_pos+1:].strip()
        
        ret[first_part] = second_part
        
    return ret
```

### Άσκηση 46

Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι ένα θετικός ακέραιος αριθμός. Η συνάρτηση θα επιστρέφει τον επόμενο πρώτο αριθμό ο οποίος είναι μεγαλύτερος από τη παράμετρο. Για παράδειγμα:

```python
f(10) # Επιστρέφει 11
f(11) # Επιστρέφει 13
f(15) # Επιστρέφει 17
```

Λύση:
```python
def f(n):
    test = n+1
    while True:
        for i in range(2,test):
            if test%i == 0:
                break
        else:
            return test
        
        test += 1
```

### Άσκηση 47
Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι ένας θετικός ακέραιος αριθμός. Η συνάρτηση θα επιστρέψει τον μεγαλύτερο πρώτο αριθμό ο οποίος είναι μικρότερος από τη παράμετρο. Για παράδειγμα:

```python
f(10) # Επιστρέφει 7
f(100) # Eπιστρέφει 97
``` 

Λύση:
```python
def f(n):
    test = n-1
    while True:
        for i in range(2,test):
            if test%i == 0:
                break
        else:
            return test
        
        test -= 1
```


### Άσκηση 48
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα επιστρέφει την απάντηση στο παρακάτω ερώτημα. Ας υποθέσουμε ότι έχουμε 1000 ευρώ και κάθε μήνα ξοδεύουμε το 10% του ποσού που έχουμε. Μετά από πόσους μήνες το ποσό που θα έχει μείνει θα είναι λιγότερο από 100 ευρώ;


Λύση:
```python
def f():
    remaining = 1000
    months = 0
    while remaining>100:
        remaining -= 0.1*remaining
        months += 1
        
    return months
```

### Άσκηση 49
Φτιάξτε μία συνάρτηση με το όνομα ```fact``` η οποία θα δέχεται μία παράμετρο. Η παράμετρος θα είναι ένας θετικός ακέραιος αριθμός. Η συνάρτηση θα επιστρέφει το παραγοντικό του αριθμού αυτού. Το παραγοντικό ενός αριθμού ```N```, συμβολίζεται με ```Ν!``` και είναι ίσο με το γινόμενο: ```1 * 2 * .. * Ν-1 * Ν```.

Ο [αριθμός e](https://en.wikipedia.org/wiki/E_%28mathematical_constant%29) είναι ίσος με 2.718281828459...  Επίσης γνωρίζουμε ότι ο αριθμός αυτό μπορεί να προσεγγιστεί με την παρακάτω σειρά:

![img](https://i.imgur.com/I3mS3Hu.png)

Όσο περισσότερους όρους βάλουμε σε αυτή τη σειρά, τόσο καλύτερη προσέγγιση του e θα κάνουμε. Φτιάξτε λοιπόν μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα υπολογίζει προσεγγιστικά και θα επιστρέφει το ```e``` χρησιμοποιώντας τον παραπάνω μαθηματικό τύπο. Για τον υπολογισμό του e, προσθέστε όσους όρους χρειαστούν μέχρι ο τελευταίος όρος που θα προσθέσετε να γίνει μικρότερος από 0.0001. Συνίσταται να χρησιμοποιήσετε τη συνάρτηση ```fact```. 

Λύση:
```python
def fact(n):
    if n == 0:
        return 1
    
    ret = 1
    for i in range(2,n+1):
        ret *= i
        
    return ret

def f():
    e = 1
    n = 1
    term = 1
    
    while term>0.0001:
        term = 1/fact(n)
        e += term
        n += 1
        
    return e
```

### Άσκηση 50
Δίνεται η παρακάτω συνάρτηση:

```python
import requests

def get_disease_gene_names(disease):
    r = requests.get(f'http://mygene.info/v3/query?q={disease}&fields=symbol&size=1000&species=human')
    j = r.json()

    return {x['symbol'] for x in j['hits']}
```

Αυτή η συνάρτηση παίρνει σαν όρισμα ένα string το οποίο αναπαριστάει έναν φαινότυπο (ασθένεια ή μη) ή μία βιολογική λειτουργία. Η συνάρτηση επιστρέφει ένα σύνολο από γονίδια τα οποία έχουν συσχετιστεί με αυτό το string. 

Φτιάξτε μία συνάρτηση η οποία δεν παίρνει κανένα όρισμα. Η συνάρτηση θα πρέπει να επιστρέφει ένα **σύνολο** με τα γονίδια τα οποία: Εμπλέκονται στη παχυσαρκία (```'obesity'```) KAI στον μεταβολισμό (```'metabolism'```) αλλά δεν έχουν συσχετιστεί με κάποιο λιπίδιο (```'lipids'```).


Λύση:
```python
def f():
    obesity = get_disease_gene_names('obesity')
    metabolism = get_disease_gene_names('metabolism')
    lipids = get_disease_gene_names('lipids')
    
    return (obesity & metabolism) - lipids
```

### Άσκηση 51
Δίνεται η παρακάτω συνάρτηση:

```python
import requests
def get_pi_1M():
    r = requests.get('https://www.angio.net/pi/digits/pi1000000.txt')
    return r.text
```

Αυτή η συνάρτηση επιστρέφει ένα string το οποίο περιέχει το π (3.14159...) στις πρώτες 1.000.000 θέσεις. Γράψτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα επιστρέφει τη θέση πάνω στο π όπου ο αριθμός 7 γίνεται για πρώτη φορά ο πιο κοινός αριθμός του π. 

Για παράδειγμα: τα πρώτα 100 ψηφία του π είναι:
```
3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
```

Ας μετρήσουμε πόσα ψηφία υπάρχουν για κάθε θέση του π:


```
Θέση 1
3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
|
3:1 φορά
Ποιο κοινό ψηφίο: 3
```
```
Θέση 2
3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
  |
  3:1 φορά
  1:1 φορά
Ποιο κοινό ψηφίο: Κανένα (ισοπαλία μεταξύ 3 και 1)
```

```
Θέση 3:
3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
   |
   3:1 φορά
   1:1 φορά
   4:1 φορά
Ποιο κοινό ψηφίο: Κανένα (ισοπαλία μεταξύ 3, 1 και 4)
```

```
Θέση 4:
3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
    |
    3:1 φορά
    1:2 φορές
    4:1 φορά
Ποιο κοινό ψηφίο: το 1
```

Εδώ παρατηρούμε ότι στη θέση 4, το 1 γίνεται το πιο κοινό ψηφίο του π για πρώτη φορά!

Ποια λοιπόν είναι η αντίστοιχη θέση για το 7;

Μπορείτε να επιστρέψετε τη θέση μετρώντας είτε ξεκινώντας από το 0, είτε από το 1. Ό,τι σας βολεύει. 

Λύση:
```python
from collections import defaultdict
def f():
    
    PI = get_pi_1M()

    counters = defaultdict(int)
    maximum_count = 1

    for digit_index, digit in enumerate(PI):
        counters[digit] += 1
        
        if counters[digit] > maximum_count:
            maximum_count = counters[digit]
            maximum_digit = digit
            
            if maximum_digit == '7':
                break
                
    return digit_index
```

### Άσκηση 52
Φτιάξτε μία συνάρτηση η οποία παίρνει σαν παράμετρο έναν ακέραιο αριθμό. Η συνάρτηση δημιουργεί ένα αρχείο με το όνομα factors.txt. Το αρχείο περιέχει τόσες γραμμές όσες ο αριθμός της παραμέτρου. Η i-οστή γραμμή περιέχει όλους τους παράγοντες του i από το 1 μέχρι και το i διαχωρισμένοι με κόμματα. Οι παράγοντες ενός αριθμού είναι οι αριθμοί που τον διαρούν τέλεια. H συνάρτηση δεν επιστρέφει τίποτα. Για παράδειγμα:

```python
f(10)

# Δημιουργεί το αρχείο factors.txt το οποίο θα πρέπει να μπορώ να το τυπωσω με:
with open('factors.txt') as f:
    data = f.read()

print (data)
# θα πρέπει να τυπώνει:
'''
1
1,2
1,3
1,2,4
1,5
1,2,3,6
1,7,
1,2,4,8
1,3,9
1,2,5,10
'''
```

Λύση:
```python
def f(N):
    
    with open('factors.txt', 'w') as f:
        for i in range(1,N+1):
            factors = [str(j) for j in range(1,i+1) if i%j==0]
            f.write(','.join(factors) + '\n')
```

### Άσκηση 53
Γράψτε κώδικα python τέτοιον ώστε όταν γράφω:

```python
f()()[0]()
```

Να επιστρέφεται η τιμή: ```"Μήτσος"```

Λύση 1
```python
def f():
    def g():
        def h():
            return 'Μήτσος'
        return [h]
    return g
```

Λύση 2
```python
f = lambda : lambda : [lambda : 'Μήτσος']
```

### Άσκηση 54
Σε αυτό το site: https://ftp.ncbi.nlm.nih.gov/gene/DATA/GENE_INFO/Mammalia/ θα βρείτε το αρχείο: Homo_sapiens.gene_info.gz. Το αρχείο αυτό μπορείτε να το κατεβάσετε και απευθείας με αυτό το link: https://ftp.ncbi.nlm.nih.gov/gene/DATA/GENE_INFO/Mammalia/Homo_sapiens.gene_info.gz . Το αρχείο αυτό είναι συμπιεσμένο οπότε θα πρέπει και να το αποσυμπιέσετε. Το αποσυμπιεσμένο αρχείο ονομάζεται: ```Homo_sapiens.gene_info```. To αρχείο είναι tab delimited (οι στήλες δηλαδή είναι χωρισμένες με τον χαρακτήρα tab) και περιέχει διάφορες πληροφορίες για τα γονίδια στο ανθρώπινο γονιδίωμα. Η πρώτη γραμμή του αρχείου περιέχει την επικεφαλίδα (header) η οποία περιέχει τους τίτλους των στηλών. Η επικεφαλίδα είναι:

```text
#tax_id GeneID  Symbol  LocusTag    Synonyms    dbXrefs chromosome  map_location    description type_of_gene    Symbol_from_nomenclature_authority  Full_name_from_nomenclature_authority   Nomenclature_status Other_designations  Modification_date   Feature_type
``` 

Το αρχείο μπορείτε να το ανοίξετε και από το excel (ή από το Google sheets). Μπορείτε να google-άρετε: "how to open tab delimited file in excel" για να βρείτε πως γίνεται αυτό.

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα string. Η παράμετρος αυτή θα είναι το όνομα ενός αρχείου το οποίο θα έχει την ίδια δομή όπως το ```Homo_sapiens.gene_info```. Η συνάρτηση θα πρέπει να επιστρέφει ένα dictionary. Τα keys του dictionary θα είναι οι τιμές στη στήλη με το όνομα: ```Symbol```. Τα values του dictionary θα πρέπει να είναι οι αντίστοιχες τιμές στη στήλη: ```description```. 

Για παράδειγμα θα πρέπε να μπορώ να γράφω:
```python
d = f('Homo_sapiens.gene_info')
print (d['A1BG']) # Τυπώνει: "alpha-1-B glycoprotein" 
print (d['GLP1R']) # Τυπώνρι: "glucagon like peptide 1 receptor"
```

Λύση:
```python
def f(filename):
    
    ret = {}
    
    with open(filename) as f:
        header = f.readline().strip().split('\t')
        symbol_col = header.index('Symbol')
        description_col = header.index('description')
        
        for l in f:
            ls = l.strip().split('\t')
            symbol = ls[symbol_col]
            description = ls[description_col]
            
            ret[symbol] = description
            
    return ret
```

### Άσκηση 55
Ας θεωρήσουμε πάλι το ίδιο αρχείο με την άσκηση 54. Η στήλη ```Synonyms``` του αρχείου περιέχει τα συνώνυμα για κάθε γονίδιο. Οι τιμές αυτής της στήλης είναι strings διαχωρισμένα με τον χαρακτήρα ```|```. Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα string. Η παράμετρος αυτή θα είναι το όνομα ενός αρχείου το οποίο θα έχει την ίδια δομή όπως το ```Homo_sapiens.gene_info```. Η συνάρτηση θα πρέπει να επιστρέφει ένα dictionary. Τα keys του dictionary θα είναι οι τιμές στη στήλη με το όνομα: ```Symbol```. Τα values του dictionary θα πρέπει να είναι μία λίστα με όλα τα συνώνυμα του γονιδίου όπως υπάρχουν στη στήλη ```Synonyms```. Για παράδειγμα θα πρέπει να μπορώ να γράφω:

```python
d = f('Homo_sapiens.gene_info')
print (d['A1BG']) # Τυπώνει: ['A1B', 'ABG', 'GAB', 'HYST2477']
print (d['HCN2']) # Τυπώνει: ['BCNG-2', 'BCNG2', 'HAC-1']
```

Λύση:
```python
def f(filename):
    
    ret = {}
    
    with open(filename) as f:
        header = f.readline().strip().split('\t')
        symbol_col = header.index('Symbol')
        synonyms_col = header.index('Synonyms')
        
        for l in f:
            ls = l.strip().split('\t')
            symbol = ls[symbol_col]
            synonyms = ls[synonyms_col].split('|')
            
            ret[symbol] = synonyms
            
    return ret
```

### Άσκηση 56
Aς θεωρήσουμε πάλι το ίδιο αρχείο με την άσκηση 54. Η στήλη ```chromosome``` περιέχει το χρωμόσωμα στο οποίο ανήκει το γονίδιο. Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 παράμετρους. Η πρώτη παράμετρος θα είναι ένα string με το όνομα filename, το οποίο θα είναι το όνομα ενός αρχείου το οποίο θα έχει την ίδια δομή με το ```Homo_sapiens.gene_info```. H δεύτερη παράμετρος με το όνομα chromosome θα είναι ένα string με το όνομα ενός χρωμοσώματος. Η συνάρτηση θα δημιουργεί ένα αρχείο με το όνομα: ```Homo_sapiens_CHROMOSOME.gene_info``` όπου το ```CHROMOSOME``` θα πρέπει να το αντικαταστήσετε με τη τιμή της παραμέτρου chromosome. Το περιεχόμενο του αρχείου θα είναι ακριβώς το ίδιο με αυτό του αρχείου filename αλλά θα περιέχει μόνο τα γονίδια που ανήκουν στο χρωμόσωμα της παραμέτρου. Η συνάρτηση θα πρέπει να επιστρέψει το όνομα του αρχείου που δημιούργησε. Για παράδειγμα:

```python
filename = f('Homo_sapiens.gene_info', '7')

# Ανοίγω το αρχείο που δημιούργησε και τυπώνω τις πρώτες 6 γραμμές
with open(filename) as f:
    for l_number, line in enumerate(f):
        print (line.strip('\n'))
        if l_number>=5:
            break

#To παραπάνω τυπώνει:
'''
#tax_id GeneID  Symbol  LocusTag    Synonyms    dbXrefs chromosome  map_location    description type_of_gene    Symbol_from_nomenclature_authority  Full_name_from_nomenclature_authority   Nomenclature_status Other_designations  Modification_date   Feature_type
9606    26  AOC1    -   ABP|ABP1|DAO|DAO1|KAO   MIM:104610|HGNC:HGNC:80|Ensembl:ENSG00000002726 7   7q36.1  amine oxidase copper containing 1   protein-coding  AOC1    amine oxidase copper containing 1   O   amiloride-sensitive amine oxidase [copper-containing]|amiloride binding protein 1 (amine oxidase (copper-containing))|amiloride-binding protein 1|amiloride-sensitive amine oxidase|amine oxidase copper domain-containing protein 1|diamine oxidase|histaminase|kidney amine oxidase   20210302    -
9606    43  ACHE    -   ACEE|ARACHE|N-ACHE|YT   MIM:100740|HGNC:HGNC:108|Ensembl:ENSG00000087085    7   7q22.1  acetylcholinesterase (Cartwright blood group)   protein-coding  ACHE    acetylcholinesterase (Cartwright blood group)   O   acetylcholinesterase|Yt blood group|acetylcholinesterase (Yt blood group)|apoptosis-related acetylcholinesterase    20210302    -
9606    60  ACTB    -   BRWS1|PS1TP5BP1 MIM:102630|HGNC:HGNC:132|Ensembl:ENSG00000075624    7   7p22.1  actin beta  protein-coding  ACTB    actin beta  O   actin, cytoplasmic 1|I(2)-actin|PS1TP5-binding protein 1|beta cytoskeletal actin    20210307    -
9606    107 ADCY1   -   AC1|DFNB44  MIM:103072|HGNC:HGNC:232|Ensembl:ENSG00000164742    7   7p12.3  adenylate cyclase 1 protein-coding  ADCY1   adenylate cyclase 1 O   adenylate cyclase type 1|3',5'-cyclic AMP synthetase|ATP pyrophosphate-lyase 1|Ca(2+)/calmodulin-activated adenylyl cyclase|adenyl cyclase|adenylate cyclase 1 (brain)|adenylate cyclase type I|adenylyl cyclase 1|adenylyl cyclase subtype 1   20210302    -
9606    117 ADCYAP1R1   -   PAC1|PAC1R|PACAPR|PACAPRI   MIM:102981|HGNC:HGNC:242|Ensembl:ENSG00000078549    7   7p14.3  ADCYAP receptor type I  protein-coding  ADCYAP1R1   ADCYAP receptor type I  O   pituitary adenylate cyclase-activating polypeptide type I receptor|PACAP receptor 1|PACAP type I receptor|PACAP-R1|adenylate cyclase activating polypeptide 1 (pituitary) receptor type I|pituitary adenylate cyclase activating polypeptide 1 receptor type I Hiphop|pituitary adenylate cyclase-activating polypeptide type 1 receptor    20210302    -
'''
```

* Προσοχή 1! Το νέο αρχείο θα πρέπει να έχει και την επικεφαλίδα (header) του filename.
* Προσοχή 2! Υπάρχει ένα γονίδιο του οποίοι η τιμή στη στήλη chromosome είναι: ```10|19|3```. Ανήκει δηλαδή σε τρία χρωμοσώματα! αγνοήστε το. Επίσης υπάρχουν 146 γονίδια τα οποία δεν έχουν τιμή στη στήλη chromosome (η τιμή είναι: ```-```), 66 γονίδια με χρωμόσωμα: ```'Un'```και 66 γονίδια με χρωμόσωμα: ```X|Y```. Αγνοήστε τα όλα αυτά.


Λύση:
```python
def ask_56(filename, chromosome):
    
    output_filename = f'Homo_sapiens_{chromosome}.gene_info'
    
    with open(filename) as f_in, open(output_filename, 'w') as f_out:
        header_line = f_in.readline()
        header = header_line.strip().split('\t')
        chromosome_col = header.index('chromosome')
        
        f_out.write(header_line)
                
        for l in f_in:
            ls = l.strip().split('\t')
            chromosome_val = ls[chromosome_col]
            
            if chromosome_val == chromosome:
                f_out.write(l)
                
    return output_filename
```

### Άσκηση 57
Φτιάξτε μία συνάρτηση με το όνομα ```ask_57_a``` η οποία θα παίρνει σαν παράμετρο ένα string. Η παράμετρος αυτή θα είναι το όνομα ενός αρχείου το οποίο θα έχει την ίδια δομή όπως το αρχείο ```Homo_sapiens.gene_info```. Η συνάρτηση θα χρησιμοποιεί την συνάρτηση της άσκησης 56 για να "σπάσει" το αρχείο σε πολλά αρχεία όπου το κάθε αρχείο θα έχει και από ένα χρωμόσωμα. Θεωρήστε μόνο τα χρωμοσώματα: 1,2,3,...,22,Χ,Υ,ΜΤ. Το χρωμόσωμα ενός αρχείο υπάρχει στη στήλη με το όνομα: ```chromosome```. Θα πρέπει δηλαδή η συνάρτηση να φτιάχνει τα αντίστοιχα αρχεία:  ```Homo_sapiens_1.gene_info```, ```Homo_sapiens_2.gene_info```, ... ```Homo_sapiens_22.gene_info```, ```Homo_sapiens_Χ.gene_info```, ```Homo_sapiens_Υ.gene_info```, ```Homo_sapiens_ΜΤ.gene_info```. H συνάρτηση θα επιστρέφει μία λίστα με τα αρχεία που δημιούργησε.

Φτιάξτε μία συνάρτηση με το όνομα ```ask_57_b``` η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι μία λίστα από strings. Κάθε strings θα είναι και το όνομα ενός αρχείου το οποίο θα έχει την ίδια δομή όπως το αρχείο ```Homo_sapiens.gene_info```. Η συνάρτηση θα ενώνει όλα τα αρχεία της λίστας της παραμέτρου σε ένα αρχείο. Το αρχείο θα σώζεται με όνομα: ```Homo_sapiens_MERGED.gene_info```. Αυτό το αρχείο θα πρέπει να έχει την ίδια δομή με το αρχείο ```Homo_sapiens.gene_info``` και τα γονίδια που περιέχει να είναι ταξινομήμα αλφαβητικά σύμφωνα με τη στήλη ```Symbol```. H συνάρτηση θα επιστρέφει το string: ```Homo_sapiens_MERGED.gene_info```. Θα πρέπει δηλαδή να μπορώ να κάνω:

```python
filenames = ask_57_a('Homo_sapiens.gene_info')
merged_filename = ask_57_b(filenames)

# Take all contents from original Homo_sapiens.gene_info
with open('Homo_sapiens.gene_info') as f:
    original_content = f.read()

# Take all contents from merged 
with open(merged_filename) as f:
    merged_content = f.read()


```

* Προσοχή! Υπάρχει ένα γονίδιο του οποίοι η τιμή στη στήλη chromosome είναι: ```10|19|3```. Ανήκει δηλαδή σε τρία χρωμοσώματα! αγνοήστε το. Επίσης υπάρχουν 146 γονίδια τα οποία δεν έχουν τιμή στη στήλη chromosome (η τιμή είναι: ```-```), 66 γονίδια με χρωμόσωμα: ```'Un'```και 66 γονίδια με χρωμόσωμα: ```X|Y```. Αγνοήστε τα όλα αυτά.


Λύση:
```python
def ask_57_a(filename):
    chromosomes = list(map(str, range(1,23)))
    chromosomes += ['X', 'Y', 'MT']
    
    ret = [ask_56(filename, chromosome) for chromosome in chromosomes]
    return ret

def ask_57_b(filenames):
    
    all_content=[]
    for filename in filenames:
        with open(filename) as f:
            header_line = f.readline()
            header = header_line.strip().split('\t')
            symbol_col = header.index('Symbol')
            
            for l in f:
                ls = l.strip().split('\t')
                symbol = ls[symbol_col]
                all_content.append((symbol, l))
                
    # sorting..
    all_content.sort()
    
    with open('Homo_sapiens_MERGED.gene_info', 'w') as f:
        f.write(header_line)
        for l in all_content:
            f.write(l[1])
            

```

### Άσκηση 58
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα string. Η παράμετρος αυτή θα είναι το όνομα ενός αρχείου το οποίο θα έχει την ίδια δομή όπως το αρχείο ```Homo_sapiens.gene_info```. Η συνάρτηση θα επιστρέφει μία λίστα με τα χρωμοσώματα ταξινομημένα από το μεγαλύτερο προς το μικρότερο ανάλογα με το πλήθος γονιδίων που έχουν. Για παράδειγμα:

```python
f('Homo_sapiens.gene_info') # Επιστρέφει τη λίστα: 

# Προσοχή το αρχείο Homo_sapiens.gene_info.gz αννανεώθηκε στις 2 Απριλίου. 
# Όσοι κατεβάσατε το αρχείο ΠΡΙΝ από αυτή την ημερομηνία, το σωστό αποτέλεσμα είναι:
['1', '2', '6', '3', '11', '7', '5', '19', '12', '17', '4', '9', 'X', '8', '10', '14', '16', '15', '13', '20', '22', '18', '21', 'Y', 'MT',] 

# Όσοι κατεβάσατε το αρχείο στις 2 Απριλίου ή μετά, το σωστό αποτέλεσμα είναι:
['1', '2', '6', '3', '11', '7', '5', '12', '19', '17', '4', '9', 'X', '8', '10', '14', '16', '15', '13', '20', '22', '18', '21', 'Y', '-', 'MT'

# Συμπέρασμα: στη βιολογία "τα πάντα ρει"...
```

* Προσοχή! Υπάρχει ένα γονίδιο του οποίοι η τιμή στη στήλη chromosome είναι: ```10|19|3```. Ανήκει δηλαδή σε τρία χρωμοσώματα! αγνοήστε το. Επίσης υπάρχουν 146 γονίδια τα οποία δεν έχουν τιμή στη στήλη chromosome (η τιμή είναι: ```-```), 66 γονίδια με χρωμόσωμα: ```'Un'```και 66 γονίδια με χρωμόσωμα: ```X|Y```. Αγνοήστε τα όλα αυτά.

Λύση:
```python
from collections import Counter

def ask_58(filename):
    
    accepted_chromosomes = list(map(str, range(1,23)))
    accepted_chromosomes += ['X', 'Y', 'MT']
    
    with open(filename) as f:
        header = f.readline().strip().split('\t')
        
        chromosome_col = header.index('chromosome')
        
        c = Counter(x.split('\t')[chromosome_col] for x in f)
        
    c_sorted = sorted(c, key=c.get, reverse=True)
    
    return [x for x in c_sorted if x in accepted_chromosomes]
```

### Άσκηση 59
Έστω ```d``` το dictionary που επιστρέφει η συνάρτηση της άσκησης 55 όταν τη τρέχουμε βάζοντας το αρχείο ```Homo_sapiens.gene_info``` σαν παράμετρο. Συμπληρώστε τη lambda συνάρτηση στη παρακάτω εντολή ώστε να επιστρέψει το γονίδιο το οποίο έχει το μεγαλύτερο (από άποψη μήκους ονόματος) συνώνυμο:

```python
d = ask_55('Homo_sapiens.gene_info')
max(d, key=lambda x: ...)

```

Στο μέιλ που θα στείλετε απλά βάλτε την παραπάνω εντολή με τις τελίτσες συμπληρωμένες.

Δίνεται ότι αυτό που θα πρέπει να επιστρέφει η παραπάνω εντολή είναι: ```'ARMCX5-GPRASP2'```. 

Πρέπει να επιστρέφει το γονίδιο, όχι το συνώνυμο του γονιδίου.

Λύση 1
```python
max(d, key=lambda x : max([len(x) for x in d[x]]))
```

Λύση 2
```python
max(d, key=lambda x: len(max(d[x], key=len)))
```

Λύση 3
```python
max(d, key=lambda x: max(map(len, d[x])) )
```

### Άσκηση 60
Μία ανάλυση που έγινε παρήγαγε ένα αρχείο το οποίο είχε το εξής περιεχόμενο:

```
ID  GENE    FoldChange
TC0100007038.hg.1   NECAP2  1.17
TC0100007063.hg.1   FAM231C; FAM231A    -1.04
TC0100007206.hg.1   CDA; CDB; CDC   -1.15
TC0100007207.hg.1   PINK1; MIR6084  1.1
```

Παρατηρούμε ότι η στήλη ```GENE``` μπορεί να έχει παραπάνω από ένα γονίδια διαχωρισμένα με τον χαρακτήρα ```';'```. Αυτό που θέλουμε είναι να μετασχηματίσουμε το αρχείο έτσι ώστε η στήλη GENE να έχει μόνο ένα γονίδιο. Οι γραμμές που έχουν παραπάνω από ένα γονίδιο θα πρέπει να γραφτούν τόσες φορές όσες τα γονίδια που περιέχουν. Κάθε γραμμή θα έχει και από ένα γονίδιο. Η τιμή στη στήλη ```ID``` και στη στήλη ```FoldChange``` θα πρέπει να παραμείνουν ίδιες. Επίσης οι στήλες χωρίζονται με τον χαρακτήρα tab (```'\t'```)

Φτιάξτε μία συνάρτηση η οποία θα παίρνει δύο παράμετρους. Και οι δύο θα είναι strings τα οποία θα είναι ονόματα αρχείων. Η συνάρτηση θα πρέπει να ανοίγει το αρχείο του οποίου το όνομα είναι η πρώτης παράμετρος, να το μετασχηματίζει όπως περιγράφηκε παραπάνω και να το σώζει στο όνομα του αρχείου της δεύτερης παράμετρου. Θα πρέπει δηλαδή να μπορώ να γράφω:


```python

contents = '''ID    GENE    FoldChange
TC0100007038.hg.1   NECAP2  1.17
TC0100007063.hg.1   FAM231C; FAM231A    -1.04
TC0100007206.hg.1   CDA; CDB; CDC   -1.15
TC0100007207.hg.1   PINK1; MIR6084  1.1
'''

with open('ask_60_input.txt', 'w') as f:
    f.write(contents)

f('ask_60_input.txt', 'ask_60_output.txt')

with open('ask_60_output.txt') as f:
    result = f.read()

print (result) 
#  Θα πρέπει να τυπώνει:
'''
ID  GENE    FoldChange
TC0100007038.hg.1   NECAP2  1.17
TC0100007063.hg.1   FAM231C -1.04
TC0100007063.hg.1   FAM231A -1.04
TC0100007206.hg.1   CDA -1.15
TC0100007206.hg.1   CDB -1.15
TC0100007206.hg.1   CDC -1.15
TC0100007207.hg.1   PINK1   1.1
TC0100007207.hg.1   MIR6084 1.1
'''
```

Λύση:
```python
def f(fn_inp, fn_outp):
    with open(fn_inp) as f_inp, open(fn_outp, 'w') as f_outp:
        header = f_inp.readline()
        f_outp.write(header)
        
        for l in f_inp:
            ls = l.strip().split('\t')
            genes = ls[1].split(';')
            for gene in genes:
                
                line = [ls[0], gene.strip(), ls[2]]
                f_outp.write('\t'.join(line) + '\n')
```

### Άσκηση 61
Φτιάξτε μία συνάρτηση με το όνομα ```ask_61``` η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα επιστρέφει:
* Το string "a" με πιθανότητα 14%
* To string "b" με πιθανότητα 47%
* To string "c" με πιθανότητα 39%

Δηλαδή κάθε φορά που τη καλεί κάποιος θα επιστρέφει είτε "a", είτε "b", είτε "c" σύμφωνα με τις παραπάνω πιθανότητες.

### Άσκηση 62
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα καλεί τη συνάρτηση ask_61 1.000.000 φορές και θα μετράει πόσες φορές επέστρεψε "a", πόσες φορές "b" και πόσες φορές "c". Θα επιστρέφει ένα dictionary του οποίου τα κλειδιά θα είναι τα "a", "b", "c" και τα values θα είναι οι αντίστοιχοι μετρητές τους. Για παράδειγμα:

```python
f() 
# Επιστρέφει ένα dictionary  με τιμές παραπλήσιες με αυτές:
{'b': 470283, 'c': 389550, 'a': 140167}
```

### Άσκηση 63
Ο παρακάτω κώδικας:

```python
from scipy.stats import nbinom
nbinom.pmf(10, 2, 1/6, 2) #  Επιστρέφει: 0.0581420098403444 
```

Επιστρέφει τη πιθανότητα να ρίξουμε 10 φορές ένα ζάρι και τη 10η φορά να έρθει για 2η φορά το 6. Ή αλλιώς τη πιθανότητα να έχουμε 2 φορές το 6 σε 10 ρίψεις του ζαριού και το 2ο εξάρι να είναι στη 10η ρίψη. 
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση "ρίχνει" 10 ζάρια 1.000.000 φορές και μετράει πόσες από αυτές τις φορές το τελευταίο ζάρι (10η ρίψη) ήταν η 2η φορά που ήρθε 6. Η συνάρτηση επιτρέφει τον αριθμό των επιτυχιών διαιρεμένο με το 1.000.000. Ή αλλιώς επιστρέφει τον λόγο των επιτυχιών προς τον συνολικό αριθμό των πειραμάτων. Για παράδειγμα:

```python
f() # Επιστρέφει έναν αριθμό που είναι κοντά στο 0.0581
```

* ΠΡΟΣΟΧΗ! Εσείς δεν χρειάζεται ούτε να εγκαταστήσετε scipy, ούτε να τρέξετε τη nbinom, ούτε να μάθετε τι κάνει. Τον κώδικα με την nbinom σας τον δίνω για να δείτε ποια είναι η σωστή απάντηση, και πως μπορείς να την υπολογίσεις χωρίς.. 1.000.000 επαναλήψεις! 

### Άσκηση 64

Δίνεται η παρακάτω φόρμουλα για τον υπολογισμό του π (3.14159...):

![img](https://i.imgur.com/ruurBAn.png)

Φτιάξτε έναν generator με το όνομα ```ask_64_a``` o οποίος δεν θα παίρνει κανένα όρισμα. O generator θα κάνει yield τους όρους του παραπάνω αθροίσματος. Θα πρέπει δηλαδή να μπορώ να γράψω:

```python
gen = ask_64_a()

print (next(gen)) # Τυπώνει: 0.3333333333333333  1/(1*3)

print (next(gen)) # Τυπώνει: 0.02857142857142857  1/(5*7)

print (next(gen)) # Τυπώνει: 0.010101010101010102  1/(9*11)

```

Φτιάξτε τη συνάρτηση ask_64_b η οποία παίρνει μία παράμετρο. Η παράμετρος είναι ένας ακέραιος αριθμός Ν. Η συνάρτηση υπολογίζει το άθροισμα των πρώτων Ν όρων των αριθμών που παράγει ο generator ```ask_64_a```. Στη συνέχεια υπολογίζει και επιστρέφει το γινόμενο αυτού του αθροίσματος με το 8. Για παράδειγμα θα πρέπει:

```python
ask_64_b(1000) # Επιστρέφει: 3.141092653621038 
```

### Άσκηση 65
Δίνεται ο παρακάτω generator:

```python
def g():
    a = 2054802212
    while a>100:
        a = (1103515245*a + 12345) % 2**31
        yield a
```

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση επιστρέφει το πλήθος των στοιχείων που παράγει η γεννήτρια g. Για να το κάνετε αυτό είναι υποχρεωτικό να χρησιμοποιήσετε τη [StopIteration](https://docs.python.org/3/library/exceptions.html#StopIteration).

Ένας άλλος τρόπος να περιγραφεί αυτό που ζητάει η άσκηση είναι: το πλήθος των στοιχείων που κάνει generate το ```g()``` μέχρι να "πετάξει" StopIteration.

Hint: Ο αριθμός που πρέπει να επιστρέφει η συνάρτηση είναι μεγαλύτερος από 4.000.000 και μικρότερος από 5.000.000  

### Άσκηση 66
Φτιάξτε μία συνάρτηση με το όνομα ```ask_66``` η οποία παίρνει δύο ορίσματα. Η συνάρτηση κάνει τους εξής ελέγχους:
* αν τουλάχιστον ένα από τα δύο ορίσματα δεν είναι int ή float, πετάει (raise) TypeError 
* αν τουλάχιστον ένα από τα δύο ορίσματα είναι αρνητικό αριθμός (<0), πετάει (raise) ValueError
* αν το άθροισμα των δύο αριθμών είναι μεγαλύτερο από το 1000, πετάει (raise) OverflowError  

Αν δεν συμβεί κάποιο exception η συνάρτηση επιστρέφει το άθροισμα των δύο παραμέτρων. 

Για παράδειγμα:

```python
f(3, "mitsos") # #Πετάει TypeError 

f(-3, 4) # Πετάει ValueError

f(400, 800) # Πετάει OverflowError

f(10,15) # Επιστρέφει 25
```

### Άσκηση 67
Δίνεται η παρακάτω συνάρτηση:

```python
import random

def test_ask_66():

    def rand_param():
        if random.random()<0.5:
            r = random.randint(1,1000)
            if random.random()<0.3:
                r /= 1
        else:
            r = "a"

        return r

    first = rand_param()
    second = rand_param()

    return ask_66(first, second)

```

Αυτή η συνάρτηση δημιουργεί δύο τυχαίες τιμές και τις χρησιμοποιεί σαν παράμετρους για να καλέσει τη συνάρτηση ```ask_66```. 

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα καλεί τη συνάρτηση ```test_ask_66``` 100.000 φορές. Η συνάρτηση θα επιτρέφει ένα dictionary με τα εξής κλειδιά / τιμές:

* Κλειδί: "Invalid Type" , Τιμή: Πόσες φορές "πέταξε" TypeError η ```test_ask_66```.
* Κλείδί: "Invalid Value", Τιμή: Πόσες φορές "πέταξε" ValueError η ```test_ask_66```.
* Κλειδί: "Overflow" , Τιμή: Πόσες φορές "πέταξε" OverflowError η ```test_ask_66```.
* Κλειδί: "ΟΚ" , Τιμή πόσες φορές ΔΕΝ πέταξε κάποιο Exception η ```test_ask_66```. 


### Άσκηση 68
Γράψτε κώδικα python τέτοιον ώστε όταν τον σώζω σε ένα αρχείο με το όνομα ```ask_68.py``` και μετά:

1. τρέχω στη γραμμή εντολών:
```bash
python ask_68.py 10 30 
```

Να τυπώνει ```40``` (το άθροισμα του 10 και του 30)

2. γράφω στο jupyter:
```python
from ask_68 import my_add

print (my_add(10,30)) # Τυπώνει 40 
```

Να τυπώνει τον αριθμό ```40``` (το άθροισμα του 10 και του 30)

### Άσκηση 69

Σε αυτό το link: https://www.dropbox.com/s/brqaopz8g2vs0ox/covid_fasta.gz?dl=1 υπάρχει ένα αρχείο το οποίο περιέχει 8.728 ακολουθίες από διάφορα strains του ιού COVID19 που έχουν συλλεχθεί από διάφορα μέρη. Το αρχείο είναι σε φορμά [FASTA](https://en.wikipedia.org/wiki/FASTA_format). Δηλαδή για κάθε strain:
* Υπάρχει μία γραμμή (επικεφαλίδα) με διάφορες πληροφορίες για την ακολουθία (π.χ χώρα προέλευση). Για παράδειγμα για το πρώτο strain του αρχείου η επικεφαλίδα είναι:

```text
>hCoV-19/Italy/FVG-ICGEB-S208/2020|EPI_ISL_498558|2020-07
```

* Στη συνέχεια ακολουθούν πολλές γραμμές με την ακολουθία, όπου κάθε γραμμή έχει 80 βάσεις. 

Μετά από τις γραμμές με την ακολουθία ακολουθεί η επικεφαλίδα του 2ου strain κτλ..

Στη συνέχεια ακολουθεί η επικεφαλίδα για το 2ο strains και μετά οι γραμμές με την ακολουθία για τον 2ο strain κτλ. 

Το αρχείο είναι συμπιεσμένο. Μπορείτε να το αποσυμπιέσετε πριν το ανοίξετε ή (καλύτερα) να το ανοίξετε συμπιεσμένο απευθείας από τη python με τον εξής τρόπο:

```python
import gzip

with gzip.open('covid_fasta.gz', 'rt') as f:
    # Εδώ μπορείτε να βάλετε τις εντολές που θα βάζατε αν το αρχείο δεν ήταν συμπιεσμένο.
    # π.χ. f.readline() 
    pass
```

Φτιάξτε έναν generator ο οποίος θα παίρνει μία παράμετρο. Η παράμετρος θα είναι το όνομα του αρχείου με τις ακολουθίες του COVID19 (μπορείτε αν θέλετε να βάλετε το αποσυμπιεσμένο αρχείο). Για κάθε strain που έχει το αρχείο, ο generator θα κάνει yield ένα dictionary. To dictionary θα έχει τα ακόλουθα δύο ζευγάρια από κλειδιά / τιμές:

* Κλειδί: "header", Τιμή: Ένα string με την επικεφαλίδα του strain
* Κλειδί: "sequence": Τιμή: Ένα string με την ακολουθία του strain, ως ένα string το οποίο περιέχει μόνο A,C,G,Τ και Ν (=άγνωστη βάση). 

Για παράδειγμα:

```python
gen = g('covid_fasta.gz')

first_strain = next(gen)
print (first_strain['header']) 
# Τυπώνει: >hCoV-19/Italy/FVG-ICGEB-S208/2020|EPI_ISL_498558|2020-07 
print (first_strain['sequence'][:100])
# Τυπώνει: 'ATTAAAGGTTTATACTTTCCCAGGTAACAAACCAACCAACTTTCGATCTCTTGTAGATCTGTTCTCTAAACGAACTTTAAAATCTGTGTGGCTGTCACTC'

second_strain = next(gen)
print (second_strain['header'])
# Τυπώνει: >hCoV-19/Italy/FVG-ICGEB-S211/2020|EPI_ISL_498559|2020-07-01

print (second_strain['sequence'][:100])
# Τυπώνει: 'ATTAAAGGTTTATACCTTCCCAGGTAACAAACCAACCAACTTTCGATCTCTTGTAGATCTGTTCTCTAAACGAACTTTAAAATCTGTGTGGCTGTCACTC' 
```

Σημείωση: Θα παρατηρήσετε ότι κάποιες ακολουθίες έχουν γράμματα εκτώς από A,C,G και T. Δεν χρειάζεται να κάνετε κάποιον έλεγχο. Απλά κάντε yield την ακολουθία όποια και αν είναι αυτή. Προαιρετικό: αντικαταστήστε τα new lines (```\n```) με τον κενό χαρακτήρα (```''```).  

### Άσκηση 70
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει μία λίστα η οποία θα περιέχει τις 10 χώρες του κόσμου με τα περισσότερα strains του ιού COVID19. Η χώρα από την οποία προέρχεται ένα strain υπάρχει στην επικεφαλίδα του strain στο αρχείο FASTA της άσκησης 69. Η χώρα υπάρχει μεταξύ του πρώτου και του δεύτερου ```/``` στην επικεφαλίδα. Για παράδειγμα:

```
>hCoV-19/Italy/FVG-ICGEB-S208/2020|EPI_ISL_498558|2020-07 
         ^^^^^
```

### Άσκηση 71
Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι ένα string. To string θα αναπαριστάει ένα insertion σε φορμάτ [HGVS](https://varnomen.hgvs.org/bg-material/simple/). Για παράδειγμα η μετάλλαξη ```NM_004006.2:c.849_850insCCT``` σημαίνει ότι στο μετάγραφο NM_004006.2, μεταξύ των θέσεων 849 και 850 (σε κωδικεύουσες θέσεις), έχει "προστεθεί" η ακολουθία ```CCT```. Η συνάρτηση θα επιστρέφει ```True``` ή ```False``` ανάλογα με το αν η μετάλλαξη είναι στο σωστό φορμάτ ή όχι. Το σωστό φορμάτ είναι:

1. Όνομα γονιδίου. Αυτό μπορεί να περιέχει γράμματα, αριθμούς και τον χαρακτήρα ```_```.
2. Τελεία
3. Αριθμός με ένα ή πολλά ψηφία
4. Άνω κάτω τελεία
5. Το γράμμα c ή το γράμμα g
6. Τελεία 
7. Αριθμός με ένα ή πολλά ψηφία
8. Ο χαρακτήρας ```_``` (underscore)
9. Αριθμός με ένα ή πολλά ψηφία
10. Οι χαρακτήρες: ```ins```
11. Μία ακολουθία με ένα η περισσότερα από τα γράμματα ```A```,```C```,```G```,```T```.

Επίσης θα πρέπει ο αριθμός στο πεδίο 9 να είναι κατά 1 μεγαλύτερος από τον αριθμό στο πεδίο 7. Αυτό το τέλευταίο θα το ελέγξετε με regular expression χρησιμοποιώντας groups. Στη συνέχεια θα πάρετε τα πεδία που έχουν κάνει "capture" τα groups, θα τα μετατρέψετε σε ακέραιους (από strings) και θα κάνετε τον έλεγχο αν διαφέρουν κατά 1. 

Για παράδειγμα θα πρέπει:

```python
f('NM_004006.2:c.849_850insCCT') # Επιστρέψει True
f('NM_004006.2:c.849_850insCCE') # Επιστρέψει False
f('NM_004006.2:c.849_850ins') # Επιστρέψει False
f('NM_004006.2:c.849_850inrsCCT') # Επιστρέψει False
f('NM_004006.2:c.849_852insCCT') # Επιστρέψει False
f('NM_004006.2:c.849insCCT') # Επιστρέψει False
f('NM_004006.2:c.849_insCCT') # Επιστρέψει False
f('NM_004006.2:r.849_850insCCT') # Επιστρέψει False
f('NM_004006:c.849_850insCCT') # Επιστρέψει False
f('NM_004006.:c.849_850insCCT') # Επιστρέψει False
f('NM_004006.a:c.849_850insCCT') # Επιστρέψει False
f('NM_004006:c.849_850insCCT') # Επιστρέψει False
f('.2:c.849_850insCCT') # Επιστρέψει False
f('MHTSOS.2:c.849_850insCCT') # Επιστρέψει True
```

### Άσκηση 72
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα string. Η παράμετρος αυτή θα είναι το όνομα ενός αρχείου το οποίο θα έχει την ίδια δομή όπως το ```Homo_sapiens.gene_info``` που έχουμε δει σε προηγούμενες ασκήσεις. Η συνάρτηση θα πρέπει να χρησιμοπoιείσει ΕΝΑ regular expression για να εντοπίσει το πλήθος από Ensembl Genes τα οποία υπάρχουν στο αρχείο. Ένα Ensembl Gene έχει ένα ID το οποίο ακολουθεί το φορμάτ:

* Οι χαρακτήρες ENSG
* Ένα ή περισσότερα 0
* Αριθμός με ένα ή πολλά ψηφία

Δίνεται ότι ο αριθμός αυτός είναι:
* είτε 35194 για αρχεία που έχουν κατέβει πριν τις 2 Απριλίου 
* είτε 35207 για αρχείο που έχουν κατέβει μετά τις 2 Απριλίου και πριν τις 10 
* είτε 35208 για αρχεία που έχουν κατέβει μετά τις 10 Απριλίου

Hint: re.findall

### Άσκηση 73
Στα αγαπημένο μας αρχείο ```Homo_sapiens.gene_info``` υπάρχει η στήλη ```dbXrefs```. Σε αυτή τη στήλη υπάρχουν οι κωδικοί του κάθε γονιδίου σύμφωνα με διάφορες ονοματολογίες (nomenclatures). Για παράδειγμα στο πρώτο γονίδιο του αρχείου (```A1BG```), υπάρχει το κείμενο: ```MIM:138670|HGNC:HGNC:5|Ensembl:ENSG00000121410``` . Σε αυτό το κείμενο υπάρχει η πληροφορία ότι αυτό το γονίδιο έχει τον κωδικό ```138670``` στην ονοματολογία [MIM](https://www.omim.org/), τον κωδικό ```5``` στην ονοματολογία [HGNC](https://www.genenames.org/) και τον κωδικό ```ENSG00000121410``` στην ονοματολογία [Ensembl](https://www.ensembl.org/index.html). Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα string. Το string θα είναι της μορφής:  ```MIM:138670|HGNC:HGNC:5|Ensembl:ENSG00000121410``` . Η συνάρτηση θα επιστρέφει ένα string όπου οι κωδικοί ΜΙΜ και Ensembl θα έχουν αλλάξει θέση. Για παράδειγμα:

```python
f('MIM:138670|HGNC:HGNC:5|Ensembl:ENSG00000121410') # Επιστρέφει: Ensembl:ENSG00000121410|HGNC:HGNC:5|MIM:138670
```  

Σε αυτή την άσκηση είναι υποχρεωτικό να χρησιμοποιήσετε τη ```re.sub```

### Άσκηση 74
Σε αυτό τον πίνακα: https://www.bioinformatics.org/sms/iupac.html υπάρχει το "IUPAC nucleotide code" (πρώτος πίνακας). [Ο πίνακας υπάρχει και στη wikipedia](https://en.wikipedia.org/wiki/Nucleic_acid_notation). Σε αυτόν τον πίνακα υπάρχει μία αντιστοίχιση μεταξύ συνδοιασμών νουκλεοτιδίων και γραμμάτων. Για παράδειγμα το γράμμα: ```K``` σημαίνει ```G``` or ```T``` και το γράμμα ```Μ``` σημαίνει ```A``` or ```C```. Άρα ο κωδικός ```KM``` μπορεί να κάνει match τις ακολουθίες ```GΑ```, ```GC```, ```TA``` και ```TC```. Γράψτε μία συνάρτηση η οποία θα παίρνει 2 παράμετρους. Και οι δύο παράμετροι θα είναι strings. Η 1η παράμετρος θα είναι ένας συνδυασμός από γράμματα που ανήκουν στο "IUPAC nucleotide code". Δηλαδή θα αποτελείται από συνδοιασμούς των γραμματων ```A```,```C```,```G```,```T```,```R```,```Y```,```S```,```W```,```K```,```M```,```B```,```D```,```H```,```V```,```N``` (αγνοήστε τα ```U```, ```.```, ```-```). Η 2η παράμετρος θα είναι μία ακολουθία που θα αποτελείται μόνο από τα γράμματα ```A```,```C```,```G```,```T``` (δεν χρειάζεται να το επαληθεύσετε αυτό). Η συνάρτηση θα επιστρέφει ```True``` αν η δεύτερη παράμετρος (ακολουθία) είναι συμβατή με τα γράμματα στον κωδικό IUPAC της 1ης παραμέτρου. Διαφορετικά θα επιστρέφει ```False```. 

Για παράδειγμα:
```python
f('M', 'A') # Επιστρέφει True
f('M', 'T') # Επιστρέφει False
f('KM', 'GA') # Επιστρέφει True
f('KM', 'GG') # Επιστρέφει False
f('BAN', 'TAA') # Επιστρέφει True
f('BAN', 'AAA') # Επιστρέφει False
```

* Στην άσκηση είναι υποχρεωτικό να κατασκευάσετε ένα regular expression το οποία θα κάνει fullmatch το δεύτερο όρισμα.
* Δεν χρειάζεται να κάνετε κάποιον έλεγχο για να δείτε αν τα περιεχόμενα της 1ης παραμέτρου είναι σωστά. Δηλαδή δεν χρειάζεται να τσεκάρεται ότι τα γράμματα είναι όντως από τον πίνακα της IUPAC.\

Hint: Αν η 1η παράμετρος είναι ```'KM'``` τότε το regular expression είναι ```'[GT][AC]'```

### Άσκηση 75
[Διαβάζουμε στη wikipedia](https://en.wikipedia.org/wiki/GATA1):

> In both GATA1 and GATA1-S, C-ZnF (i.e. C-terminus zinc finger) binds to DNA-specific nucleic acid sequences sites viz., (T/A(GATA)A/G), on the expression-regulating sites of its target genes and in doing so either stimulates or suppresses the expression of these target genes 


Αυτό φαίνεται πολύ ενδιαφέρον! ο μεταγραφικός παράγοντας GATA1 λοιπόν προσδένεται σε οτιδήποτε έχει τη μορφή T ή Α, ακολουθούμενο από GATA, ακολουθούμενο από A ή G (Για παράδειγμα στην ακολουθία: ```TGATAG``` ) και ρυθμίζει την έκφρασή του. Η ερώτηση είναι: επηρεάζει το GATA1 την έκφραση στα γονίδια του COVID; Για να το διευρευνήσουνμε μπορούμε να κάνουμε το εξής: να μετρήσουμε απλά πόσες φορές υπάρχει το pattern της ακολουθίας που προσδένεται ο GATA1 **πριν** από το start codon ```ATG```. Επίσης θα αφήσουμε και ένα περιθώριο το πολύ 100 βάσεων μεταξύ του GATA1 pattern και του start codon. Άρα φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι ένα string το οποίο θα είναι το όνομα ενός αρχείου όπως το ```covid_fasta.gz```. Η συνάρτηση θα ψάχνει σε κάθε strain του αρχείου πόσες φορές υπάρχει το παρακάτω pattern:

* Το γράμμα ```T``` ή ```A```
* Η ακολουθία ```GATA``` 
* To γράμμα ```A``` ή ```G```
* 1 έως 100 οποιεσδήποτε βάσεις 
* Η τριπλέτα  ```ATG```

Η συνάρτηση θα επιστρέφει τον μέσο όρο εμφάνισης του πλήθους του παραπάνω pattern για όλα τα strains. Δηλαδή αν σε όλο το αρχείο βρεθεί αυτό το pattern 150 φορές και το αρχείο έχει 10 strains, η συνάρτηση θα πρέπει να επιστρέφει 15 (150/10).

* Είναι υποχρεωτική η χρήση regular expressions
* Μπορείτε να χρησιμοποιείσετε και τον generator της άσκησης 69.

### Άσκηση 76
Σημείωση: Χωρίς να σας προκαταλαμβάνω [[???](https://www.loutraki365.gr/blog/post/omileite-ellinika-prokatalamvano-kai-prokatavallo-i-megali-syghysi)], αυτή είναι μία δύσκολη άσκηση. Καλύτερα να ασχοληθείτε αφού έχετε κάνει τις υπόλοιπες. Επίσης θα βαθμολογηθεί επιεικότερα.

[Σε αυτό το link](https://m.ensembl.org/info/docs/api/compara/compara_schema.html#genomic_align) περιγράφονται τα CIGAR strings (σε μία απλή εκδοχή τους). Τα CIGAR strings είναι ένας τρόπος να περιγράψουμε τον τρόπο με τον οποίο μία ακολουθία έχει στοιχηθεί (align) σε μία άλλη. Για παράδειγμα ας υποθέσουμε ότι έχουμε τις ακολουθίες Α: ```AAGCGCACTT``` και Β: ```ΑΑCGCTT```  και ότι η Β έχει στοιχηθεί πάνω στην Α με αυτόν τον τρόπο:

```
Α: A A G C G C A C T T
Β: Α Α - C G C - - T T 
```

Ένας τρόπος να περιγράψουμε αυτη τη στοίχιση είναι απλά να μετρήσουμε τα matches και τα deletions. Σε αυτή τη περίπτωση είναι:

```
Α: A A G C G C A C T T
Β: Α Α - C G C - - T T 
   M M D M M M D D M M 
```

To string ```M M D M M M D D M M``` το συρικνώνουμε γράφοντας απλά τον αριθμό από M και D πριν από αυτά. Για παράδειγμα:
```
M M D M M M D D M M
-->
2M1D3M2D2M
```

Τέλος τα 1 μπορούμε να τα σβήσουμε (όταν δεν υπάρχει αριθμός εννοείται το 1):
```
2M1D3M2D2M
-->
2MD3M2D2M
```

Γράψτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι ένα string το οποίο θα αναπαριστάει ένα CIGAR string. H συνάρτηση θα επιστρέφει ```True``` ή ```False``` ανάλογα με το αν η παράμετρος είναι CIGAR string ή όχι. Η συνάρτηση πρέπει να είναι η εξής:

```python
import re
def f(x):
    m = re.fullmatch(r'..PUT YOU MAGIC HERE..', x)
    return bool(m)
```

Δηλαδή θα πρέπει απλά να συμπληρώσετε το regular expression.

Για παράδειγμα θα πρέπει:
```python
f('M') # Επιστρέφει True
f('5M') # Επιστρέφει True
f('D') # Επιστρέφει True
f('15D') # Επιστρέφει True
f('MD') # Επιστρέφει True
f('DM') # Επιστρέφει True
f('MDM') # Επιστρέφει True
f('DMD') # Επιστρέφει True
f('10D2MD') # Επιστρέφει True
f('2MD3M2D2M') # Επιστρέφει True

f('1M') # Επιστρέφει False
f('0M') # Επιστρέφει False
f('1D') # Επιστρέφει False
f('MM') # Επιστρέφει False
f('DD') # Επιστρέφει False
f('10D10D') # Επιστρέφει False
f('MDMM') # Επιστρέφει False
```

### Άσκηση 77
Όλοι ξέρουμε για το φαινόμενο του [alternative splicing](https://en.wikipedia.org/wiki/Alternative_splicing), ή εναλλακτικό μάτισμα. Σύμφωνα με αυτό το φαινόμενο, κατά τη διαδικασία της μεταγραφής ένα ή περισσότερα εξώνια μπορεί να διαγραφτούν και να μην συμμετέχουν στο παραγόμενο mRNA. Ας υποθέσουμε ότι έχουμε ένα γονίδιο το οποίο έχει 4 εξόνια. Επίσης ας υποθέσουμε ότι κατά τη διάρκεια της μεταγραφής μπορεί να διαγραφτούν όλα εκτός απο το 1o και τελευταιο εξόνιο και ότι τα εξόνια δεν αλλάζουν ποτέ σειρά. Πόσα εναλλακτικά μετάγραφα μπορούν να δημιουργηθούν; Ας τα μετρήσουμε:

```
Εξόνια Αρχικού γονίδιου:
1-2-3-4 

Εναλλακτικά ματίσματα:
1-2-3-4
1-3-4
1-2-4
1-4
```  

Βλέπουμε ότι μπορούν να δημιουργηθούν (θεωρητικά) 4 διαφορετικά μετάγραφα.

Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος αυτή θα είναι ακέραιος αριθμός και θα αναπαριστάει τον αριθμό από εξόνια ενός γονιδίου. Η συνάρτηση θα επιστρέφει μία λίστα από όλα τα δυνατά μετάγραφα του γονιδίου. Κάθε μετάγραφο θα είναι απλά μία λίστα με τα εξόνια που περιέχει. Για παράδειγμα:

```python
f(3) # Επιστρέφει [ [1,2,3], [1,3] ]
f(4) # Επιστρέφει [ [1,2,3,4], [1,3,4], [1,2,4], [1,4] ]
f(5) # Επιστρέφει [ [1,2,3,4,5], [1,3,4,5], [1,2,4,5], [1,2,3,5], [1,4,5], [1,3,5], [1,2,5], [1,5] ]
```

* Σημείωση 1: Η σειρά που επιστρέφει τα μετάγραφα δεν έχει σημασία. 
* Σημείωση 2: Μπορείτε να επιστρέψετε και λίστα από tuples.

### Άσκηση 78
Ας υποθέσουμε ότι:
* Στη γενετική θέση ```Θ1``` έχουμε μία μετάλλαξη με δύο αλλήλια: το αλλήλιο ```Α11``` και το αλλήλιο ```Α12```. Οι αλληλικές τους συχνότητες στον πληθυσμό που μελετάμε είναι: ```P11``` και ```P12``` αντίστοιχα. 
* Στη γενετική θέση ```Θ2``` έχουμε μία μετάλλαξη με τρία δυνατά αλλήλια: τα αλλήλια ```Α21```, ```Α22```, ```Α23```. Οι αλληλικές τους συχνότητες στον πληθυσμό που μελετάμε είναι: ``` P21```, ```P22```, ```P23```. 
* Υποθέτουμε ότι οι γενετικές θέσεις ```Θ1``` και ```Θ2``` είναι ανεξάρτητες. Ή αλλιώς ότι δεν είναι σε [ανισορροπία σύνδεσης](https://en.wikipedia.org/wiki/Linkage_disequilibrium). 

Με βάση τα παραπάνω ένα άτομα μπορεί να έχει εναν από τους εξής απλότυπους:

```
Απλότυπος 1: A11  A21 με πιθανότητα P11 * P21
Απλότυπος 2: A11  A22 με πιθανότητα P11 * P22
Απλότυπος 3: A11  A23 με πιθανότητα P11 * P23
Απλότυπος 4: A12  A21 με πιθανότητα P12 * P21
Απλότυπος 5: A12  A22 με πιθανότητα P12 * P22
Απλότυπος 6: A12  A23 με πιθανότητα P12 * P23
```

Βλέπουμε δηλαδή ότι οι δυνατοί απλότυποι είναι όλοι οι συνδυασμοί των αλληλίων της θέσης ```Θ1``` με όλα τα αλλήλια της θέσης ```Θ2``` και η συχνότητά τους είναι το γινόμενο των συχνοτήτων των αλλήλιων που έχουν. 

Με βάση τα παραπάνω γράψτε μία συνάρτηση με το όνομα ```ask_78``` η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι ένα dictionary το οποίο θα περιέχει τα εξής κλειδιά/τιμές: Κλειδί: το όνομα της μετάλλαξης, τιμή: μία λίστα με tuples. Κάθε tuple θα έχει δύο τιμές. Η πρώτη τιμή θα είναι  ένα string με το όνομα κάθε αλληλίου της μετάλλαξης. Η 2η τιμή του tuple θα είναι η συχνότητα αυτού του αλληλίου. Τα αλλήλια μπορεί να είναι παραπάνω από 2. Η συνάρτηση θα επιστρέφει ένα dictionary. Κάθε κλειδί του dictionary θα είναι το όνομα του απλότυπου σε αυτό το φορμάτ: ```Haplotype 1```, ```Haplotype 2```, ```Haplotype 3```, κτλ. Η τιμή κάθε κλειδιού του dictionary θα είναι ένα tuple το οποίο θα περιέχει 2 τιμές. Η πρώτη τιμή θα είναι ένα string το οποίο θα αποτελείται από όλα τα ονόματα των αλλήλιων του απλότυπου ενωμένα με τον χαρακτήρα ```-```. H 2η τιμή του tuple θα είναι η συχνότητα του απλότυπου υπολογισμένη με βάση τα παραπάνω. Για παράδειγμα:

```python
alleles = {
    'M1': [('A', 0.3), ('B', 0.7)],
    'M2': [('K', 0.1), ('L', 0.5), ('M', 0.4)]
}
f(alleles) 
# Επιστρέφει:
{
    'Haplotype 1': ('A-K', 0.03), # 0.3 * 0.1
    'Haplotype 2': ('A-L', 0.15), # 0.3 * 0.5
    'Haplotype 3': ('A-M', 0.12), # 0.3 * 0.4
    'Haplotype 4': ('B-K', 0.07), # 0.7 * 0.1
    'Haplotype 5': ('B-L', 0.35), # 0.7 * 0.5
    'Haplotype 6': ('B-M', 0.28), # 0.7 * 0.4 
}

```

Εννοείται ότι το dictionary ```alleles``` μπορεί να περιέχει παραπάνω από 2 μεταλλάξεις. 

### Άσκηση 79
Φτιάξτε μία συνάρτηση με το όνομα ```ask_79``` η οποία θα παίρνει δύο παραμέτρους. Η πρώτη θα είναι ένα dictionary σαν το dictionary που περιγράφηκε ως η παράμετρος της συνάρτησης ```ask_78``` της άσκησης 78. Η δεύτερη παράμετρος θα είναι το όνομα ενός αρχείου. Η συνάρτηση θα καλεί της συνάρτηση ```ask_78``` με τη τιμή της παραμέτρου και θα σώζει το dictionary που επιστρέφει η ```ask_78``` στο αρχείο με το όνομα της 2ης παραμέτρου σε φορμάτ json. Θα πρέπει δηλαδή να μπορώ να γράφω:

```python
import json
alleles = {
    'M1': [('A', 0.3), ('B', 0.7)],
    'M2': [('K', 0.1), ('L', 0.5), ('M', 0.4)]
}

results_1 = ask_78(alleles)

ask_79(alleles, 'file.json')

with open('file.json') as f:
    results_2 = json.load(f)

results_1 = {k: tuple(v) for k,v in results_1.items()} # Κάνω tuple τις τιμές του dictionary
results_2 = {k: tuple(v) for k,v in results_2.items()} # Κάνω tuple τις τιμές του dictionary

print (results_1 == results_2) # Τυπώνει True

```

### Άσκηση 80
Πηγαίνετε σε αυτή τη σελίδα: https://www.worldometers.info/coronavirus/country/greece/ . Αφού.. περιεργαστείτε λίγο τη σελίδα, θα νοιώσετε σίγουρα την ανάγκη να επεξεργαστείτε και εσείς τα δεδομένα της με τη φανταστική python που ξέρετε! Ας κάνουμε μια.. χακιά λοιπόν! 

Για αρχή, πηγαίνετε εδώ: https://www.view-page-source.com/howto-see-html-code-different-browsers/ και διαβάστε πως μπορείτε να δείτε τον κώδικα μίας σελίδας που έχετε επισκεφτεί. Αφού δείτε πως το κάνετε αυτό ανάλογα με τον browser σας και το λειτουργικό σας σύστημα (windows, mac, Linux), ξανα-επισκεφτείτε τη σελίδα https://www.worldometers.info/coronavirus/country/greece/ και κάντε τις ανάλογες ενέργειες για να εμφανιστεί ο κώδικας αυτής της σελίδας. 

Λογικά θα εμφανιστεί κάτι τελείως ακαταλαβίστικο το οποίο ξεκινάει με αυτό:
```html
<!DOCTYPE html>
<!--[if IE 8]> <html lang="en" class="ie8"> <![endif]-->
<!--[if IE 9]> <html lang="en" class="ie9"> <![endif]-->
<!--[if !IE]><!--> <html lang="en"> <!--<![endif]-->
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Greece Coronavirus: 273,459 Cases and 8,302 Deaths - Worldometer</title>
```

Μέσα σε αυτό το χάος υπάρχει ένας πίνακας σε json ο οποίος περιέχει τα ημερήσια κρούσματα του κοροναϊού στην Ελλάδα. Η πληροφορία αυτή υπάρχει στη γραμμή 631. Πρόκειται για μία γραμμή η οποία ξεκινάει με:

```
   [null,null,null,null,null,null,null,null,null,null,null,null,2,1,3,0
```

και συνεχίζεται για πολύ.. μέσα σε αυτή τη γραμμή. 

Όπως καταλάβατε ήδη η λίστα σε αυτή η γραμμή περιέχει τον ημερίσιο αριθμό κρουσμάτων από τότε που ξεκίνησε να γίνεται παρακολούθηση του κοροναϊού παγκοσμίως (15 Φεβρουαρίου, 2020). Δηλαδή το πρώτο στοιχείο της λίστας (```null```) περιέχει τον αριθμό των κρουσμάτων στην Ελλάδα στις 15 Φεβρουαρίου 2021. Τα στοιχεία ```null``` στην αρχή σημαίνουν ότι απλά εκείνη τη μέρα δεν έγινε μέτρηση (μην το μερδεύετε με τα στοιχεία ```0``` που σημαίνει ότι εκείνη τη μέρα δεν καταγράφηκαν κρούσματα).

Επιλέξτε με το ποντίκι αυτή τη λίστα ξεκινώντας από την αγκύλη που ξεκινάει (```[```) μέχρι την αγκύλη που τελειώνει (```]```). Στη συνέχεια κάνετε το copy (Ctrl-C). Πηγαίνετε στο jupyter και κάντε το paste (Ctrl-V) μέσα σε ένα string. Θα πρέπει δηλαδή στο jupyter σας να υπάρχει ένα κελί σαν αυτό:

![img](https://i.imgur.com/RITbb3S.png)

Αφού αυτό είναι ένα string σε format json, μπορείτε να το επεξεργαστείτε:

```python
import jsοn
data = json.loads(s)
```

Αφού λοιπόν κάνετε τα παραπάνω απαντήστε στην εξής ερώτηση: αν θεωρήσουμε σαν μέρα 1 την 15 Φεβρουαρίου, 2020, ποιος είναι ο αριθμός της μέρας που είχαμε ρεκόρ κρουσμάτων (μέχρι στιγμής) στην Ελλάδα; Η απάντησή σας θα πρέπει να είναι ένας αριθμός (όχι ημερομηνία)

Για αυτή την άσκηση δεν χρειάζεται να φτιάξετε κάποια συνάρτηση (αν φτιάξετε δεν είναι λάθος φυσικά). Απλα σε ένα "κελί" στο jupyter και κάτω από το σχόλιο ```# askhsh 80``` βάλτε:
* το string το οποίο φτιάξατε κάνοντας copy paste από τον κώδικα της σελίδας.
* τον κώδικα ο οποίος το διαβάζει και τον μετατρέπει σε μία λίστα python. 
* τον κώδικα ο οποίος απαντάει στο ερώτημα της άσκησης. 

### Άσκηση 81
Η [PharmGKB](https://www.pharmgkb.org) είναι μία βάση δεδομένων που περιέχει φαρμακογονιδιωματική πληροφορία. Γνωρίζουμε ότι μερικά φάρμακα έχουν διαφορετική τοξικότητα ή διαφορετική επίδραση ([ADME](https://en.wikipedia.org/wiki/ADME) effects), ανάλογα μα το γονιδίωμα του λήπτη τους. Μπορούμε να φορτώσουμε με pandas ένα μικρό μέρος αυτής της βάσης. Για αρχή πηγαίνετε εδώ: https://www.pharmgkb.org/downloads και κατεβάστε το αρχείο: [clinicalVariants.zip](https://api.pharmgkb.org/v1/download/file/data/clinicalVariants.zip) το οποίο περιέχει Clinical Variant Data. Το αρχείο είναι σε zip οπότε θα πρέπει να το αποσυμπιέσετε. Ένα από τα αρχεία που περιέχει το zip αρχείο είναι το ```clinicalVariants.tsv```. Μπορείτε να το φορτώσετε με:

```python
import pandas as pd

cV = pd.read_csv('clinicalVariants/clinicalVariants.tsv', sep='\t') 
```

ή με:
```python
import pandas as pd
cV = pd.read_csv('clinicalVariants.tsv', sep='\t') 
```

Ανάλογα με το που το έχετε αποσυμπιέσει. 

Φτιάξτε λοιπόν μία συνάρτηση η οποία θα παίρνει ένα όρισμα. Το όρισμα θα είναι ένα DataFrame σαν το cV. Η συνάρτηση θα επιστρέφει ένα νέο DataFrame το οποίο θα περιέχει τις ίδιες στήλες με το DataFrame της παραμέτρου. Θα περιέχει όμως μόνο τις γραμμές όπου η στήλη ```"type"``` έχει τη τιμή ```"Toxicity"``` και η στήλη ```"level of evidence"``` θα έχει ή τη τιμή ```"1A"``` ή τη τιμή ```"1B"```.

Θα πρέπει δηλαδή να μπορώ να γράφω:

```python
import pandas as pd
cV = pd.read_csv('clinicalVariants.tsv', sep='\t') 

new_cV = f(cV)

print (new_cV.shape)
# Τυπώνει (119, 6)

```

### Άσκηση 82
Παρατηρούμε ότι η στήλη ```type``` περιέχει τιμές που μπορεί να έχουν τη λέξη "Toxicity" μαζί με άλλες λέξεις. Επίσης η στήλη ```type``` έχει μερικές γραμμές στις οποίες η τιμή της είναι 'NA', οπότε θα πρέπει να τις αφαιρέσετε αυτες τις γραμμές για αυτή την άσκηση. 

Φτιάξτε μία συνάρτηση η οποία θα παίρνει ένα όρισμα. Το όρισμα θα είναι ένα DataFrame σαν το cV. Η συνάρτηση θα επιστρέφει το γονίδιο το οποίο έχει τις περισσότερες γραμμές όπου στη στήλη ```type``` υπάρχει το string  "Τoxicity".

Θα πρέπει δηλαδή να μπορώ να γράφω:

```python
import pandas as pd
cV = pd.read_csv('clinicalVariants.tsv', sep='\t') 

f(cV) # Τυπώνει 'HLA-B' 

```


### Άσκηση 83
Φτιάξτε μία συνάρτηση η οποία θα παίρνει ένα όρισμα. Το όρισμα θα είναι ένα DataFrame σαν το cV. Η συνάρτηση θα φτιάχνει ένα barplot με τους 10 πιο κοινούς φαινότυπους (στήλη ```phenotypes```) που υπάρχουν στο DataFrame της παραμέτρου.  Η συνάρτηση δεν θα επιστρέφει τίποτα. Θα πρέπει δηλαδή να μπορώ να γράφω:

```python
import pandas as pd
cV = pd.read_csv('clinicalVariants.tsv', sep='\t') 

f(cV) 
# Εμφανίζει το plot:
```
![img](https://i.imgur.com/3a4e7Gn.png)

### Άσκηση 84
Αν πάμε στο [Expression Atlas](https://www.ebi.ac.uk/gxa/experiments/E-MTAB-5214/Downloads) μπορούμε να κατεβάσουμε τα δεδομένα από [αυτό το paper](https://europepmc.org/article/MED/25954001). Σε αυτό το πείραμα οι συγγραφείς μελέτησαν την έκφραση σχεδόν όλων των γονιδίων σε 53 διαφορετικούς ιστούς. Μπορείτε να κατεβάσετε το αρχείο [Expression values across all genes (TPM)](https://www.ebi.ac.uk/gxa/experiments-content/E-MTAB-5214/resources/ExperimentDownloadSupplier.RnaSeqBaseline/tpms.tsv) και να το μελετήσετε.. Θα δείτε ότι η πρώτη στήλη είναι το ENSEMBL code για το γονίδιο, η 2η στήλη έχει το όνομα του γονιδίου και οι υπόλοιπες στήλες έχουν την έκφραση του γονιδίου σε διάφορους ιστούς (δεν μας ενδιαφέρει εδώ πως το μετρήσανε ή τι δείχνουν αυτές οι ποσότητες).

Μπορείτε να φορτώσετε αυτά τα δεδομένα σε pandas με:

```python
import pandas as pd
url = 'https://www.ebi.ac.uk/gxa/experiments-content/E-MTAB-5214/resources/ExperimentDownloadSupplier.RnaSeqBaseline/tpms.tsv'
expression = pd.read_csv(url, sep='\t', skiprows=4)
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρία ορίσματα. H πρώτη θα είναι ένα DataFrame σαν το expression. Η δεύτερη και η τρίτη παράμετρος θα είναι το όνομα ενός ιστού, όπως εμφανίζεται στις στήλες του DataFrame. Η συνάρτηση θα κάνει ένα scatter plot όπου στον άξονα x θα είναι οι τιμές της έκφρασης όλων των γονιδίων για τον ιστό της 2ης παράμετρου. Στον άξονα y θα είναι οι τιμές τις έκφρασης όλων των γονιδίων για τον ιστό της 3ης παραμέτρου. Στο plot που θα κάνετε αφαιρέστε όλα τα γονίδια που έχουν τιμή έκφρασης > 200 σε οποιοδήποτε από τους 2 ιστούς. 

Δίνονται εδώ μερικά παραδείγματα:
```python
f(expression, 'stomach', 'spleen')
```
Εμφανίζει το plot:

![img](https://i.imgur.com/owcO8Yc.png)


```python
f(expression, 'heart left ventricle', 'lung')
```
Εμφανίζει το plot:

![img](https://i.imgur.com/jOrwJ5N.png)

```python
f(expression, 'coronary artery', 'aorta')
```
Εμφανίζει το plot:

![img](https://i.imgur.com/PtUmXjk.png)


Όπως καταλαβαίνετε από το πόσο "διαγώνιες" είναι οι τιμές σε αυτό το plot, μπορούμε να βγάλουμε συμπεράσματα για την ομοιότητα στη βιολογική λειτουργία αυτών των ιστών. 

### Άσκηση 85

Σε αυτή τη σελίδα https://en.wikipedia.org/wiki/List_of_busiest_airports_by_passenger_traffic υπάρχει ένας πίνακας με τα 50 αεροδρόμια με τη μεγαλύτερη επιβατική κίνηση σε όλο τον κόσμο. 

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα:
* Φορτώνει τον πρώτο(\*) πίνακα της σελίδας σε ένα pandas DataFrame
* Θα "γκρουπάρει" όλες τις γραμμές που έχουν την ίδια χώρα (στήλη: ```Country```)
* Για κάθε group θα υπολογίζει το άθροισμα των επιβατών (στήλη: ```Totalpassengers```)
* Θα ταξινομεί το DataFrame με βάση αυτό το άθροισμα, ξεκινώντας από το μεγαλύτερο και καταλήγοντας στο μικρότερο
* Θα κάνει ένα barplot με το άθροισμα των επιβατών για κάθε χώρα. 

Θα πρέπει δηλαδή να τρέχω:

```python
f()
```

Η συνάρτηση θα παράγει το παρακάτω γράφημα (είστε ελεύθεροι να κάνετε οποιαδήποτε.. στυλιστική αλλαγή)
![img](https://i.imgur.com/l8QxYnO.png)

Προσπαθήστε να υλοποιήσετε αυτή την άσκηση γράφοντας μία εντολή με method chaining, χωρίς αυτό να είναι υποχρεωτικό.

\* **ΠΡΟΣΟΧΗ!** Αυτή η εκφώνηση γράφτηκε πριν [προστεθούν στη σελίδα τα στατιστικά για το 2020](https://en.wikipedia.org/w/index.php?title=List_of_busiest_airports_by_passenger_traffic&type=revision&diff=1018415106&oldid=1014458171). Τα αποτελέσματά σας θα είναι διαφορετικά από το γράφημα που δόθηκε. Μπορείτε να προσπαθήσετε να βγάλετε το γράφημα που δόθηκε αν διαβάσετε το δεύτερο DataFrame που περιέχει η σελίδα (αντί για το πρώτο). Και τα δύο θεωρούνται σωστά.  

### Άσκηση 86
Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος αυτή θα είναι ένας 2-διάστατος numpy πίνακας. Η συνάρτηση θα επιστρέφει το άθροισμα των αριθμών που βρίσκονται στην περίμετρο του πίνακα. Δηλαδή τα στοιχεία που βρίσκονται στη πρώτη γραμμή, στη τελευταία γραμμή, στη 1η στήλη και στη τελευταία στήλη. Για παράδειγμα θα πρέπει:

```python
a = np.array([[3,6,5], [4,3,10], [6,5,2]])

f(a) # Επιστρέφει 41 = 3+6+5+10+2+5+6+4 

```

### Άσκηση 87
Ξαναδιαβάζουμε λίγο την άσκηση 84. Αν κατεβάσετε το αρχείο [Expression values across all genes (TPM)](https://www.ebi.ac.uk/gxa/experiments-content/E-MTAB-5214/resources/ExperimentDownloadSupplier.RnaSeqBaseline/tpms.tsv), μπορείτε να το φορτώσετε σε ένα numpy array ως εξής:

```python
expression = np.genfromtxt("tpms.tsv", delimiter='\t', skip_header=5, usecols=range(2,55))
```

ή ως εξής (χωρίς να κατεβάσετε το αρχείο):
```python
expression = np.genfromtxt(
    "https://www.ebi.ac.uk/gxa/experiments-content/E-MTAB-5214/resources/ExperimentDownloadSupplier.RnaSeqBaseline/tpms.tsv", 
    delimiter='\t', 
    skip_header=5, 
    usecols=range(2,55))
```

Φτιάξτε μία συνάρτηση η οποία παίρνει μία παράμετρο. Η παράμετρος είναι το όνομα ενός αρχείου με δομή όπως το ```tpms.tsv```. Η συνάρτηση θα πρέπει:
* Να "φορτώνει" το αρχείο σε έναν numpy πίνακα 
* Να υπολογίζει ποια γραμμή (κάθε γραμμή είναι και ένα γονίδιο) έχει τον μεγαλύτερο μέσο όρο. Για να το κάνετε αυτό χρησιμοποιείστε τη [nanmean](https://numpy.org/doc/stable/reference/generated/numpy.nanmean.html#numpy.nanmean) έτσι ώστε να υπολογίσετε τους μέσους όρους αγνοώντας τις  ```NaN``` τιμές. 
* Φορτώσετε τα ονόματα των γονιδίων σε μία λίστα (με.. παραδοσιακή python)
* Επιστρέψτε το όνομα του γονιδίου που έχει τον μεγαλύτερο μέσο όρο έκφρασης για όλους τους διαφορετικούς ιστούς που υπάρχουν στο αρχείο.

Hint: Πως παίρνουμε τη θέση του πίνακα με τον μεγαλύτερο αριθμό; [argmax](https://numpy.org/doc/stable/reference/generated/numpy.argmax.html)

### Άσκηση 88
Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι ένας ακέραιος θετικός αριθμός. Η συνάρτηση θα "κατασκευάζει" και θα επιστρέφει έναν 2-διάστατο πίνακα σε numpy ως εξής:

Αν ν==1 επιστρέφει τον πίνακα:
```
1
```

Αν ν==2 επιστρέφει:
```
2 2 2
2 1 2
2 2 2
```

Αν ν==3 επιστρέφει:
```
3 3 3 3 3
3 2 2 2 3
3 2 1 2 3
3 2 2 2 3
3 3 3 3 3
```

Αν ν==4 επιστρέφει:
```
4 4 4 4 4 4 4
4 3 3 3 3 3 4
4 3 2 2 2 3 4
4 3 2 1 2 3 4
4 3 2 2 2 3 4
4 3 3 3 3 3 4
4 4 4 4 4 4 4
```

κτλ...

Η συνάρτησή σας θα πρέπει να επιστρέφει τιμή για οποιοδήποτε θετικό αριθμό  n

Σημείωση 1: Για n==1 επιστρέφει τον πίνακα:
```python
array([[1]])
```

Σημείωση 2: Όταν φτιάχνετε έναν πίνακα (π.χ. με τη np.zeros, np.array, np.ones κτλ) μπορείτε να χρησιμοποιήσετε τη παράμετρο ```dtype=np.int``` , για να είναι όλοι οι αριθμοί ακέραιοι. Για παράδειγμα: ```numpy.array([4,5,6], dtype=numpy.int)```.

### Άσκηση 89
Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι ένα 2-διάστατος numpy πίνακας. Η συνάρτηση θα επιστρέφει ένα νέο πίνακας όπου:
* τα μονά στοιχεία θα έχουν γίνει ζυγά προσθέτοντάς τα κατά 1
* τα άρτια (ζυγά) στοιχεία θα έχουν γίνει μονά αφαιρόντας τα κατά 1

Για παράδειγμα:
```python
a = array([[7, 7, 2, 4],
       [7, 9, 3, 8],
       [4, 4, 6, 5],
       [5, 7, 8, 2]], dtype=np.int)

f(a) 
# Επιστρέφει:
array([[8, 8, 1, 3],
       [8, 10, 4, 7],
       [3, 3, 5, 6],
       [6, 8, 7, 1]])

```

**Σε αυτή την άσκηση (89) απογορεύεται να χρησιμοποιήσετε for/while** 

### Άσκηση 90
Υπάρχει μία πολύ σημαντική κατανομή στη στατιστική η οποία ονομάζεται κατανομή [Poisson](https://en.wikipedia.org/wiki/Poisson_distribution). Η κατανομή αυτή μας δίνει τη πιθανότητα να συμβεί ένα συγκεκριμμένο πλήθος γεγονότων όταν:
* Ο μέσος όρος του ρυθμού που συμβαίνουν αυτά τα γεγονότα είναι σταθερός και γνωστός.
* Τα γεγονότα αυτά είναι ανεξάρτητα μεταξύ τους. 

Για παράδειγμα:
* Σε ένα κατάστημα, μετράμε ότι κατά μέσο όρο κάθε ώρα μπαίνουν 5 πελάτες. Ποια είναι η πιθανότητα σε μία ώρα να μπούν 7 πελάτες;
* Στην αλυσίδα του ανθρώπινου DNA, μετράμε μέσο όρο 10.000 μεταλλάξεων για κάθε 1 εκατομύρια βάσεις (τυχαίο νούμερο). Ποια είναι η πιθανότητα σε μία ακολουθία με μήκος ένα εκατομύριο βάσεις να βρούμε 7.000 μεταλλάξεις; 
* Σε ένα πρωτάθλημα ποδοσφαίρου μετράμε 2.5 γκολ ανά αγώνα. Ποια είναι η πιθανότητα σε έναν αγώνα να μπουν 4 γκολ;

Κανονίκα στα πλαίσια αυτού του μαθήματος θα έπρεπε να διερευνήσουμε το 2ο παράδειγμα. Επειδή όμως αυτό ξεφεύγει από δυσκολία τα πλαίσια μιας απλής άσκησης θα διευρευνήσουμε το.. 3ο παράδειγμα. Η παρακάτω συνάρτηση λοιπόν:

```python
import requests

def get_greek_games():
    r = requests.get('https://www.dropbox.com/s/zy7l0bbno9epiuz/90a79c8e6578e8a371cbb4b6ce10ae43.json?dl=1')
    return r.json()
```

Επιστρέφει μία λίστα με τα αποτελέσματα όλων των παιχνιδιών ποδοσφαίρου στην Ελλάδα στη 1η και 2η Εθνική κατηγορία (ή όπως τις έχουν ονομάσει τέλος πάντων) για τα τελευταία 10 χρόνια. Η λίστα περιέχει πραγματικά αποτελέσματα. Η λίστα έχει τη παρακάτων δομή:

```python
[
    ['Asteras Tripolis FC', 1, 2, 'PAS Giannina FC'],
    ['Xanthi FC', 0, 0, 'PAS Lamia 1964'],
    ['Olympiacos Piraeus FC', 4, 1, 'AE Larissa FC'],
    ...
]
```

Όπου μέσα σε κάθε λίστα το 1ο στοιχείο είναι το όνομα της γηπεδούχος ομάδας, το 2ο στοιχείο είναι τα γκολ που πέτυχε η γηπεδούχος ομάδα, το 3ο στοιχείο είναι τα γκολ που πέτυχε η φιλοξενούμενη ομάδα και το 4ο στοιχείο είναι το όνομα της φιλοξενούμενης ομάδας. 

Ο σκοπός αυτής της άσκησης είναι να βρούμε κατα πόσο τα γκολ που πετυχαίνονται στο ελληνικό πρωτάθλημα ακολουθούν την κατανομή Poisson. H numpy έχει τη συνάρτηση: [np.random.poisson](https://numpy.org/doc/stable/reference/random/generated/numpy.random.poisson.html) η οποία φτιάχνει τυχαίους αριθμούς (ακέραιους) οι οποίοι ακολουθούν αυτή τη κατανομή. Η συνάρτηση παίρνει δύο ορίσματα. Τον σταθερό αριθμό που εκφράζει το "πλήθος των γεγονότων" και τον αριθμό από τυχαία δείγματα που θέλουμε να δημιουργήσει. Για παράδειγμα: Σε ένα κατάστημα, μετράμε ότι κατά μέσο όρο κάθε ώρα μπαίνουν 5 πελάτες. Μπορούμε να φτιάξουμε έναν πίνακα με 20 "ώρες" όπου κάθε στοιχείο του πίνακα θα έχει το πλήθος από πελάτες που μπήκαν στο κατάστημα:

```python
np.random.poisson(5, 20) 
# Επέστρεψε: 
array([ 6,  6,  8,  3,  4,  6,  7,  5,  8,  7,  4,  5, 14,  5,  8,  2,  4,
        5,  5,  5])
# Σημείωση: σε εσάς θα επιστρέψει κάτι διαφορετικό, αφού πρόκειται για τυχαίους αριθμούς. 
```

Δηλαδή ο πίνακας αυτός αποτελεί μία εξομοίωση ενός 20-ωρου λειτουργίας του καταστήματος. 

Πίσω στο ποδόσφαιρο τώρα:

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα:
* Καλεί την ```get_greek_games``` για να έχει μία λίστα με όλα τα αποτελέσματα των αγώνων.
* Υπολογίζει τον μέσο όρο των γκολ ανά αγώνα για όλους τους αγώνες από την παραπάνω λίστα. (Άθροισμα όλων των γκολ / πλήθος από αγώνες)
* Καλεί την np.random.poisson με τον αντίστοιχο μέσο όρο και δημιουργεί 100.000 τυχαίους (ή τεχνιτούς) αγώνες.
* Μετράμε από τους "τεχνιτούς" αγώνες, ποιο είναι το ποσοστό αυτών που το πλήθος από γκολ είναι 0,1,2,...9
* Μετράμε από τους πραγματικούς αγώνες ποιο είναι το ποσοστό αυτών που το πλήθος από γκολ είναι 0,1,2,...9
* Φτιάχνουμε ένα numpy πίνακα διαστάσεων 4 γραμμές επί 10 στήλες:
   * Η 1η γραμμή περιέχει τους αριθμούς 0,1,2,...9
   * Η 2η γραμμή περιέχει τα ποσοστά από τους "τεχνιτούς" αγώνες
   * Η 3η γραμμή περιέχει τα ποσοστά από τους πραγματικούς αγώνες
   * Η 4η γραμμή περιέχει το απόλυτο της διαφοράς της 2ης γραμμής με τη 3η γραμμή. 
* Επιστρέφει τον πίνακα

Δίνεται ότι ο πίνακας που θα επιστρέφει θα πρέπει να έχει τιμές παρόμοιες με:
```python
array([[0.000, 1.000, 2.000, 3.000, 4.000, 5.000, 6.000, 7.000, 8.000, 9.000],
       [0.099, 0.229, 0.262, 0.205, 0.115, 0.053, 0.020, 0.007, 0.002, 0.000],
       [0.102, 0.222, 0.263, 0.213, 0.122, 0.048, 0.020, 0.008, 0.000, 0.001],
       [0.003, 0.006, 0.001, 0.008, 0.007, 0.005, 0.001, 0.001, 0.002, 0.000]])
```

Σημείωση 1: για να φαίνονται με τον παραπάνω τρόπο οι τιμές των δεκαδικών στους πίνακες της numpy μπορείτε να χρησιμοποιήσετε τις παρακάτω εντολές:

```python
float_formatter = "{:.3f}".format
np.set_printoptions(formatter={'float_kind':float_formatter}, linewidth=80)
```

Σημείωση 2: Εννοείται ότι σε εσάς οι τιμές στη 2η και 4η γραμμή θα είναι λίγο διαφορετικές. 

Σημείωση 3: Σε περίπτωση που αναρωτιέστε(;) από που.. προήλθε η λίστα με τα αποτελέσματα των αγώνων ακολουθεί ο κώδικας που τα κατέβασε και το μορφοποίησε:

```python
# Clone / Download data from: https://github.com/openfootball/europe 

import os
import re

def get_games(text):
    a = re.findall(r' ([\w ]+)(\d+)-(\d+) (?:\(\d+-\d+\))?([\w ]+)', text)
    a = [(x[0].strip(), int(x[1]), int(x[2]), x[3].strip()) for x in a]
    return a

def crawl_dir()
    games = []

    for dirpath, dirs, files in os.walk("/Users/admin/europe/greece/"):
        for filename in files:
            fname = os.path.join(dirpath,filename)
            with open(fname) as f:
                data = f.read()
            
            games.extend(get_games(data))

    return games

def do_everything():

    games = crawl_dir()

    with open('greek_football.json', 'w') as f:
        json.dump(games, f)

do_everything()
# Upload greek_football.json to dropbox
```

### Άσκηση 91

Δίνεται η παρακάτω συνάρτηση:

```python
import random
from collections import defaultdict

def create_data_1():
    data = defaultdict(list)
    for x in range(10):

        for y in range(8):
            start = random.randint(1,100)
            end = start + random.randint(5, 20)
            data['region_' + str(x+1)].append((start, end))
            
    return data
```

Η συνάρτηση αυτή επιστρέφει τυχαία data όπου υποθέτουμε ότι έχουν γίνει 10 πειράματα αλληλούχιση ενός χρωμοσώματος μεγέθους 120 βάσεων. Το κάθει πείραμα παράγει 8 ακολουθίες. Η αρχή και το τέλος κάθε ακολουθίας είναι επίσης τυχαία (από το 1 μέχρι και το 120). Τα δεδομένα που επιστρέφει η συνάρτηση είναι ένα dictionary:
* Κλειδιά είναι το όνομα της ακολουθίας: ```region_1```, ```region_2```, ... ```region_10```
* Τιμές είναι ένα πίνακας από διαστήματα. Για παράδειγμα: ```[(55, 61), (74, 85), (30, 45), (81, 91), (74, 90), (45, 51), (7, 21), (40, 46)]```.

Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρος. Η παράμετρος θα είναι ένα dictionary με παρόμοια δομή με αυτό που επιστρέφει η συνάρτηση ```create_data_1```. Η συνάρτηση θα φτιάχνει ένα plot όπου στον x άξονα θα φαίνονται τα διαστήματα της ακολουθίας σαν μια ευθεία γραμμή (για παράδειγμα το διάστημα: 74, 85 θα είναι μία γραμμή η οποία θα ξεκινάει από χ=74 και θα τελειώνει στο χ=85). Στο plot, y θα είναι 1 για το ```region_1```, 2 για το ```region_2```, ..., 10 για το ```region_10```.

Δίνεται ένα παράδειγμα:
```python
data = create_data_1()
f(data)

# Εμφανίζει ένα πλοτ σαν αυτό:
```

![img](https://i.imgur.com/0xZtF0L.png)


### Άσκηση 92
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα κάνει plot τη συνάρτηση: f(x)=sin(1/x) για 10.000 σημεία του x από το -0.5 μέχρι το 0.5. 

Η συνάρτηση η οποία υπολογίζει το ημίτονο στη numpy είναι η ```np.sin```

### Άσκηση 93
Θυμόμαστε όλοι την αγαπημένη μας συνάρτηση ```get_tumour_genes_pos``` που εμφανίστηκε πρώτη φορά στην άσκηση 26. Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν είσοδο μία λίστα από γονίδια σαν αυτά που επιστρέφει η συνάρτηση ```get_tumour_genes_pos```. Η συνάρτηση θα εμφανίζει ένα plot με το ιστόγραμμα του μήκους των γονιδίων της παραμέτρου, μόνο όμως για αυτά που έχουν μήκος μικρότερο απο 100.000 βάσεις.

Μπορείτε να χρησιμοποιήσετε τη histplot συνάρτηση της βιβλιοθήκης seaborn ή όποια άλλη συνάρτηση βρείτε, που κάνει παρόμοια plots. 

### Άσκηση 94 
Η παρακάτω συνάρτηση:
```python
import requests

def get_country_population():
    r = requests.get('https://pkgstore.datahub.io/JohnSnowLabs/population-figures-by-country/population-figures-by-country-csv_json/data/2159fad77778c3b584f3d396593e0af6/population-figures-by-country-csv_json.json')
    j = r.json()
    
    return {x['Country']:x['Year_2016'] for x in j}

```

Επιστρέφει ένα dictionary όπου τα κλειδιά είναι χώρες και τιμές είναι ο πληθυσμός τους το 2016. 

Επίσης, η παρακάτω συνάρτηση:
```python
import pandas as pd

def get_covid_cases():
    a = pd.read_csv('https://raw.githubusercontent.com/EESI/ISM/master/data/total_cases_20200428.csv')
    return a
```

Επιστρέφει ένα pandas DataFrame όπου οι γραμμές είναι ημερομηνίες από 2019-12-31 έως 2020-04-28 και οι στήλες είναι διάφορες χώρες. Τα στοιχεία του πίνακα είναι πόσα κρούσματα είχε μία χώρα (αθροιστικά) από την αρχή της πανδημίας μέχρι αυτή την ημερομηνία. 

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα καλεί την ```get_country_population``` για να πάρει ένα dictionary με τους πληθυσμούς και την ```get_covid_cases``` για να πάρει ένα DataFrame με τα κρούσματα. Η συνάρτηση θα υπολογίζει τον αριθμό από κρούσματα / πληθυσμό για όλες τις χώρες οι οποίες είναι κοινές μεταξύ των δύο data. Για τον αριθμό κρουσμάτων πάρτε τα κρούσματα που υπήρχαν στις 2020-04-28 (τελευταία γραμμή του DataFrame). Στη συνέχεια θα εμφανίζει μία γεωγραφική απεικόνιση (με geo pandas ή με plotly) με αυτόν τον αριθμό για όλες τις κοινές χώρες. 


### Άσκηση 95
Η παρακάτω συνάρτηση:

```python
import pandas as pd

def get_edges():
    a = pd.read_csv('http://genemania.org/data/archive/2017-03-12/Arabidopsis_thaliana/Co-expression.Dean_Rider-Ogas-2003.txt', sep='\t')
    return a
```

Επιστρέφει ένα βιολογικό δίκτυο όπου κόμβοι είναι γονίδια του φυτού Arabidopsis thaliana και ακμές είναι μία εκτίμηση της συσχέτισής τους. Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα φτιάχνει ένα δίκτυο χρησιμοποιώντας τη βιβλιοθήκη networkx. Το δίκτυο αυτό θα έχει μόνο τις ακμές όπου το Weight είναι μικρότερο από 0.009. Στη συνέχεια θα οπτικοποιεί το δίκτυο. Στη συνάρτηση οπτικοποίησης (nx.draw) χρησιμοποιήστε τη παράμετρο: ```node_size=1```.


Ο γράφος θα πρέπει να έχει αυτή τη μορφή:

![img](https://i.imgur.com/htKB55m.png)



