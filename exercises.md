
# Λίστα με ασκήσεις

## Σημειώσεις για όλες τις ασκήσεις
* **ΑΠΑΓΟΡΕΥΕΤΑΙ** να κάνετε: ```a = input("...")``` (και γενικότερα μην το κάνετε ποτέ αυτό..)
* Όταν η εκφώνηση λέει ότι πρέπει να φτιάξετε συνάρτηση.. πρέπει να φτιάξετε συνάρτηση!
* Αν η εκφώνηση λέει ότι η συνάρτηση πρέπει να επιστρέφει κάτι.. τότε μέσα στη συνάρτησή σας πρέπει κάπου να κάνετε ```return```.


## Σημειώσεις για τις ασκήσεις: 1-10
* **ΑΠΑΓΟΡΕΥΕΤΑΙ** η χρήση της ```if``` (αν τη χρησιμοποιείσετε χάνετε τη μισή άσκηση)
* **AΠΑΓΟΡΕΥΕΤΑΙ** να κάνετε: ```return True```  ή ```return False```  (αν το χρησιμοποιείσετε χάνετε τη μισή άσκηση)

Για παράδειγμα, έστω ότι η άσκηση λέει: 

Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν αριθμό. Η συνάρτηση θα πρέπει να επιστρέφει:
* ```True``` αν ο αριθμός είναι μονός
* ```False``` αν ο αριθμός είναι ζυγός (άρτιος).

Τι να **ΜΗΝ** κάνετε:
```python
def f(n):
	if n%2 == 1:
		return True
	else:
		return False

```

Τι να κάνετε:
```python
def f(n):
	return n%2 == 1
```


### Άσκηση 1
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν αριθμό. 
* Αν το υπόλοιπο της διαίρεσης του αριθμού με το 7 είναι μονός θα απιτρέφει: ```True```
* Αν το υπόλοιπο της διαίρεσης του αριθμού με το 7 είναι ζυγός (άρτιος) θα επιστρέφει ```False```

Λύση:
```python
def f(x):
	return (x%7) % 2 == 1
```

### Άσκηση 2
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν αριθμό. 
* Αν ο αριθμός ανήκει στο διάστημα \[100,200\] (δηλαδή είναι μεγαλύτερος ή ίσος από το 100 και μικρότερος ή ίσος από το 200) η συνάρτηση θα επιστρέφει ```True```.
* Aν o αριθμός ΔΕΝ ανήκει στο διάστημα \[100, 200\] η συνάρτηση θα επιστρέφει ```False```.

Λύση:
```python
# 1st solution
def f(x):
	return x>=100 and x<=200

# 2nd solution
def f(x):
	return 100 <= x <= 200
```



### Άσκηση 3
Υπολογίστε και τυπώστε τις τιμές της συνάρτησης:

f(x)=-8x<sup>2</sup> + 5x - 2

Για x=5, x=6, x=7


```python
def f(x):
	return (-8*(x**2)) + (5*x) -2

print (f(5))
print (f(6))
print (f(7))
```

### Άσκηση 4
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν string το οποίο αναπαριστάει μία ακολουθία DNA. Η συνάρτηση θα επιστρέφει ένα string το οποίο θα αποτελείται από το δεύτερο γράμμα κάθε τριπλέτας.

Για παράδειγμα:

Έστω η ακολουθία: ```CAGTGACGTACCGTAGGGCGTAGCGTAACG```

```
Η ακολουθία:
CAGTGACGTACCGTAGGGCGTAGCGTAACG

Σε τριπλέτες:
CAG TGA CGT ACC GTA GGG CGT AGC GTA ACG

Το δεύτερο γράμμα κάθε τριπλέτας είναι:
CAG TGA CGT ACC GTA GGG CGT AGC GTA ACG
 |   |   |   |   |   |   |   |   |   |
 A   G   G   C   T   G   G   G   T   C


Άρα αν f είναι το όνομα της συνάρτησης που θα φτιάξετε, το αποτέλεσμα της εντολής:
f('CAGTGACGTACCGTAGGGCGTAGCGTAACG')

Θα πρέπει να είναι:
'AGGCTGGGTC'
```

Λύση:
```python
def f(x):
	return x[1::3]
```

### Άσκηση 5
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν string το οποίο αναπαριστάει μία ακολουθία DNA. Η συνάρτηση θα επιστρέφει το [CG content](https://en.wikipedia.org/wiki/GC-content) της ακολουθίας. Το GC content υπολογίζεται με βάση τον παρακάτω τύπο:

![img](https://i.imgur.com/oRNebOT.png)

Όπου A,C,G,T είναι το πλήθος των A,C,G,T που υπάρχουν στην ακολουθίας. 

Λύση:
```python
def f(x):
	C = x.count('C')
	G = x.count('G')
	return (C+G) / len(x)
```

### Άσκηση 6
Φτάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα 2 αριθμούς. Ο πρώτος αναπαριστάει τον βαθμό ενός μαθητή στη πρόοδο ενός μαθήματος και ο δεύτερος τον βαθμό στο τελικό διαγώνισμα. Η πρόοδος μετράει για το 40% του τελικού βαθμού και το τελικό διαγώνισμα μετράει για το 60%. Η βάση του μαθήματος είναι το 5. Η συνάρτηση θα πρέπει να επιστρέφει:
* ```True``` αν ο μαθητής περνάει το μάθημα. 
* ```False``` αν ο μαθητής ΔΕΝ περνάει το μάθημα. 


Λύση:
```python
def f(a,b):
	return 0.6*a + 0.4*b > 0.5
```

### Άσκηση 7
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα ένα string το οποίο θα αναπαριστάει μία ακολουθία DNA. Η συνάρτηση θα πρέπει να επιστρέφει:
* ```True``` αν η ακολουθία αποτελείται από 2 αντίγραφα
* ```False``` αν η ακολουθία ΔΕΝ αποτελείται από 2 αντίγραφα.

Μία ακολουθία αποτελείται από δύο αντίγραφα αν το 1ο μισό της είναι ίδιο με το δεύτερο μισό της. Για παράδειγμα:

```
f('AAACCCGGGAAACCCGGG') # Επιστρέφει True
το 1ο μισό της είναι: AAACCCGGG
Το 2ο μισό της είναι: AAACCCGGG


f('AAACCCGGGAAACCCGGT') # Επιστρέφει False
το 1ο μισό της είναι:  AAACCCGGG
το 2ο μισό της είναι:  AAACCCGGT

```

Υποθέστε ότι πάντα η ακολουθία έχει ζυγό (άρτιο) αριθμό από βάσεις. 

Λύση:
```python
def f(x):

	l = len(x)//2
	return x[:l] == x[l:]
```


### Άσκηση 8
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα ένα string το οποίο θα αναπαριστάει μία ακολουθία DNA. Η συνάρτηση θα επιστρέφει:
* ```True``` , Αν οι πουρίνες (A ή G) είναι περισσότερες ή ίσες με τις πυριμιδίνες (T ή C). 
* ```False``` , Aν οι πουρίνες είναι λιγότερες από τις πυριμιδίνες. 

Λύση:
```python
def f(x):

	A = x.count('A')
	C = x.count('C')
	G = x.count('G')
	T = x.count('T')

	return A+G >= G+T 
```

### Άσκηση 9
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα ένα string το οποίο θα αναπαριστάει μία ακολουθία DNA η οποία σε κάποιο υπο-string της περιέχει ένα (και μόνο ένα) ORF ([Open Reading Frame](https://en.wikipedia.org/wiki/Open_reading_frame)). Η συνάρτηση θα επιστρέφει το ORF που περιέχει η ακολουθία. Για αυτή την άσκηση θα θεωρήσουμε ότι το stop codon μπορεί να είναι μόνο ```TAA```. Το start codon είναι: ```ATG```. 

Για παράδειγμα έστω η ακολουθία: 
```
TGCACTGGGGAAAATGTTACCAGGTCCGAACTTATTGAGGTAAGACAGA
```
Παρατηρούμε ότι:
```
TGCACTGGGGAAAATGTTACCAGGTCCGAACTTATTGAGGTAAGACAGA
             ^^^                        ^^^
              |                          |
            start                       stop
            codon                       codon
```


Θα πρέπει η συνάρτησή σας να επιστρέψει το ORF: ```ATGTTACCAGGTCCGAACTTATTGAGGTAA```

Σημείωση: Θεωρούμε ότι τα ```ATG``` και ```ΤΑΑ``` βρίσκονται πάντα σε θέσεις τριπλέτων, δεν χρειάζεται να το ελέγξετε αυτό. 

Λύση:
```python
def f(x):

	start = x.index('ATG')
	end = x.index('TAA') + 3
	return x[start:end]
```

### Άσκηση 10
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα ένα string το οποίο θα αναπαριστάει μία ακολουθία DNA. H συνάρτησή σας θα πρέπει να επιστρέφει:
* ```True``` αν υπάρχει το start codon (```ATG```) στην ακολουθία **KAI** αν αυτό βρίσκεται σε θέση που να διαρείται με το 3 (δηλαδή όντως αποτελεί κωδικόνιο)
* ```False``` αν δεν ισχύει η παραπάνω συνθήκη. 

Για παράδειγμα:

```
f('AAAATGGGG') # Επιστρέφει True: To ATG είναι στη 3η θέση (μετρώντας από το 0) 
f('TAAAATGGGG') # Επιστρέφει False: To ATG είναι στη 4η θέση (μετρώντας από το 0)
f('AAACCCGGG') # Επιστρέφει False: Δεν υπάρχει το ATG μέσα στην ακολουθία
```

Λύση:
```python
# 1st solution 
def f(x):
	return x.count('ATG') > 0 and x.index('ATG')%3 == 0

# 2nd solution 
def f(x):
	return 'ATG' in x and x.index('ATG')%3 == 0

# 3rd solution 
def f(x):
	return x.find('ATG')%3 == 0

```


## Ασκήσεις 11-20

### Άσκηση 11
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν όρισμα δύο παραμέτρους: το ΒΜΙ και το gender. Η συνάρτηση θα κάνει τους εξής υπολογισμούς:
* Αν το gender είναι ```"male"``` τότε:
   * Αν το BMI > 32 επιστρέφει ```"overweight"```
   * Αν το BMI <= 32 επιστρέφει ```"not overweight"```
* Αν το gender είναι ```"female"``` τότε:
   * Αν το BMI > 30 επιστρέφει ```"overweight"```
   * Αν το BMI <= 30 επιστρέφει ```"not overweight"```

Λύση:
```python
# 1st solution
def f(BMI, gender):
	if gender == 'male':
		if BMI > 32:
			return "overweight"
		return "not overweight"
	if gender == "female":
		if BMI > 30:
			return "overweight"
		return "not overweight"


#2nd solution
def f(BMI, gender):

	overweight = (gender == 'male' and BMI > 32) or (gender == 'female' and BMI > 30)
	if overweight:
		return 'overweight'

	return "not overweight"
```

### Άσκηση 12
Σύμφωνα με [αυτό το site](https://alen.space/basic-guide-nanosatellites/) υπάρχει μία κατηγοριοποίηση των δορυφόρων σε σχέση με το βάρος τους. Η κατηγοριοποίηση αυτή είναι:

```
    Large satellites: More than 1,000 kg
    Medium-sized satellites: 500-1,000 kg
    Small satellites:
        Minisatellite: 100-500 kg
        Microsatellite: 10-100 kg
        Nanosatellite: 1-10 kg
        Picosatellite: Less than 1 kg
```

Βλέπουμε λοιπόν ότι υπάρχουν τρεις βασικές κατηγορίες: ```"Large satellites"```, ```"Medium-sized satellites"``` και ```"Small satellites"```. Οι Small satellites χωρίζονται σε 4 υποκατηγορίες: ```Minisatellite```, ```Microsatellite```, ```Nanosatellite``` και ```Picosatellite```. 

Φτιάξτε λοιπόν μία συνάρτηση η οποία θα παίρνει σαν παράμετρο τη μεταβλήτή: ```weight```. Ανάλογα με τον πίνακα παραπάνω η συνάρτηση θα επιστρέφει σε **ένα** string με τη κατηγορία και την υποκατηγορία (αν υπάρχει) του δορυφόρου με αυτή το βάρος. Για παράδειγμα:

```
f(1500) # Επιστρέφει: "Large satellite"
f(750)  # Επιστρέφει: "Medium-sized satellite"
f(200)  # Επιστρέφει: "Small satellite - Minisatellite"
f(0.5)  # Επιστρέφει: "Small satellite - Picosatellite"
``` 

Για τις οριακές τιμές επιστρέφουμε τη μικρότερη δυνατή κατηγορία. 

Λύση:
```python
def f(x):
	if x > 1000:
		return 'Large satellit'

	if x > 500:
		return 'Medium-sized satellites'

	if x > 100:
		return 'Small satellites - Minisatellite'

	if x > 10:
		return 'Small satellites - Microsatellite'

	if x > 1:
		return 'Small satellites - Nanosatellite'

	return 'Small satellites - Picosatellite'
```

### Άσκηση 13
Σε [αυτό το site](https://life-greece.gr/prostima-kok-gia-alkool-2019) υπάρχει ένας πίνακας με τα χρηματικά πρόστιμα για την οδήγηση υπό την επήρεια αλκοόλ. Αφού αναλογιστείτε πόσο επικίνδυνο είναι για εσάς και τους υπόλοιπους η οδήγηση υπό την επήρεια αλκοόλ φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν παράμετρο τη μεταβλητή alcohol. Η συνάρτηση θα επιστρέφει:

* Αν το alcohol < 0.25, επιστρέφει τον ακέραιο 0
* Αν το alcohol είναι από 0.25 μέχρι και 0.4 επιστρέφει τον ακέραιο 200
* Αν το alcohol είναι μεγαλύτερο από 0.4 μέχρι και 0.6 επιστρέφει τον ακέραιο 700
* Αν το alcohol είναι μεγαλύτερο από 0.6, επιστρέφει τον ακέραιο 3000

Λύση:
```python
def f(x):
	if alcohol < 0.25:
		return 0

	if alcohol <= 0.4:
		return 200

	if alcohol <= 0.6:
		return 700

	return 3000
```

### Άσκηση 14
Φτιάξτε μία συνάρτηση σε python, τέτοια ώστε όταν γράφω:
```
f(1)
```

Να επιστρέφει ```"Hello"```

Όταν γράφω:
```
f(f(1))
```
Να επιστρέφει ```"Mitsos"```

Όταν γράφω:
```
f(f(f(1)))
```
Να επιστρέφει: ```"Maria"```

```python
def f(x):

	if x == 1:
		return 'Hello'

	if x == 'Hello':
		return 'Mitsos'

	if x == 'Mitsos':
		return 'Maria'
```

### Άσκηση 15
Φτιάξτε δύο συναρτήσεις σε python με το όνομα ```f``` και ```g```. Και οι δύο συναρτήσεις θα πρέπει να παίρνουν σαν παράμετρο έναν ακέραιο και να επιστρέφουν έναν ακέραιο. Οι συναρτήσεις θα πρέπει να είναι τέτοιες ώστε η τιμή της έκφρασης:

```
f(g(1)+g(2)) + g(f(1)+f(2))
```

να είναι 3. 

Λύση:
```python
def f(x):
	return x

def g(x):
	return x-1
```

### Άσκηση 16
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν παράμετρο 2 αριθμούς: a,b. H συνάρτηση θα πρέπει να λύνει την εξίσωση ```ax+b=0``` με τον εξής τρόπο:

* Αν το a είναι 0 τότε:
   * Αν το b είναι 0 τότε επιστρέφει ```"TAYTOTHTA"```
   * Αν το b δεν είναι 0 τότε επιστρέφει: ```"ADYNATH"```
* Αν το a δεν είναι 0 τότε επιστρέφει τη τιμή: ```-b/a```.

Λύση:
```python
def f(a,b):
	if a == 0:
		if b == 0:
			return 'TAYTOTHTA'
		return 'ADYNATH'

	return -b/a
```

### Άσκηση 17
Ισχύει το εξής:

* Ένα ναυτικό μίλι είναι 1.852 χιλιόμετρα. 
* Ένα χιλιόμετρο είναι 0.62137 μίλια.

Φτιάξτε τη συνάρτηση ```nautical_miles_to_km``` η οποία θα παίρνει σαν παράμετρο έναν αριθμό ο οποίος θα αναπαριστά μία απόσταση σε ναυτικά μίλια και θα επιστρέφει την ίδια απόσταση εκφρασμένη σε χιλιόμετρα.

Φτιάξτε τη συνάρτηση ```km_to_miles``` η οποία θα παίρνει σαν παράμετρο έναν αριθμό ο οποίος θα αναπαριστά μία απόσταση σε χιλιόμετρα και θα επιστρέφει την ίδια απόσταση εκφρασμένη σε μίλια.

Φτιάξτε τη συνάρτηση ```nautical_miles_to_miles``` η οποία θα παίρνει σαν παράμετρο έναν αριθμό ο οποίος θα αναπαριστά μία απόσταση σε ναυτικά μίλια και θα επιστρέφει την ίδια απόσταση εκφρασμένη σε μίλια. Σε αυτή τη συνάρτηση είναι υποχρεωτικό να χρησιμοποιήσετε τις συναρτήσεις ```nautical_miles_to_km``` και ```km_to_miles```.

Λύση:
```python
def nautical_miles_to_km(x):
	return x*1.852

def km_to_miles(x):
	return x*0.62137

def nautical_miles_to_miles(x):
	return km_to_miles(nautical_miles_to_km(x))
```

### Άσκηση 18
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει 3 παραμέτρους. Και οι 3 θα είναι αριθμοί. Η συνάρτηση θα επιστρέφει τον μεσαίο. Για παράδειγμα:

```
f(5,3,6) # Επιστρέφει: 5
f(3,4,5) # Επιστρέφει: 4
f(3,3,4) # Επιστρέφει: 3
f(3,3,3) # Επιστρέφει: 3
```

**Απαγορεύεται να χρησιμοποιήσετε ```max```, ```min```, ```sort```.**

Λύση:
```python
def f(x):
	if (b<=a and a<=c) or (c<=a and a<=b):
		return a
	if (a<=b and b<=c) or (c<=b and b<=a):
		return b

	return c

```

### Άσκηση 19
Φτιάξτε μία συνάρτηση με το όνομα ```reverse``` η οποία θα παίρνει σαν παράμετρο μία ακολουθία DNA. H συνάρτηση θα επιστρέφει την αντίστροφή της (reverse). Για παράδειγμα:

```
reverse('ACGT') # Επιστρέφει: "TGCA"
reverse('AGTCCG') # Επιστρέφει: "GCCTGA"
```

Φτιάξτε μία συνάρτηση με το όνομα ```complement``` η οποία θα παίρνει σαν παράμετρο μία ακολουθία DNA. H συνάρτηση θα επιστρέφει την συμπληρωματική ακολουθία της. Για να φτιάξετε τη συμπληρωματική ακολουθία πρέπει να κάνετε τις εξής αντικαταστάσεις:

* Αντικαταστήστε τα ```A``` με ```T```
* Αντικαταστήστε τα ```T``` με ```A```
* Αντικαταστήστε τα ```C``` με ```G```
* Αντικαταστήστε τα ```G``` με ```C```

* **ΑΠΑΓΟΡΕΥΕΤΑΙ** να χρησιμοποιήσετε biopython ή κάποια βιβλιοθήκη που κάνει αυτό. 
* Hint: 

Έστω το string ```"mitsos"```. Πως θα αντικαταστούσατε το "s" με "ο" και τα "ο" με "s" ;
Αν κάνετε:
```
a = 'mitsos'
a = a.replace('s', 'o')
a = a.replace('o', 's')
print (a)
```
Το αποτέλεσμα είναι: ```"mitsss"``` (γιατί;)

Ένα κόλπο είναι το εξής:
```
a = 'mitsos'
a = a.replace('s', '1')
a = a.replace('o', '2')
a = a.replace('1', 'o')
a = a.replace('2', 's')
print (a)
```

Λύση:
```python

def reverse(x):
	return x[::-1]

def complement(x):
	t = x.replace('A', '1').replace('C', '2').replace('G', '3').replace('T', '4')
	t = t.replace('1', 'T').replace('2', 'G').replace('3', 'C').replace('4', 'A')

	return t
```

### Άσκηση 20
Φτιάξτε μία συνάρτηση με το όνομα ```reverse_complement``` η οποία θα παίρνει σαν όρισμα μία ακολουθία DNA. H συνάρτηση θα επιστρέφει την αντίστροφη συμπληρωματική ακολουθία της. Για παράδειγμα:

```
f('AGTCCG') # Επιστρέφει: "CGGACT" 
```

Μπορείτε να επιβεβαίωσετε τα αποτελέσματά σας με [αυτό το online tool](http://arep.med.harvard.edu/labgc/adnan/projects/Utilities/revcomp.html).

Συνίσταται (δεν είναι υποχρεωτικό) να χρησιμοποιήσετε τις συναρτήσεις ```reverse``` και ```complement``` της άσκησης 19. 

Λύση:
```python
def reverse_complement(x):
	return complement(reverse(x))
```

## Ασκήσεις 21-30

**Για τις ασκήσεις 21-25 δίνεται η παρακάτω συνάρτηση**

```python
import requests

def get_tumor_gene_names():
	r = requests.get('http://mygene.info/v3/query?q=tumor&fields=symbol&size=1000&species=human')
	j = r.json()

	return [x['symbol'] for x in j['hits']]
```

Η συνάρτηση αυτή χρειάζεται το πακέτο requests της python. Αν δεν είναι εγκαταστημένο στον υπολογιστή σας μπορείτε να το εγκαταστήσετε τρέχoντας σε ένα κελί στο jupyter:

```bash
!pip install requests
```

Η συνάρτηση ```get_tumor_gene_names()``` επιστρέφει μία λίστα με γονίδια τα οποία έχουν εντοπιστεί ότι εμπλέκονται στον καρκίνο.

### Άσκηση 21
Φτιάξτε μία συνάρτηση η οποία παίρνει μία παράμετρο. Η παράμετρος είναι μία λίστα με strings. Η συνάρτηση θα επιστρέφει μία νέα λίστα η οποία θα περιέχει τα strings της παραμέτρου τα οποία ξεκινάνε από ```"IL"```

Χρησιμοποιώντας τη συνάρτηση την οποία φτιάξατε και τη συνάρτηση ```get_tumor_gene_names()``` απαντήστε στην ερώτηση: Ποια γονίδια που εμπλέκονται στον καρκίνο είναι ιντερλευκίνες;

### Άσκηση 22
Φτιάξτε μία συνάρτηση με το όνομα ```ask_22_a``` η οποία θα παίρνει μία παράμετρο. Αυτή η παράμετρος είναι μία λίστα από strings. Η συνάρτηση θα επιστρέφει μία νέα λίστα η οποία θα έχει τα στοιχεία της περαμέτρου αλλά θα είναι ταξινομημένη με βάση το μήκος του string (από το μικρότερο στο μεγαλύτερο). 

Χρησιμοποιώντας τη συνάρτηση που μόλις φτιάξατε (τη ```ask_22_a```) και τη ```get_tumor_gene_names()```, φτιάξτε μία άλλη συνάρτηση με το όνομα ```ask_22_b``` η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει την απάντηση στην ερώτηση: Ποια είναι τα 10 γονίδια με το μεγαλύτερο όνομα τα οποία εμπλέκονται στον καρκίνο;

### Άσκηση 23
Φτιάξτε μία συνάρτηση με το όνομα ```ask_23_a``` η οποία θα παίρνει μία παράμετρο. Αυτή η παράμετρος είναι μία λίστα από strings. Η συνάρτηση θα επιστρέφει τη λίστα της περαμέτρου όπου όμως σε κάθε στοιχείο της θα έχετε αφαιρέσει όλους τους αριθμούς. Για παράδειγμα θα πρέπει:

```python
l = ['C1QTNF3', 'CD274', 'TNFRSF21']
f(l) # Επιστρέφει: ['CQTNF', 'CD', 'TNFRSF']
```
Χρησιμοποιώντας τη συνάρτηση ```ask_23_a```, τη συνάρτηση ```ask_22_a``` της άσκησης 22 και τη συνάρτηση ```get_tumor_gene_names()```, φτιάξτε μία νέα συνάρτηση με το όνομα ```ask_23_b``` η οποία δεν θα παίρνει κάποιο όρισμα. Η συνάρτηση θα επιστρέφει την απαντήση στην ερώτηση: Αν αφαιρέσουμε τους αριθμούς από τα ονόματα των γονιδίων, ποια είναι τα 10 γονίδια με το μεγαλύτερο όνομα τα οποία εμπλέκονται στον καρκίνο; (Τυπώστε τα αλλαγμένα ονόματα)

### Άσκηση 24
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα επιστρέφει έναν αριθμό ο οποίος θα είναι το πλήθος των γονιδίων που εμπλέκονται στον καρκίνο και ΔΕΝ έχουν κάποιον αριθμό στον όνομά τους. 

### Άσκηση 25
Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι μία λίστα από strings. Η συνάρτηση θα επιστρέφει το στοιχείο της λίστας που έχει το μικρότερο μήκος. Αν δύο ή περισσότερα στοιχεία έχουν το ίδιο μικρότερο μήκος, τότε θα επιστρέφει αυτό που είναι μικρότερο αλφαβητικά. Για παράδειγμα:

```python
a =['lll', 'kkk', 'aaaa']

f(a) # Επιστρέφει "kkk" (είναι το μικρότερα αλφαβητικά και έχει το μικρότερο δυνατό μήκος)
f(get_tumor_gene_names()) # Επιστρέφει: ANG 

```

Αν χρησιμοποιήσετε 2 φορές τη sorted στην Άσκηση 25, χάνετε 2 μονάδες (8/10)

**Για τις ασκήσεις 26-30 δίνεται η παρακάτω συνάρτηση:**

```python
import requests

def get_tumour_genes_pos():
    url = 'http://mygene.info/v3/query?q=tumor'
    url += '&fields=symbol,genomic_pos.chr,genomic_pos.start,genomic_pos.end'
    url += '&size=1000&species=human'
    
    r = requests.get(url)
    j = r.json()

    list_1 = [
    	[
        	x['symbol'], 
        	(x['genomic_pos'][0] if type(x['genomic_pos']) is list else x['genomic_pos']),
    	] for x in j['hits'] if 'genomic_pos' in x]

    list_2 = [
    	[
    		x[0], x[1]['chr'], x[1]['start'], x[1]['end']
    	] for x in list_1 if not 'CHR' in x[1]['chr']]

    return list_2
```

Αν τρέξετε αυτή τη συνάρτηση θα επιστρέψει πάλι τα γονίδια τα οποία έχουν εμπλακεί στον καρκίνο αλλά αυτή τη φορά για κάθε γονίδιο θα έχουμε μία λίστα. 

Για παράδειγμα, ας τυπώσουμε τα πρώτα δέκα γονίδια:
```python
genes = get_tumour_genes_pos()
genes[:10]
```
Τυπώνει (ίσως σε εσάς να τυπώσει διαφορετική λίστα):
```
[['TPD52', '8', 80034745, 80231232],
 ['TP53', '17', 7661779, 7687538],
 ['TSG101', '11', 18468336, 18526951],
 ['TP63', '3', 189631389, 189897276],
 ['TP73', '1', 3652516, 3736201],
 ['TUSC3', '8', 15417215, 15766649],
 ['TUSC7', '3', 116709235, 116723581],
 ['PTTG2', '4', 37960398, 37961128],
 ['TUSC8', '13', 44400250, 44405984],
 ['TUSC1', '9', 25676389, 25678440]]
```

* το 1ο στοιχείο είναι το όνομα ενός γονιδίου
* το 2ο στοιχείο είναι το χρωμόσωμα στο οποίο ανήκει
* το 3ο στοιχείο είναι η αρχή του γονιδίου πάνω στο χρωμόσωμα
* το 4ο στοιχείο είναι το τέλος του γονιδίου πάνω στο χρωμόσωμα 


### Άσκηση 26
Φτιάξτε μία συνάρτηση η οποία παίρνει μία παράμετρο. Η παράμετρος είναι μία λίστα όπως η λίστα που επιστρέφει η ```get_tumour_genes_pos()```. Η συνάρτηση θα επιστρέφει το όνομα του γονιδίου με το μεγαλύτερο μήκος. Το μήκος ενός γονιδίου είναι η διαφορά του τέλους από την αρχή του. Για παράδειγμα το μήκος του γονιδίου TPD52 είναι: 80231232-80034745=196487

### Άσκηση 27
Φτιάξτε μία συνάρτηση η οποία παίρνει μία παράμετρο. Η παράμετρος είναι μία λίστα όπως η λίστα που επιστρέφει η ```get_tumour_genes_pos()```. Η συνάρτηση θα επιστρέφει μία λίστα με τα ονόματα των γονιδίων της λίστας της παραμέτρου ταξινομημένα ανάλογα με τη θέση τους στο γονιδίωμα. Πρώτα πάνε τα γονίδια που είναι στο χρωμόσωμα 1, μετά τα γονίδια που είναι στο χρωμόσωμα 2, ... μετά το χρωμόσωμα 22 μετά το Χ και στο τέλος το Υ. Τα γονίδια που είναι στο ίδιο χρωμόσωμα ταξινομούνται με βάση την θέση της αρχής τους στο χρωμόσωμά τους. 

### Άσκηση 28
Φτιάξτε μία συνάρτηση η οποία παίρνει μία παράμετρο. Η παράμετρος είναι μία λίστα όπως η λίστα που επιστρέφει η ```get_tumour_genes_pos()```. Η συνάρτηση θα επιστρέφει το μέσο όρο του μήκους των γονιδίων που περιέχει. 

Μέσος όρος της λίστας ```a = [4,5,6,6]``` είναι ```sum(a)/len(a)```

### Άσκηση 29
Φτιάξτε μία συνάρτηση η οποία θα παίρνει δύο παράμετρους. Η πρώτη θα είναι μία λίστα όπως η λίστα που επιστρέφει η ```get_tumour_genes_pos()``` και η δεύτερη θα είναι το όνομα ενός χρωμοσώματος (π.χ. ```"4"```). H συνάρτηση θα επιστρέφει το πλήθος των γονιδίων της λίστας που ανήκουν σε αυτό το χρωμόσωμα.


π.χ.
```python
f(genes, '4') # Επιστρέφει 32
f(genes, '1') # Επιστρέφει 94 
f(genes, '21') # Επιστρέφει 8
```

**Προσοχή:** Σε εσάς ίσως επιστρέφει λίγο διαφορετικές τιμές. Η συνάρτηση ```get_tumour_genes_pos()``` ενδέχεται να επιστρέφει ένα ελαφρώς διαφορετικό σετ από γονίδια κάθε φορά που τη καλείτε. Αυτό είναι ΟΚ! Απλά το site από όπου "τραβάει" τα δεδομένα αυτή η συνάρτηση δεν εγγυάται ότι θα επιστρέφει πάντα τα ίδια.
 
### Άσκηση 30
Φτιάξτε μία συνάρτηση η οποία παίρνει μία παράμετρο. Η παράμετρος είναι μία λίστα, όπως αυτή που επιστρέφει η συνάρτηση ```get_tumour_genes_pos()```. Η συνάρτηση θα επιστρέφει το όνομα του γονίδιου του οποίου το μήκος έχει τη μικρότερη απόσταση από το μέσο όρο του μήκους όλων των γονιδίων. 

Πως βρίσκουμε την απόσταση μεταξύ των αριθμών ```a``` και ```b```: ```abs(a-b)```. 

### Άσκηση 31
Γράψτε μία συνάρτηση η οποία θα παίρνει ως όρισμα 3 ακέραιους αριθμούς τους a,b,c. Η συνάρτηση θα επιστρέφει το άθροισμα όλων των αριθμών από το a μέχρι και το b οι οποίοι διαιρούνται με το c. Για παράδειγμα:

```
f(23, 258, 7) # επιστρέφει 4620
```

### Άσκηση 32
Γράψτε μία συνάρτηση η οποία θα παίρνει ένα όρισμα. Το όρισμα θα είναι μία λίστα με αριθμούς. Η συνάρτηση θα επιστρέφει το γινόμενο των αντίστροφων των στοιχείων της λίστας τα οποία δεν είναι 0. Ο αντίστροφος ενός αριθμού a είναι το 1/a.  

Για παράδειγμα:

f([2, 4, 0, 0.1]) # επιστρέφει 1/2 * 1/4 * 1/0.1 = 1.25 

### Άσκηση 33
Ένας πληθυσμός με το όνομα Α αποτελείται από 20 ανθρώπους. Σε αυτούς τους ανθρώπους κάναμε γονοτύπηση σε 10 γενετικούς τόπους. Όλοι οι γονότυποι είναι δι-αλληλικοί (biallelic). Κάθε ένας από τους 10 γενετικούς τόπους έχει όνομα Μ1, Μ2, ... Μ10. Τα αποτελέσματα που πήραμε υπάρχουν σε αυτή τη λίστα:

```python
pop_A = [
	['M1', 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 2, 1, 0, 1, 1, 1, 0, 1],
	['M2', 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 1, 0],
	['M3', 1, 1, 1, 0, 0, 2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 1, 0, 2, 1],
	['M4', 1, 1, 0, 0, 0, 0, 1, 2, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
	['M5', 0, 0, 2, 2, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 0, 2],
	['M6', 0, 0, 1, 0, 2, 0, 0, 0, 1, 1, 2, 2, 2, 0, 0, 0, 1, 0, 0, 0],
	['M7', 0, 0, 2, 1, 1, 1, 0, 2, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0],
	['M8', 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 0, 0, 2],
	['M9', 0, 0, 1, 0, 0, 1, 2, 1, 0, 0, 1, 1, 1, 1, 0, 2, 1, 0, 2, 1],
	['M10', 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1]
]
```

Σε αυτή τη λίστα οι αριθμοί 0,1,2 σημαίνουν:
* 0: Ο γονότυπος είναι ομόζυγος στο πρωτεύον αλλήλιο
* 1: Ο γονότυπος είναι ετερόζυγος
* 2: Ο γονότυπος είναι ομόζυγος στο δευτερεύον αλλήλιο.

Ή αλλιώς τα 0,1,2 είναι το πλήθος των δευτερεύοντων αλλήλιων που έχει ο αντίστοιχος γονότυπος. 

Φτιάξτε μία συνάρτηση ο οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι μία λίστα όπως η ```pop_A```. Η συνάρτηση θα επιστρέφει το όνομα του γονότυπου με τη μεγαλύτερη αλληλική συχνότητα του δευτερεύοντος αλλήλιου. Για παράδειγμα θα πρέπει:

```python
f(pop_A) # Επιστρέφει 'Μ9'
```

### Άσκηση 34
Κάνουμε τον ίδιο πείραμα σε έναν άλλο πληθυσμό ο οποίος όμως τώρα έχει 25 άτομα. Τα αποτελέσματα της γονοτύπησης υπάρχουν στη παρακάτω λίστα: 

```python
pop_B = [
	['M1', 2, 1, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 1, 0, 1, 0, 2, 0, 1, 0, 2, 0, 1], 
	['M2', 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 2, 0, 0, 0],
	['M3', 1, 1, 0, 2, 1, 1, 0, 0, 2, 0, 2, 0, 0, 1, 0, 1, 0, 0, 0, 2, 0, 0, 0, 1, 1],
	['M4', 0, 0, 1, 0, 2, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 2, 1, 1, 0, 0, 2],
	['M5', 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 2, 0, 1, 0, 0, 2, 1, 1, 0, 1, 0, 0, 0, 0],
	['M6', 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 1, 2, 1, 0, 2, 1, 0],
	['M7', 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 2, 0, 2, 2],
	['M8', 0, 2, 0, 0, 1, 0, 1, 2, 0, 0, 0, 2, 0, 0, 1, 1, 0, 0, 0, 1, 2, 0, 1, 0, 0],
	['M9', 1, 1, 1, 0, 0, 2, 0, 1, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 2, 1, 0],
	['M10', 1, 0, 0, 2, 0, 0, 0, 1, 0, 0, 2, 2, 0, 2, 1, 0, 1, 2, 0, 0, 1, 0, 0, 1, 1]
]

```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει δύο παράμετρους Α και Β. Κάθε παράμετρος θα είναι μία λίστα όπως η pop_A και pop_B. Η συνάρτηση θα επιστρέφει το όνομα του γενετικού τόπου του οποίου η αλληλική συχνότητα του δευτερεύοντος αλλήλιου έχει τη μεγαλύτερη απόλυτη διαφορά μεταξύ των πληθυσμών Α και Β. 

### Άσκηση 35
[Αυτό το άρθρο της wikipedia](https://en.wikipedia.org/wiki/Genetic_distance) έχει έναν κατάλογο με μετρικές για την μέτρηση της γενετικής απόστασης μεταξύ δύο πληθυσμών με βάση τις αλληλικές τους συχνότητες. Αυτό το άρθρο είναι αρκετά κακογραμμένο και μπορείτε να το αγνοήσετε!

Καταρχήν θα ορίσουμε τη αλληλική συχνότητα P<sub>γ,α,π</sub> ως τη συχνότητα του αλλήλιου α στον γενετικό τόπο γ στον πλυθυσμό π. Για παράδειγμα ο πληθυσμός pop_A (θα τον αναφέρουμε σαν Α) έχει για κάθε έναν από τους 10 γενετικούς τόπους, 2 διαφορετικά αλλήλια (το πρωτεύον και το δευτερεύον). Στον γενετικό τόπο ```Μ1``` έχουμε τον γονότυπο από 20 ανρθώπους:

```python
print (pop_A[0][1:])
[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 2, 1, 0, 1, 1, 1, 0, 1]
```

Εδώ παρατηρούμε οτι έχουμε 11 φορές το 0, 8 φορές το 1 και μία φορά το 2. Άρα:
* Το πρωτεύον αλλήλιο υπάρχει: 11\*2 + 8\*1 = 30 φορές.
* Το δευτερεύον αλλήλιο υπάρχει: 8\*1 + 1\*2 = 10 φορές. 

Άρα το P<sub>1,πρωτεύον,Α</sub> είναι 30/40 . Ή αλλιώς η συχνότητα του πρωτεύοντος αλλήλιου στον γενετικό τόπο 1 στον πληθυσμό Α είναι 30/40. Ομοίως: P<sub>1,δευτερεύον,Α</sub> είναι 10/40. Ή αλλιώς η συχνότητα του δευτερεύοντος αλλήλιου στον γενετικό τόπο 1 στον πληθυσμό Α είναι 10/40.

Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 παραμέτρους. Και οι δύο παράμετροι θα είναι λίστες με το όνομα Α και Β. Οι λίστες θα έχουν την ίδια μορφή όπως και οι λίστες ```pop_A``` και ```pop_B```. Η συνάρτηση θα επιστρέφει την ευκλίδεια απόσταση (Rogers Euclidean distance) μεταξύ των πληθυσμών ```A``` και ```B```, η οποία ορίζεται ως εξής:

* Για κάθε γενετικό τόπο j (Μ1 έως Μ10) υπολογίστες τα P<sub>j,δευτερεύον,Α</sub> και P<sub>j,δευτερεύον,Β</sub>. Στη συνέχεια υπολογίστε τη διαφορά τους και στη συνέχεια υπολογίστε το τετράγωνο αυτής της διαφοράς.
* Υπολογίστε το άθροισμα αυτού του τετραγώνου για όλους τους γενετικούς τόπους (Μ1 έως Μ10).
* Υπολογίστε (και επιστρέψτε) τη τετραγωνική ρίζα αυτού του αθροίσματος 

H τετραγωνική ρίζα του a είναι: ```a**0.5```


Δίνεται ότι:
```python
f(pop_A, pop_B) # Επιστρέφει: 0.265 
```

### Άσκηση 36
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 παραμέτρους. Και οι δύο παράμετροι θα είναι λίστες με το όνομα X και Y. Οι λίστες θα έχουν την ίδια μορφή όπως και οι λίστες ```pop_A``` και ```pop_B```.  Η συνάρτηση θα επιστρέφει την "Nei's minimum genetic distance 1973" μεταξύ των πληθυσμών ```X``` και ```Y``` η οποία υπολογίζεται ως εξής [πηγή](https://dyerlab.github.io/applied_population_genetics/genetic-distances.html):


<!-- OLD ![img](https://i.imgur.com/qde8a4d.png) -->
<!-- 
I=\frac{\sum_{i=1}^{L} \left ( \sum_{j=1}^{l_{i}} \left ( p_{ij,x}p_{ij,y} \right ) \right ) }{\sqrt{\sum_{i=1}^{L} \left ( \sum_{j=1}^{l_{i}} \left ( p_{ij,x}^{2} \right ) \right )}\sqrt{\sum_{i=1}^{L} \left ( \sum_{j=1}^{l_{i}} \left ( p_{ij,y}^{2} \right ) \right )}}
-->
![img](https://i.imgur.com/kpYmmcp.png)


Όπου:
* L είναι το πλήθος από γενετικούς τόπους (10 στη περίπτωσή μας)
* l<sub>i</sub> είναι το πλήθος από αλλήλια στον γενετικό τόπο i. Στη δική μας περίπτωση έχουμε πάντα 2 (bi-allelic)
* p<sub>ij,x</sub> είναι η συχνότητα του αλληλίου j στον γενετικό τόπο i, στον πληθυσμό X
* p<sub>ij,y</sub> είναι η συχνότητα του αλληλίου j στον γενετικό τόπο i, στον πληθυσμό Y

Δίνεται ότι:
```python
f(pop_A, pop_B) # Επιστρέφει: 0.9886664715207936
```


### Άσκηση 37
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 παραμέτρους. Και οι δύο παράμετροι θα είναι λίστες με το όνομα X και Y. Οι λίστες θα έχουν την ίδια μορφή όπως και οι λίστες ```pop_A``` και ```pop_B```. Η συνάρτηση θα επιστρέφει την "Cavalli-Sforza chord distance" μεταξύ των πληθυσμών ```pop_A``` και ```pop_B```, σύμφωνα με τον μαθηματικό τύπο ([πηγή](https://www.montana.edu/kalinowski/documents/2002_Genetic_distances_review_MolecularEcology.pdf)):

<!-- 
	D=1-\sum_{j=1}^{2}\left ( \sum_{i=1}^{L} \left ( \frac{\sqrt{p_{ij,x}\cdot p_{ij,y}}}{L} \right ) \right )
-->
![img](https://i.imgur.com/jFdqr3e.png)

<!-- ![img](https://i.imgur.com/qm3WRxQ.png) -->

Όπου:
* L είναι το πλήθος από γενετικούς τόπους (10 στη περίπτωσή μας)
* p<sub>ij,x</sub> είναι η συχνότητα του αλληλίου j στον γενετικό τόπο i, στον πληθυσμό X
* p<sub>ij,y</sub> είναι η συχνότητα του αλληλίου j στον γενετικό τόπο i, στον πληθυσμό Y

Δίνεται ότι:
```python
f(pop_A, pop_B) # Επιστρέφει 0.004909335749700872
```

### Άσκηση 38
Αφού έχετε φτιάξει τις φανταστικές συναρτήσεις σας, ζητάτε από έναν συνάδελφο να σας στείλει τα δεδομένα του. Ο συνάδελφος σας στέλνει την εξής λίστα:

```python
pop_C= [
   ['M1', 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 2, 0, 1, 1, 0, 0, 2, 0, 1, 1, 0],
   ['Μ2', 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 2, 0],
   ['M3', 1, 0, 2, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 2, 1, 0, 0, 0, 1, 1, 0, 2, 1, 0],
   ['M4', 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 2, 0, 0, 1, 0, 1, 0, 0, 0, 2, 0, 0, 0], 
   ['M5', 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 0, 2, 0, 1, 0, 0, 1, 0],
   ['M6', 0, 0, 0, 0, 2, 0, 1, 1, 0, 1, 0, 4, 2, 1, 0, 1, 1, 0, 1, 1, 0, 1, 2, 0, 1],
   ['M7', 0, 0, 0, 2, 1, 0, 1, 0, 2, 0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 1, 0, 1, 0, 0],
   ['M8', 2, 0, 0, 0, 0, 2, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2],
   ['M9', 1, 0, 0, 0, 1, 0, 2, 0, 0, 2, 0, 1, 2, 0, 1, 0, 0, 1, 2, 0, 0, 0, 1, 1, 0],
   ['M10', 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 2, 1],
   ['M11', 0, 1, 0, 2, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 1, 2],
   ['M12', 0, 1, 0, 1, 1, 2, 1, 1, 0, 2, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0]

]

```  

Με τρόμο παρατηρείτε ότι η λίστα έχει προβλήματα! Υπάρχει γονότυπος με αριθμό 4 και ένας άλλος με αριθμό 5! Επίσης ο γενετικός τόπος ```'Μ11'``` έχει λιγότερους γονότυπους από ότι οι υπόλοιποι γενετικοί τόποι! 

Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρο θα είναι μία λίστα (με τη μορφή που έχουν οι λίστες pop_A, pop_B, pop_C). H συνάρτηση σας θα επιστρέφει:
* ```False``` αν όλοι οι γενετικοί τόποι δεν έχουν το ίδιο πλήθος από γονότυπους.
* ```False``` αν υπάρχει έστω και ένας γονότυπος του οποίου οι τιμές ΔΕΝ είναι 0,1,2
* ```True``` αν δεν ισχύει καμία από τις παραπάνω συνθήκες. 

Για παράδειγμα θα πρέπει:
```python
f(pop_A) # Επιστρέφει True
f(pop_B) # Επιστρέφει True
f(pop_C) # Επιστρέφει False
```


### Άσκηση 39
Αφού επικοινωνείτε με τον συνάδελφό σας, του καταδεικνύετε τα λάθη που έχει κάνει! Ο συνάδελφος σας ζητάει συγγνώμη και σας στέλνει διορθωμένη τη λίστα. Η νέα λίστα είναι η εξής:

```python
pop_D = [
	['M1', 'M2', 'M3', 'M4', 'M5', 'M6', 'M7', 'M8', 'M9', 'M10'], 
	[0, 2, 0, 0, 1, 1, 1, 0, 1, 0], 
	[1, 1, 1, 0, 0, 0, 0, 0, 0, 1], 
	[0, 0, 2, 0, 1, 2, 0, 0, 0, 1], 
	[0, 0, 0, 2, 2, 0, 0, 0, 0, 0], 
	[0, 0, 0, 2, 1, 0, 1, 0, 0, 0], 
	[1, 2, 0, 0, 0, 2, 0, 0, 2, 0], 
	[0, 1, 0, 0, 0, 1, 0, 0, 0, 0], 
	[0, 0, 0, 0, 0, 0, 0, 1, 0, 0], 
	[1, 2, 0, 0, 0, 0, 1, 0, 0, 0], 
	[0, 1, 0, 1, 0, 0, 1, 0, 0, 2], 
	[0, 0, 0, 1, 0, 0, 0, 0, 0, 1], 
	[1, 1, 2, 0, 2, 0, 1, 0, 0, 0], 
	[0, 1, 2, 0, 2, 1, 1, 0, 0, 2], 
	[0, 0, 1, 0, 0, 1, 2, 1, 0, 2], 
	[0, 0, 1, 0, 2, 1, 0, 1, 1, 0], 
	[0, 1, 0, 0, 0, 0, 0, 0, 0, 0], 
	[0, 0, 1, 0, 0, 1, 1, 0, 1, 1], 
	[0, 0, 0, 0, 2, 2, 0, 2, 0, 0], 
	[1, 1, 0, 1, 1, 0, 1, 0, 1, 0], 
	[1, 0, 0, 2, 1, 1, 0, 1, 2, 2], 
	[1, 2, 0, 1, 0, 1, 0, 0, 1, 0], 
	[0, 0, 1, 0, 1, 1, 0, 1, 0, 0], 
	[0, 0, 2, 0, 2, 0, 0, 0, 1, 0], 
	[0, 1, 0, 1, 2, 0, 1, 0, 1, 0], 
	[0, 0, 2, 1, 1, 0, 0, 2, 1, 0],
]
```

Πάλι παρατηρείτε ότι κάτι δεν πάει καλά.. Παίρνετε τηλέφωνο τον συνάδελφο και σας εξηγεί ότι η νέα λίστα έχει σε κάθε υπολίστα έναν άνθρωπο. Η πρώτη υπολίστα έχει τα ονόματα των γενετικών τόπων. Η 2η έχει τους γονότυπους για τον 1ο άνθρωπο, η 3η για τον δεύτερο, η 4η για τον τρίτο κτλ. Για παράδειγμα η δεύτερη υπολίστα: ```[0, 2, 0, 0, 1, 1, 1, 0, 1, 0]``` περιέχει τους γονότυπους για τον 1ο άνθρωπο. Οπότε ο 1ος άνθρωπος στον γενετικό τόπο ```Μ1``` έχει γονότυπο 0, στον γενετικό τόπο ```Μ2``` έχει γονότυπο 2, στον γενετικό τόπο ```Μ3``` έχει γονότυπο 0 κτλ.. 

Εξηγείτε στον συνάδελφο ότι οι αλγόριθμοί σας δέχονται λίστες με διαφορετική διάταξη. Ο συνάδελφός σας όμως δηλώνει ότι δεν έχει ιδέα πως να μετατρέψει τη λίστα στη μορφή που πρέπει γιατί δεν έχει παρακολουθήσει το μάθημα ΒΙΟΛ-494. Ευτυχώς εσείς έχετε! 

Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι μία λίστα όπως είναι η pop_D. Η συνάρτηση θα κάνει τους ανάλογους μετασχηματισμούς έτσι ώστε η λίστα να έχει τη μορφή που έχει η λίστα pop_A ή η λίστα pop_B. 

Για παράδειγμα: 
```python
f(pop_D) 
# Θα πρέπει να επιστρέφει τη λίστα:
[
	['M1', 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], 
	['M2', 2, 1, 0, 0, 0, 2, 1, 0, 2, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 1, 0], 
	['M3', 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 1, 0, 1, 0, 0, 0, 0, 1, 2, 0, 2], 
	['M4', 0, 0, 0, 2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 0, 0, 1, 1], 
	['M5', 1, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0, 2, 2, 0, 2, 0, 0, 2, 1, 1, 0, 1, 2, 2, 1], 
	['M6', 1, 0, 2, 0, 0, 2, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 2, 0, 1, 1, 1, 0, 0, 0], 
	['M7', 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 2, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0], 
	['M8', 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 1, 0, 1, 0, 0, 2], 
	['M9', 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 2, 1, 0, 1, 1, 1], 
	['M10', 0, 1, 1, 0, 0, 0, 0, 0, 0, 2, 1, 0, 2, 2, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0],
]

```

### Άσκηση 40 
Η λίστα:
```python
genes = ['Gene_1', 'Gene_2', 'Gene_3', 'Gene_4', 'Gene_5', 'Gene_6', 'Gene_7', 'Gene_8', 'Gene_9', 'Gene_10']
```
Περιέχει τα ονόματα από 10 γονίδια.

Η λίστα:
```python
sizes = [2957, 8379, 9365, 5377, 9243, 5636, 4984, 9238, 6779, 7745]
```
Περιέχει το μέγεθός τους. 

H λίστα:
```python
cancer = [True, True, True, True, True, True, True, False, True, False]
```
περιέχει το αν εμπλέκονται σε μελέτες με καρκίνο (True) ή όχι (False).

Φτιάξτε μία συνάρτηση η οποία θα παίρνει 3 παραμέτρους. Και οι τρεις παράμετροι θα είναι λίστες με το ίδιο μέγεθος όπως οι λίστες ```genes```, ```sizes``` και ```cancer```. Η συνάρτηση θα επιστρέφει μία λίστα με τους αριθμούς από τα ονόματα των γονιδίων που εμπλέκονται στον καρκίνο και το μέγεθός τους είναι μεγαλύτερο από 5000. Για παράδειγμα:

```python
f(genes, sizes, cancer) # Επιστρέφει [2, 3, 4, 5, 6, 9]
```

**Κάποιες σημειώσεις για τις υπόλοιπες ασκήσεις**
* Απαγορεύεται να χρησιμοποιήσετε μεταβλήτές με το όνομα: max, min, sum, type, id, str, int, list, dict, tuple, set. Αυτά είναι ονόματα συναρτήσεων της python. Αν και η python αφήνει τη χρήση τους (κακώς..) σαν ονόματα μεταβλητών, αυτό έχει τη συνέπεια ότι μετά ΔΕΝ μπορείτε να τις χρησιμοποιήσετε. Δοκιμάστε:

```python
print (min([4,5,3])) #  Δουλεύει κανονικά 
min=5
print (min([4,5,3])) # Ουπς !
```

* Απαγορεύεται να χρησιμοποιήσετε μεταβλητή που ΔΕΝ ((έχει οριστεί στη συνάρτηση που ανήκει) 'Η (είναι παράμετρος της συνάρτησης)). Και αυτό σας αφήνει η python να το κάνετε, αλλά ειδικά σε αρχάριους προγραμματιστές δημιουργεί σύγχηση όσον αφορά τι πρέπει να βάλετε σε μία συνάρτηση και τι όχι. Για παράδειγμα: Μία συνάρτηση η οποία επιστρέφει αν o τελευταίος χαρακτήρας ενός string είναι αριθμός: 

Λάθος:
```python
a = 'asdfasdf3'
last = a[-1]

def f(x):
	is_it = last.is_digit() # To last έχει οριστεί έξω από τη συνάρτηση. Επίσης τι το κάνουμε το x της παραμέτρου;
	return is_it

```

Σωστό:
```python
def f(x):
	last = x[-1]
	is_it = last.is_digit()
	return is_it
```

Παρόλα αυτά εννοείται ότι επιτρέπεται να χρησιμοποιήσουμε συναρτήσεις που έχουν οριστεί έξω από τη συνάρτησή μας. 

### Άσκηση 41
Φτιάξτε μία συνάρτηση η οποία να παίρνει δύο παράμετρους. Οι παράμετροι είναι και οι δύο dictionaries, τα Α και το Β. Η συνάρτηση θα πρέπει να επιστρέφει ένα νέο dictionary το οποίο θα έχει τα κλειδιά του Α που δεν υπάρχουν στο Β και τα κλειδιά του Β που δεν υπάρχουν στο Α, με τις αντίστοιχες τιμές τους. Για παράδειγμα:

```python
A = {
	'kwstas': 1,
	'george': 2,
	'elenh': 3,
}

B = {
	'mitsos': 2,
	'kwstas': 3,
	'elenh': 1,
}


f(A,B) 
# Επιστρέφει:

{
	'george': 2,
	'mitsos': 2,
}
# Το "kwstas" και το "mitsos" υπάρχουν και στα δύο dictionaries (A και Β) για αυτό δεν 
# υπάρχουν στο dictionary που επέστρεψε η συνάρτηση.
``` 

### Άσκηση 42
Φτιάξτε μία συνάρτηση η οποία να παίρνει δύο παράμετρους. Οι παράμετροι είναι και οι δύο dictionaries, τα Α και το Β. Τα dictionaries είναι τέτοια που οι τιμές τους είναι ακέραιοι. Η συνάρτηση θα πρέπει να επιστρέφει ένα νέο dictionary το οποία θα πρέπει να έχει ΜΟΝΟ τα κλειδιά που ανήκουν και στο Α και στο Β. Η τιμή του κάθε κλειδιού θα είναι ο μέσος όρος των τιμών αυτού του κλειδιού στα dictionary Α και Β. Για παράδειγμα:

```python
A = {
	'kwstas': 1,
	'george': 2,
	'elenh': 3,
}

B = {
	'mitsos': 2,
	'kwstas': 3,
	'elenh': 2,
}


f(A,B)
# Επιστρέφει:
{
	'kwstas': 2.0, # (1+3)/2
	'elenh': 2.5 # (2+3)/2
}

```

### Άσκηση 43
Η λίστα:
```python
genes = ['Gene_1', 'Gene_2', 'Gene_3', 'Gene_4', 'Gene_5', 'Gene_6', 'Gene_7', 'Gene_8', 'Gene_9', 'Gene_10']
```
Περιέχει τα ονόματα από 10 γονίδια.

Η λίστα:
```python
sizes = [2957, 8379, 9365, 5377, 9243, 5636, 4984, 9238, 6779, 7745]
```
Περιέχει το μέγεθός τους. 

H λίστα:
```python
cancer = [True, True, True, True, True, True, True, False, True, False]
```
περιέχει το αν εμπλέκονται σε μελέτες με καρκίνο (True) ή όχι (False).

Φτιάξτε μία συνάρτηση η οποία θα παίρνει 3 παραμέτρους. Και οι τρεις παράμετροι θα είναι λίστες με το ίδιο μέγεθος όπως οι λίστες ```genes```, ```sizes``` και ```cancer```. Η συνάρτηση θα επιστρέφει ένα dictionary όπου:
* τα κλειδιά θα είναι τα genes
* Οι τιμές θα είναι ένα dictionary με τα εξής ζευγάρια κλειδί/τιμή:
   * 'size': περιέχει τις τιμές του sizes
   * 'cancer': περιέχει τις τιμές του cancer 

Για παράδειγμα:
```python
genes = ['Gene_1', 'Gene_2', 'Gene_3', 'Gene_4', 'Gene_5', 'Gene_6', 'Gene_7', 'Gene_8', 'Gene_9', 'Gene_10']
sizes = [2957, 8379, 9365, 5377, 9243, 5636, 4984, 9238, 6779, 7745]
cancer = [True, True, True, True, True, True, True, False, True, False]

f(genes, sizes, cancer) 
# Επιστρέφει:
{
	'Gene_1': {'size': 2957, 'cancer': True},
	'Gene_2': {'size': 8379, 'cancer': True},
	...
	'Gene_10': {'size': 7745, 'cancer': False},
}
```

### Άσκηση 44
Φτιάξτε μία συνάρτηση η οποία θα κάνει το αντίθετο από ότι η άσκηση 43. Η συνάρτηση θα δέχεται μία παράμετρο. Η παράμετρος θα είναι ένα dictionary όπως αυτό που επιστρέφει η άσκηση 43. Η συνάρτηση θα επιστρέφει τρεις λίστες:
* Η πρώτη θα είναι τα κλειδιά του dictionary της παραμέτρου.
* Η δεύτερη θα είναι η τιμή του κλειδιού "size", της κάθε τιμής του dictionary της παραμέτρου.
* Η τρίτη θα είναι η τιμή του κλειδιού "cancer", της κάθε τιμής του dictionary της παραμέτρου.

Παράδειγμα:
```python
A = {
	'Gene_1': {'size': 2957, 'cancer': True},
	'Gene_2': {'size': 8379, 'cancer': True},
	'Gene_10': {'size': 7745, 'cancer': False},
}

f(A)

k,l,m  = f(A)

print (k) # τυπώνει: ['Gene_1', 'Gene_2', 'Gene_10']
print (l) # τυπώνει [2957, 8379, 7745]
print (m) # τυπώνει [true, True, False]

```

### Άσκηση 45 
Το [MESH](https://en.wikipedia.org/wiki/Medical_Subject_Headings) είναι ένα λεξικό το οποίο περιέχει ιατρικούς και βιολογικούς όρους. Το Mesh υπάρχει από τη δεκαετία του 1960, και τα τελευταία 10 χρόνια περίπου είναι διαθέσιμο μόνο από το διαδίκτυο. Μία εγγραφή στο MESH είναι ένα string όπως το παρακάτω:

```python

MESH_record = '''
RECTYPE = D
MH = Calcimycin
AQ = AA AD AE AG AI AN BI BL CF CH CL CS EC HI IM IP ME PD PK PO RE SD ST TO TU UR
ENTRY = A-23187|T109|T195|LAB|NRW|NLM (1991)|900308|abbcdef
ENTRY = A23187|T109|T195|LAB|NRW|UNK (19XX)|741111|abbcdef
ENTRY = Antibiotic A23187|T109|T195|NON|NRW|NLM (1991)|900308|abbcdef
ENTRY = A 23187
ENTRY = A23187, Antibiotic
MN = D03.633.100.221.173
PA = Anti-Bacterial Agents
PA = Calcium Ionophores
MH_TH = FDA SRS (2014)
MH_TH = NLM (1975)
ST = T109
ST = T195
N1 = 4-Benzoxazolecarboxylic acid, 5-(methylamino)-2-((3,9,11-trimethyl-8-(1-methyl-2-oxo-2-(1H-pyrrol-2-yl)ethyl)-1,7-dioxaspiro(5.5)undec-2-yl)methyl)-, (6S-(6alpha(2S*,3S*),8beta(R*),9beta,11alpha))-
RN = 37H9VM9WZL
RR = 52665-69-7 (Calcimycin)
PI = Antibiotics (1973-1974)
PI = Carboxylic Acids (1973-1974)
MS = An ionophorous, polyether antibiotic from Streptomyces chartreusensis. It binds and transports CALCIUM and other divalent cations across membranes and uncouples oxidative phosphorylation while inhibiting ATPase of rat liver mitochondria. The substance is used mostly as a biochemical tool to study the role of divalent cations in various biological systems.
OL = use CALCIMYCIN to search A 23187 1975-90
PM = 91; was A 23187 1975-90 (see under ANTIBIOTICS 1975-83)
HN = 91(75); was A 23187 1975-90 (see under ANTIBIOTICS 1975-83)
MR = 20160527
DA = 19741119
DC = 1
DX = 19840101
UI = D000001
'''

```

Παρατηρούμε ότι αυτό το string έχει πολλές γραμμές. Κάθε γραμμή αρχίζει με το όνομα ενός πεδίου. Στη συνέχεια υπάρχει ένα ``` = ``` και στη συνέχεια η τιμή αυτού του πεδίου.

Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι ένα string το οποίο θα αναπαριστάει μία εγγραφή στη MESH (όπως το παράδειγμα παραπάνω). Η συνάρτηση θα επιστρέφει ένα dictionary. Τα κλειδιά του dictionary θα είναι τα ονόματα των πεδίων της εγγραφής και οι τιμές του dictionary θα είναι οι τιμές αυτών των πεδίων. Για παράδειγμα:

```python
f(A)
# Επιστρέφει:

{
	 'RECTYPE': 'D',
	 'MH': 'Calcimycin',
	 'AQ': 'AA AD AE AG AI AN BI BL CF CH CL CS EC HI IM IP ME PD PK PO RE SD ST TO TU UR',
	 'ENTRY': 'A23187, Antibiotic',
	 'MN': 'D03.633.100.221.173',
	 'PA': 'Calcium Ionophores',
	 'MH_TH': 'NLM (1975)',
	 'ST': 'T195',
	 'N1': '4-Benzoxazolecarboxylic acid, 5-(methylamino)-2-((3,9,11-trimethyl-8-(1-methyl-2-oxo-2-(1H-pyrrol-2-yl)ethyl)-1,7-dioxaspiro(5.5)undec-2-yl)methyl)-, (6S-(6alpha(2S*,3S*),8beta(R*),9beta,11alpha))-',
	 'RN': '37H9VM9WZL',
	 'RR': '52665-69-7 (Calcimycin)',
	 'PI': 'Carboxylic Acids (1973-1974)',
	 'MS': 'An ionophorous, polyether antibiotic from Streptomyces chartreusensis. It binds and transports CALCIUM and other divalent cations across membranes and uncouples oxidative phosphorylation while inhibiting ATPase of rat liver mitochondria. The substance is used mostly as a biochemical tool to study the role of divalent cations in various biological systems.',
	 'OL': 'use CALCIMYCIN to search A 23187 1975-90',
	 'PM': '91; was A 23187 1975-90 (see under ANTIBIOTICS 1975-83)',
	 'HN': '91(75); was A 23187 1975-90 (see under ANTIBIOTICS 1975-83)',
	 'MR': '20160527',
	 'DA': '19741119',
	 'DC': '1',
	 'DX': '19840101',
	 'UI': 'D000001'
 }

```


### Άσκηση 46

Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι ένα θετικός ακέραιος αριθμός. Η συνάρτηση θα επιστρέφει τον επόμενο πρώτο αριθμό ο οποίος είναι μεγαλύτερος από τη παράμετρο. Για παράδειγμα:

```python
f(10) # Επιστρέφει 11
f(11) # Επιστρέφει 13
f(15) # Επιστρέφει 17
```

### Άσκηση 47
Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι ένας θετικός ακέραιος αριθμός. Η συνάρτηση θα επιστρέψει τον μεγαλύτερο πρώτο αριθμό ο οποίος είναι μικρότερος από τη παράμετρο. Για παράδειγμα:

```python
f(10) # Επιστρέφει 7
f(100) # Eπιστρέφει 97
``` 

### Άσκηση 48
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα επιστρέφει την απάντηση στο παρακάτω ερώτημα. Ας υποθέσουμε ότι έχουμε 1000 ευρώ και κάθε μήνα ξοδεύουμε το 10% του ποσού που έχουμε. Μετά από πόσους μήνες το ποσό που θα έχει μείνει θα είναι λιγότερο από 100 ευρώ;

### Άσκηση 49
Φτιάξτε μία συνάρτηση με το όνομα ```fact``` η οποία θα δέχεται μία παράμετρο. Η παράμετρος θα είναι ένας θετικός ακέραιος αριθμός. Η συνάρτηση θα επιστρέφει το παραγοντικό του αριθμού αυτού. Το παραγοντικό ενός αριθμού ```N```, συμβολίζεται με ```Ν!``` και είναι ίσο με το γινόμενο: ```1 * 2 * .. * Ν-1 * Ν```.

Ο [αριθμός e](https://en.wikipedia.org/wiki/E_%28mathematical_constant%29) είναι ίσος με 2.718281828459...  Επίσης γνωρίζουμε ότι ο αριθμός αυτό μπορεί να προσεγγιστεί με την παρακάτω σειρά:

![img](https://i.imgur.com/I3mS3Hu.png)

Όσο περισσότερους όρους βάλουμε σε αυτή τη σειρά, τόσο καλύτερη προσέγγιση του e θα κάνουμε. Φτιάξτε λοιπόν μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα υπολογίζει προσεγγιστικά και θα επιστρέφει το ```e``` χρησιμοποιώντας τον παραπάνω μαθηματικό τύπο. Για τον υπολογισμό του e, προσθέστε όσους όρους χρειαστούν μέχρι ο τελευταίος όρος που θα προσθέσετε να γίνει μικρότερος από 0.0001. Συνίσταται να χρησιμοποιήσετε τη συνάρτηση ```fact```. 

### Άσκηση 50
Δίνεται η παρακάτω συνάρτηση:

```python
import requests

def get_disease_gene_names(disease):
	r = requests.get(f'http://mygene.info/v3/query?q={disease}&fields=symbol&size=1000&species=human')
	j = r.json()

	return {x['symbol'] for x in j['hits']}
```

Αυτή η συνάρτηση παίρνει σαν όρισμα ένα string το οποίο αναπαριστάει έναν φαινότυπο (ασθένεια ή μη) ή μία βιολογική λειτουργία. Η συνάρτηση επιστρέφει ένα σύνολο από γονίδια τα οποία έχουν συσχετιστεί με αυτόν το string. 

Φτιάξτε μία συνάρτηση η οποία δεν παίρνει κανένα όρισμα. Η συνάρτηση θα πρέπει να επιστρέφει ένα **σύνολο** με τα γονίδια τα οποία: Εμπλέκονται στη παχυσαρκία (```'obesity'```) KAI στον μεταβολισμό (```'metabolism'```) αλλά δεν έχουν συσχετιστεί με κάποιο λιπίδιο (```'lipids'```).


### Άσκηση 51
Δίνεται η παρακάτω συνάρτηση:

```python
import requests
def get_pi_1M():
	r = requests.get('https://www.angio.net/pi/digits/pi1000000.txt')
	return r.text
```

Αυτή η συνάρτηση επιστρέφει ένα string το οποίο περιέχει το π (3.14159...) στις πρώτες 1.000.000 θέσεις. Γράψτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα επιστρέφει τη θέση πάνω στο π όπου ο αριθμός 7 γίνεται για πρώτη φορά ο πιο κοινός αριθμός του π. 

Για παράδειγμα: τα πρώτα 100 ψηφία του π είναι:
```
3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
```

Ας μετρήσουμε πόσα ψηφία υπάρχουν για κάθε θέση του π:


```
Θέση 1
3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
|
3:1 φορά
Ποιο κοινό ψηφίο: 3
```
```
Θέση 2
3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
  |
  3:1 φορά
  1:1 φορά
Ποιο κοινό ψηφίο: Κανένα (ισοπαλία μεταξύ 3 και 1)
```

```
Θέση 3:
3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
   |
   3:1 φορά
   1:1 φορά
   4:1 φορά
Ποιο κοινό ψηφίο: Κανένα (ισοπαλία μεταξύ 3, 1 και 4)
```

```
Θέση 4:
3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
    |
    3:1 φορά
    1:2 φορές
    4:1 φορά
Ποιο κοινό ψηφίο: το 1
```

Εδώ παρατηρούμε ότι στη θέση 4, το 1 γίνεται το πιο κοινό ψηφίο του π για πρώτη φορά!

Ποια λοιπόν είναι η αντίστοιχη θέση για το 7;


### Άσκηση 52
Φτιάξτε μία συνάρτηση η οποία παίρνει σαν παράμετρο έναν ακέραιο αριθμό. Η συνάρτηση δημιουργεί ένα αρχείο με το όνομα factors.txt. Το αρχείο περιέχει τόσες γραμμές όσες ο αριθμός της παραμέτρου. Η i-οστή γραμμή περιέχει όλους τους παράγοντες του i από το 1 μέχρι και το i διαχωρισμένοι με κόμματα. Οι παράγοντες ενός αριθμού είναι οι αριθμοί που τον διαρούν τέλεια. H συνάρτηση δεν επιστρέφει τίποτα. Για παράδειγμα:

```python
f(10)

# Δημιουργεί το αρχείο factors.txt το οποίο θα πρέπει να μπορώ να το τυπωσω με:
with open('factors.txt') as f:
	data = f.read()

print (data)
# θα πρέπει να τυπώνει:
'''
1
1,2
1,3
1,2,4
1,5
1,2,3,6
1,7,
1,2,4,8
1,3,9
1,2,5,10
'''
```

### Άσκηση 53
Γράψτε κώδικα python τέτοιον ώστε όταν γράφω:

```python
f()()[0]()
```

Να επιστρέφεται η τιμή: ```"Μήτσος"```

### Άσκηση 54
Σε αυτό το site: https://ftp.ncbi.nlm.nih.gov/gene/DATA/GENE_INFO/Mammalia/ θα βρείτε το αρχείο: Homo_sapiens.gene_info.gz. Το αρχείο αυτό μπορείτε να το κατεβάσετε και απευθείας με αυτό το link: https://ftp.ncbi.nlm.nih.gov/gene/DATA/GENE_INFO/Mammalia/Homo_sapiens.gene_info.gz . Το αρχείο αυτό είναι συμπιεσμένο οπότε θα πρέπει και να το αποσυμπιέσετε. Το αποσυμπιεσμένο αρχείο ονομάζεται: ```Homo_sapiens.gene_info```. To αρχείο είναι tab delimited (οι στήλες δηλαδή είναι χωρισμένες με τον χαρακτήρα tab) και περιέχει διάφορες πληροφορίες για τα γονίδια στο ανθρώπινο γονιδίωμα. Η πρώτη γραμμή του αρχείου περιέχει την επικεφαλίδα (header) η οποία περιέχει τους τίτλους των στηλών. Η επικεφαλίδα είναι:

```text
#tax_id	GeneID	Symbol	LocusTag	Synonyms	dbXrefs	chromosome	map_location	description	type_of_gene	Symbol_from_nomenclature_authority	Full_name_from_nomenclature_authority	Nomenclature_status	Other_designations	Modification_date	Feature_type
``` 

Το αρχείο μπορείτε να το ανοίξετε και από το excel (ή από το Google sheets). Μπορείτε να google-άρετε: "how to open tab delimited file in excel" για να βρείτε πως γίνεται αυτό.

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα string. Η παράμετρος αυτή θα είναι το όνομα ενός αρχείου το οποίο θα έχει την ίδια δομή όπως το ```Homo_sapiens.gene_info```. Η συνάρτηση θα πρέπει να επιστρέφει ένα dictionary. Τα keys του dictionary θα είναι οι τιμές στη στήλη με το όνομα: ```Symbol```. Τα values του dictionary θα πρέπει να είναι οι αντίστοιχες τιμές στη στήλη: ```description```. 

Για παράδειγμα θα πρέπε να μπορώ να γράφω:
```python
d = f('Homo_sapiens.gene_info')
print (d['A1BG']) # Τυπώνει: "alpha-1-B glycoprotein" 
print (d['GLP1R']) # Τυπώνρι: "glucagon like peptide 1 receptor"
```

### Άσκηση 55
Ας θεωρήσουμε πάλι το ίδιο αρχείο με την άσκηση 54. Η στήλη ```Synonyms``` του αρχείου περιέχει τα συνώνυμα για κάθε γονίδιο. Οι τιμές αυτής της στήλης είναι strings διαχωρισμένα με τον χαρακτήρα ```|```. Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα string. Η παράμετρος αυτή θα είναι το όνομα ενός αρχείου το οποίο θα έχει την ίδια δομή όπως το ```Homo_sapiens.gene_info```. Η συνάρτηση θα πρέπει να επιστρέφει ένα dictionary. Τα keys του dictionary θα είναι οι τιμές στη στήλη με το όνομα: ```Symbol```. Τα values του dictionary θα πρέπει να είναι μία λίστα με όλα τα συνώνυμα του γονιδίου όπως υπάρχουν στη στήλη ```Synonyms```. Για παράδειγμα θα πρέπει να μπορώ να γράφω:

```python
d = f('Homo_sapiens.gene_info')
print (d['A1BG']) # Τυπώνει: ['A1B', 'ABG', 'GAB', 'HYST2477']
print (d['HCN2']) # Τυπώνει: ['BCNG-2', 'BCNG2', 'HAC-1']
```

### Άσκηση 56
Aς θεωρήσουμε πάλι το ίδιο αρχείο με την άσκηση 54. Η στήλη ```chromosome``` περιέχει το χρωμόσωμα στο οποίο ανήκει το γονίδιο. Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 παράμετρους. Η πρώτη παράμετρος θα είναι ένα string με το όνομα filename, το οποίο θα είναι το όνομα ενός αρχείου το οποίο θα έχει την ίδια δομή με το ```Homo_sapiens.gene_info```. H δεύτερη παράμετρος με το όνομα chromosome θα είναι ένα string με το όνομα ενός χρωμοσώματος. Η συνάρτηση θα δημιουργεί ένα αρχείο με το όνομα: ```Homo_sapiens_CHROMOSOME.gene_info``` όπου το ```CHROMOSOME``` θα πρέπει να το αντικαταστήσετε με τη τιμή της παραμέτρου chromosome. Το περιεχόμενο του αρχείου θα είναι ακριβώς το ίδιο με αυτό του αρχείου filename αλλά θα περιέχει μόνο τα γονίδια που ανήκουν στο χρωμόσωμα της παραμέτρου. Η συνάρτηση θα πρέπει να επιστρέψει το όνομα του αρχείου που δημιούργησε. Για παράδειγμα:

```python
filename = f('Homo_sapiens.gene_info', '7')

# Ανοίγω το αρχείο που δημιούργησε και τυπώνω τις πρώτες 6 γραμμές
with open(filename) as f:
	for l_number, line in enumerate(f):
		print (line.strip('\n'))
		if l_number>=5:
			break

#To παραπάνω τυπώνει:
'''
#tax_id	GeneID	Symbol	LocusTag	Synonyms	dbXrefs	chromosome	map_location	description	type_of_gene	Symbol_from_nomenclature_authority	Full_name_from_nomenclature_authority	Nomenclature_status	Other_designations	Modification_date	Feature_type
9606	26	AOC1	-	ABP|ABP1|DAO|DAO1|KAO	MIM:104610|HGNC:HGNC:80|Ensembl:ENSG00000002726	7	7q36.1	amine oxidase copper containing 1	protein-coding	AOC1	amine oxidase copper containing 1	O	amiloride-sensitive amine oxidase [copper-containing]|amiloride binding protein 1 (amine oxidase (copper-containing))|amiloride-binding protein 1|amiloride-sensitive amine oxidase|amine oxidase copper domain-containing protein 1|diamine oxidase|histaminase|kidney amine oxidase	20210302	-
9606	43	ACHE	-	ACEE|ARACHE|N-ACHE|YT	MIM:100740|HGNC:HGNC:108|Ensembl:ENSG00000087085	7	7q22.1	acetylcholinesterase (Cartwright blood group)	protein-coding	ACHE	acetylcholinesterase (Cartwright blood group)	O	acetylcholinesterase|Yt blood group|acetylcholinesterase (Yt blood group)|apoptosis-related acetylcholinesterase	20210302	-
9606	60	ACTB	-	BRWS1|PS1TP5BP1	MIM:102630|HGNC:HGNC:132|Ensembl:ENSG00000075624	7	7p22.1	actin beta	protein-coding	ACTB	actin beta	O	actin, cytoplasmic 1|I(2)-actin|PS1TP5-binding protein 1|beta cytoskeletal actin	20210307	-
9606	107	ADCY1	-	AC1|DFNB44	MIM:103072|HGNC:HGNC:232|Ensembl:ENSG00000164742	7	7p12.3	adenylate cyclase 1	protein-coding	ADCY1	adenylate cyclase 1	O	adenylate cyclase type 1|3',5'-cyclic AMP synthetase|ATP pyrophosphate-lyase 1|Ca(2+)/calmodulin-activated adenylyl cyclase|adenyl cyclase|adenylate cyclase 1 (brain)|adenylate cyclase type I|adenylyl cyclase 1|adenylyl cyclase subtype 1	20210302	-
9606	117	ADCYAP1R1	-	PAC1|PAC1R|PACAPR|PACAPRI	MIM:102981|HGNC:HGNC:242|Ensembl:ENSG00000078549	7	7p14.3	ADCYAP receptor type I	protein-coding	ADCYAP1R1	ADCYAP receptor type I	O	pituitary adenylate cyclase-activating polypeptide type I receptor|PACAP receptor 1|PACAP type I receptor|PACAP-R1|adenylate cyclase activating polypeptide 1 (pituitary) receptor type I|pituitary adenylate cyclase activating polypeptide 1 receptor type I Hiphop|pituitary adenylate cyclase-activating polypeptide type 1 receptor	20210302	-
'''
```

* Προσοχή 1! Το νέο αρχείο θα πρέπει να έχει και την επικεφαλίδα (header) του filename.
* Προσοχή 2! Υπάρχει ένα γονίδιο του οποίοι η τιμή στη στήλη chromosome είναι: ```10|19|3```. Ανήκει δηλαδή σε τρία χρωμοσώματα! αγνοήστε το. Επίσης υπάρχουν 146 γονίδια τα οποία δεν έχουν τιμή στη στήλη chromosome (η τιμή είναι: ```-```), 66 γονίδια με χρωμόσωμα: ```'Un'```και 66 γονίδια με χρωμόσωμα: ```X|Y```. Αγνοήστε τα όλα αυτά.

### Άσκηση 57
Φτιάξτε μία συνάρτηση με το όνομα ```ask_57_a``` η οποία θα παίρνει σαν παράμετρο ένα string. Η παράμετρος αυτή θα είναι το όνομα ενός αρχείου το οποίο θα έχει την ίδια δομή όπως το αρχείο ```Homo_sapiens.gene_info```. Η συνάρτηση θα χρησιμοποιεί την συνάρτηση της άσκησης 56 για να "σπάσει" το αρχείο σε πολλά αρχεία όπου το κάθε αρχείο θα έχει και από ένα χρωμόσωμα. Θεωρήστε μόνο τα χρωμοσώματα: 1,2,3,...,22,Χ,Υ,ΜΤ. Το χρωμόσωμα ενός αρχείο υπάρχει στη στήλη με το όνομα: ```chromosome```. Θα πρέπει δηλαδή η συνάρτηση να φτιάχνει τα αντίστοιχα αρχεία:  ```Homo_sapiens_1.gene_info```, ```Homo_sapiens_2.gene_info```, ... ```Homo_sapiens_22.gene_info```, ```Homo_sapiens_Χ.gene_info```, ```Homo_sapiens_Υ.gene_info```, ```Homo_sapiens_ΜΤ.gene_info```. H συνάρτηση θα επιστρέφει μία λίστα με τα αρχεία που δημιούργησε.

Φτιάξτε μία συνάρτηση με το όνομα ```ask_57_b``` η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι μία λίστα από strings. Κάθε strings θα είναι και το όνομα ενός αρχείου το οποίο θα έχει την ίδια δομή όπως το αρχείο ```Homo_sapiens.gene_info```. Η συνάρτηση θα ενώνει όλα τα αρχεία της λίστας της παραμέτρου σε ένα αρχείο. Το αρχείο θα σώζεται με όνομα: ```Homo_sapiens_MERGED.gene_info```. Αυτό το αρχείο θα πρέπει να έχει την ίδια δομή με το αρχείο ```Homo_sapiens.gene_info``` και τα γονίδια που περιέχει να είναι ταξινομήμα αλφαβητικά σύμφωνα με τη στήλη ```Symbol```. H συνάρτηση θα επιστρέφει το string: ```Homo_sapiens_MERGED.gene_info```. Θα πρέπει δηλαδή να μπορώ να κάνω:

```python
filenames = ask_57_a('Homo_sapiens.gene_info')
merged_filename = ask_57_b(filenames)

# Take all contents from original Homo_sapiens.gene_info
with open('Homo_sapiens.gene_info') as f:
	original_content = f.read()

# Take all contents from merged 
with open(merged_filename) as f:
	merged_content = f.read()


```

* Προσοχή! Υπάρχει ένα γονίδιο του οποίοι η τιμή στη στήλη chromosome είναι: ```10|19|3```. Ανήκει δηλαδή σε τρία χρωμοσώματα! αγνοήστε το. Επίσης υπάρχουν 146 γονίδια τα οποία δεν έχουν τιμή στη στήλη chromosome (η τιμή είναι: ```-```), 66 γονίδια με χρωμόσωμα: ```'Un'```και 66 γονίδια με χρωμόσωμα: ```X|Y```. Αγνοήστε τα όλα αυτά.


### Άσκηση 58
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα string. Η παράμετρος αυτή θα είναι το όνομα ενός αρχείου το οποίο θα έχει την ίδια δομή όπως το αρχείο ```Homo_sapiens.gene_info```. Η συνάρτηση θα επιστρέφει μία λίστα με τα χρωμοσώματα ταξινομημένα από το μεγαλύτερο προς το μικρότερο ανάλογα με το πλήθος γονιδίων που έχουν. Για παράδειγμα:

```python
f('Homo_sapiens.gene_info') # Επιστρέφει τη λίστα: 
['1', '2', '6', '3', '11', '7', '5', '19', '12', '17', '4', '9', 'X', '8', '10', '14', '16', '15', '13', '20', '22', '18', '21', 'Y', 'MT',] 

```

* Προσοχή! Υπάρχει ένα γονίδιο του οποίοι η τιμή στη στήλη chromosome είναι: ```10|19|3```. Ανήκει δηλαδή σε τρία χρωμοσώματα! αγνοήστε το. Επίσης υπάρχουν 146 γονίδια τα οποία δεν έχουν τιμή στη στήλη chromosome (η τιμή είναι: ```-```), 66 γονίδια με χρωμόσωμα: ```'Un'```και 66 γονίδια με χρωμόσωμα: ```X|Y```. Αγνοήστε τα όλα αυτά.

### Άσκηση 59
Έστω ```d``` το dictionary που επιστρέφει η συνάρτηση της άσκησης 55 όταν τη τρέχουμε βάζοντας το αρχείο ```Homo_sapiens.gene_info``` σαν παράμετρο. Συμπληρώστε τη lambda συνάρτηση στη παρακάτω εντολή ώστε να επιστρέψει το γονίδιο το οποίο έχει το μεγαλύτερο (από άποψη μήκους ονόματος) συνώνυμο:

```python
d = ask_55('Homo_sapiens.gene_info')
max(d, key=lambda x: ...)

```

Στο μέιλ που θα στείλετε απλά βάλτε την παραπάνω εντολή με τις τελίτσες συμπληρωμένες.

Δίνεται ότι αυτό που θα πρέπει να επιστρέφει η παραπάνω εντολή είναι: ```'ARMCX5-GPRASP2'```. 


### Άσκηση 60
Μία ανάλυση που έγινε παρήγαγε ένα αρχείο το οποίο είχε το εξής περιεχόμενο:

```
ID	GENE	FoldChange
TC0100007038.hg.1	NECAP2	1.17
TC0100007063.hg.1	FAM231C; FAM231A	-1.04
TC0100007206.hg.1	CDA; CDB; CDC	-1.15
TC0100007207.hg.1	PINK1; MIR6084	1.1
```

Παρατηρούμε ότι η στήλη ```GENE``` μπορεί να έχει παραπάνω από ένα γονίδια διαχωρισμένα με τον χαρακτήρα ```';'```. Αυτό που θέλουμε είναι να μετασχηματίσουμε το αρχείο έτσι ώστε η στήλη GENE να έχει μόνο ένα γονίδιο. Οι γραμμές που έχουν παραπάνω από ένα γονίδιο θα πρέπει να γραφτούν τόσες φορές όσες τα γονίδια που περιέχουν. Κάθε γραμμή θα έχει και από ένα γονίδιο. Η τιμή στη στήλη ```ID``` και στη στήλη ```FoldChange``` θα πρέπει να παραμείνουν ίδιες. Επίσης οι στήλες χωρίζονται με τον χαρακτήρα tab (```'\t'```)

Φτιάξτε μία συνάρτηση η οποία θα παίρνει δύο παράμετρους. Και οι δύο θα είναι strings τα οποία θα είναι ονόματα αρχείων. Η συνάρτηση θα πρέπει να ανοίγει το αρχείο του οποίου το όνομα είναι η πρώτης παράμετρος, να το μετασχηματίζει όπως περιγράφηκε παραπάνω και να το σώζει στο όνομα του αρχείου της δεύτερης παράμετρου. Θα πρέπει δηλαδή να μπορώ να γράφω:


```python

contents = '''ID	GENE	FoldChange
TC0100007038.hg.1	NECAP2	1.17
TC0100007063.hg.1	FAM231C; FAM231A	-1.04
TC0100007206.hg.1	CDA; CDB; CDC	-1.15
TC0100007207.hg.1	PINK1; MIR6084	1.1
'''

with open('ask_60_input.txt', 'w') as f:
	f.write(contents)

f('ask_60_input.txt', 'ask_60_output.txt')

with open('ask_60_output.txt') as f:
	result = f.read()

print (result) 
#  Θα πρέπει να τυπώνει:
'''
ID	GENE	FoldChange
TC0100007038.hg.1 	NECAP2	1.17
TC0100007063.hg.1 	FAM231C	-1.04
TC0100007063.hg.1 	FAM231A	-1.04
TC0100007206.hg.1	CDA	-1.15
TC0100007206.hg.1	CDB	-1.15
TC0100007206.hg.1	CDC	-1.15
TC0100007207.hg.1	PINK1	1.1
TC0100007207.hg.1	MIR6084	1.1
'''
```

### Άσκηση 61
Φτιάξτε μία συνάρτηση με το όνομα ```ask_61``` η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα επιστρέφει:
* Το string "a" με πιθανότητα 14%
* To string "b" με πιθανότητα 47%
* To string "c" με πιθανότητα 39%

Δηλαδή κάθε φορά που τη καλεί κάποιος θα επιστρέφει είτε "a", είτε "b", είτε "c" σύμφωνα με τις παραπάνω πιθανότητες.

### Άσκηση 62
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα καλεί τη συνάρτηση ask_61 1.000.000 φορές και θα μετράει πόσες φορές επέστρεψε "a", πόσες φορές "b" και πόσες φορές "c". Θα επιστρέφει ένα dictionary του οποίου τα κλειδιά θα είναι τα "a", "b", "c" και τα values θα είναι οι αντίστοιχοι μετρητές τους. Για παράδειγμα:

```python
f() 
# Επιστρέφει ένα dictionary  με τιμές παραπλήσιες με αυτές:
{'b': 470283, 'c': 389550, 'a': 140167}
```

### Άσκηση 63
Ο παρακάτω κώδικας:

```python
from scipy.stats import nbinom
nbinom.pmf(10, 2, 1/6, 2) #  Επιστρέφει: 0.0581420098403444 
```

Επιστρέφει τη πιθανότητα να ρίξουμε 10 φορές ένα ζάρι και τη 10η φορά να έρθει για 2η φορά το 6. Ή αλλιώς τη πιθανότητα να έχουμε 2 φορές το 6 σε 10 ρίψεις του ζαριού και το 2ο εξάρι να είναι στη 10η ρίψη. 
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση "ρίχνει" 10 ζάρια 1.000.000 φορές και μετράει πόσες από αυτές τις φορές το τελευταίο ζάρι (10η ρίψη) ήταν η 2η φορά που ήρθε 6. Η συνάρτηση επιτρέφει τον αριθμό των επιτυχιών διαιρεμένο με το 1.000.000. Ή αλλιώς επιστρέφει τον λόγο των επιτυχιών προς τον συνολικό αριθμό των πειραμάτων. Για παράδειγμα:

```python
f() # Επιστρέφει έναν αριθμό που είναι κοντά στο 0.0581
```

* ΠΡΟΣΟΧΗ! Εσείς δεν χρειάζεται ούτε να εγκαταστήσετε scipy, ούτε να τρέξετε τη nbinom, ούτε να μάθετε τι κάνει. Τον κώδικα με την nbinom σας τον δίνω για να δείτε ποια είναι η σωστή απάντηση, και πως μπορείς να την υπολογίσεις χωρίς.. 1.000.000 επαναλήψεις! 

### Άσκηση 64

Δίνεται η παρακάτω φόρμουλα για τον υπολογισμό του π (3.14159...):

![img](https://i.imgur.com/ruurBAn.png)

Φτιάξτε έναν generator με το όνομα ```ask_64_a``` o οποίος δεν θα παίρνει κανένα όρισμα. O generator θα κάνει yield τους όρους του παραπάνω αθροίσματος. Θα πρέπει δηλαδή να μπορώ να γράψω:

```python
gen = ask_64_a()

print (next(gen)) # Τυπώνει: 0.3333333333333333  1/(1*3)

print (next(gen)) # Τυπώνει: 0.02857142857142857  1/(5*7)

print (next(gen)) # Τυπώνει: 0.010101010101010102  1/(9*11)

```

Φτιάξτε τη συνάρτηση ask_64_b η οποία παίρνει μία παράμετρο. Η παράμετρος είναι ένας ακέραιος αριθμός Ν. Η συνάρτηση υπολογίζει το άθροισμα των πρώτων Ν όρων των αριθμών που παράγει ο generator ```ask_64_a```. Στη συνέχεια υπολογίζει και επιστρέφει το γινόμενο αυτού του αθροίσματος με το 8. Για παράδειγμα θα πρέπει:

```python
ask_64_b(1000) # Επιστρέφει: 3.141092653621038 
```

### Άσκηση 65
Δίνεται ο παρακάτω generator:

```python
def g():
    a = 2054802212
    while a>100:
        a = (1103515245*a + 12345) % 2**31
        yield a
```

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση επιστρέφει το πλήθος των στοιχείων που παράγει η γεννήτρια g. Για να το κάνετε αυτό είναι υποχρεωτικό να χρησιμοποιήσετε τη [StopIteration](https://docs.python.org/3/library/exceptions.html#StopIteration).

### Άσκηση 66
Φτιάξτε μία συνάρτηση με το όνομα ```ask_66``` η οποία παίρνει δύο ορίσματα. Η συνάρτηση κάνει τους εξής ελέγχους:
* αν τουλάχιστον ένα από τα δύο ορίσματα δεν είναι int ή float, πετάει (raise) TypeError 
* αν τουλάχιστον ένα από τα δύο ορίσματα είναι αρνητικό αριθμός (<0), πετάει (raise) ValueError
* αν το άθροισμα των δύο αριθμών είναι μεγαλύτερο από το 1000, πετάει (raise) OverflowError  

Αν δεν συμβεί κάποιο exception η συνάρτηση επιστρέφει το άθροισμα των δύο παραμέτρων. 

Για παράδειγμα:

```python
f(3, "mitsos") # #Πετάει TypeError 

f(-3, 4) # Πετάει ValueError

f(400, 800) # Πετάει OverflowError

f(10,15) # Επιστρέφει 25
```

### Άσκηση 67
Δίνεται η παρακάτω συνάρτηση:

```python
import random

def test_ask_66():

	def rand_param():
		if random.random()<0.5:
			r = random.randint(1,1000)
			if random.random()<0.3:
				r /= 1
		else:
			r = "a"

		return r

	first = rand_param()
	second = rand_param()

	return ask_66(first, second)

```

Αυτή η συνάρτηση δημιουργεί δύο τυχαίες τιμές και τις χρησιμοποιεί σαν παράμετρους για να καλέσει τη συνάρτηση ```ask_66```. 

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα καλεί τη συνάρτηση ```test_ask_66``` 100.000 φορές. Η συνάρτηση θα επιτρέφει ένα dictionary με τα εξής κλειδιά / τιμές:

* Κλειδί: "Invalid Type" , Τιμή: Πόσες φορές "πέταξε" TypeError η ```test_ask_66```.
* Κλείδί: "Invalid Value", Τιμή: Πόσες φορές "πέταξε" ValueError η ```test_ask_66```.
* Κλειδί: "Overflow" , Τιμή: Πόσες φορές "πέταξε" OverflowError η ```test_ask_66```.
* Κλειδί: "ΟΚ" , Τιμή πόσες φορές ΔΕΝ πέταξε κάποιο Exception η ```test_ask_66```. 


### Άσκηση 68
Γράψτε κώδικα python τέτοιον ώστε όταν τον σώζω σε ένα αρχείο με το όνομα ```ask_68.py``` και μετά:

1. τρέχω στη γραμμή εντολών:
```bash
python ask_68.py 10 30 
```

Να τυπώνει ```40``` (το άθροισμα του 10 και του 30)

2. γράφω στο jupyter:
```python
from ask_68 import my_add

print (my_add(10,30)) # Τυπώνει 40 
```

Να τυπώνει τον αριθμό ```40``` (το άθροισμα του 10 και του 30)

### Άσκηση 69

Σε αυτό το link: https://www.dropbox.com/s/brqaopz8g2vs0ox/covid_fasta.gz?dl=1 υπάρχει ένα αρχείο το οποίο περιέχει 8.728 ακολουθίες από διάφορα strains του ιού COVID19 που έχουν συλλεχθεί από διάφορα μέρη. Το αρχείο είναι σε φορμά [FASTA](https://en.wikipedia.org/wiki/FASTA_format). Δηλαδή για κάθε strain:
* Υπάρχει μία γραμμή (επικεφαλίδα) με διάφορες πληροφορίες για την ακολουθία (π.χ χώρα προέλευση). Για παράδειγμα για το πρώτο strain του αρχείου η επικεφαλίδα είναι:

```text
>hCoV-19/Italy/FVG-ICGEB-S208/2020|EPI_ISL_498558|2020-07
```

* Στη συνέχεια ακολουθούν πολλές γραμμές με την ακολουθία, όπου κάθε γραμμή έχει 80 βάσεις. 

Μετά από τις γραμμές με την ακολουθία ακολουθεί η επικεφαλίδα του 2ου strain κτλ..

Στη συνέχεια ακολουθεί η επικεφαλίδα για το 2ο strains και μετά οι γραμμές με την ακολουθία για τον 2ο strain κτλ. 

Το αρχείο είναι συμπιεσμένο. Μπορείτε να το αποσυμπιέσετε πριν το ανοίξετε ή (καλύτερα) να το ανοίξετε συμπιεσμένο απευθείας από τη python με τον εξής τρόπο:

```python
import gzip

with gzip.open('covid_fasta.gz', 'rt') as f:
	# Εδώ μπορείτε να βάλετε τις εντολές που θα βάζατε αν το αρχείο δεν ήταν συμπιεσμένο.
	# π.χ. f.readline() 
	pass
```

Φτιάξτε έναν generator ο οποίος θα παίρνει μία παράμετρο. Η παράμετρος θα είναι το όνομα του αρχείου με τις ακολουθίες του COVID19 (μπορείτε αν θέλετε να βάλετε το αποσυμπιεσμένο αρχείο). Για κάθε strain που έχει το αρχείο, ο generator θα κάνει yield ένα dictionary. To dictionary θα έχει τα ακόλουθα δύο ζευγάρια από κλειδιά / τιμές:

* Κλειδί: "header", Τιμή: Ένα string με την επικεφαλίδα του strain
* Κλειδί: "sequence": Τιμή: Ένα string με την ακολουθία του strain, ως ένα string το οποίο περιέχει μόνο A,C,G,Τ και Ν (=άγνωστη βάση).

Για παράδειγμα:

```python
gen = g('covid_fasta.gz')

first_strain = next(gen)
print (first_strain['header']) 
# Τυπώνει: >hCoV-19/Italy/FVG-ICGEB-S208/2020|EPI_ISL_498558|2020-07 
print (first_strain['sequence'][:100])
# Τυπώνει: 'ATTAAAGGTTTATACTTTCCCAGGTAACAAACCAACCAACTTTCGATCTCTTGTAGATCTGTTCTCTAAACGAACTTTAAAATCTGTGTGGCTGTCACTC'

second_strain = next(gen)
print (second_strain['header'])
# Τυπώνει: >hCoV-19/Italy/FVG-ICGEB-S211/2020|EPI_ISL_498559|2020-07-01

print (second_strain['sequence'][:100])
# Τυπώνει: 'ATTAAAGGTTTATACCTTCCCAGGTAACAAACCAACCAACTTTCGATCTCTTGTAGATCTGTTCTCTAAACGAACTTTAAAATCTGTGTGGCTGTCACTC' 
```

### Άσκηση 70
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει μία λίστα η οποία θα περιέχει τις 10 χώρες του κόσμου με τα περισσότερα strains του ιού COVID19. Η χώρα από την οποία προέρχεται ένα strain υπάρχει στην επικεφαλίδα του strain στο αρχείο FASTA της άσκησης 69. Η χώρα υπάρχει μεταξύ του πρώτου και του δεύτερου ```/``` στην επικεφαλίδα. Για παράδειγμα:

```
>hCoV-19/Italy/FVG-ICGEB-S208/2020|EPI_ISL_498558|2020-07 
         ^^^^^
```

## Οι ασκήσεις που βρίσκονται από εδώ και κάτω είναι under development..

### Άσκηση 71
Τυχαίες τιμές --> Μικρότερα Συνεχόμενα διαστήματα. 



