Copyright (C) 2021 Alexandros Kanterakis, mail:[kantale@ics.forth.gr](mailto:kantale@ics.forth.gr)
```
Άδεια αναπαραγωγής όλου ή μέρους του παρακάτω κειμένου δίνεται υπό τις ακόλουθες προϋποθέσεις:
1. Θα αναφέρεται ρητά το όνομα του δημιουργού και το copyright όπως έχει οριστεί παραπάνω.
2. Θα υπάρχει ο σύνδεσμος (url) προς αυτόν τον ιστότοπο. 
```

# Βασικές Οδηγίες
## Χρήση παραμέτρων
Η υλοποίησή σας πρέπει να είναι σε ένα ή περισσότερα αρχεία python (.py). Το πρόγραμμά σας πρέπει να τρέχει από το command line και να δέχεται κάποιες παραμέτρους. Ενδείκνυται να χρησιμοποιήσετε το πακέτο [argparse](https://docs.python.org/3/library/argparse.html) το οποίο παρέχει βολικές μεθόδους για να διαβάζετε παραμέτρους από το command line. Ένα από τα πλεονεκτήματα του argparse είναι ότι μπορείτε να δώσετε όνομα στις παραμέτρους. Π.χ.:

```python
import argparse

parser = argparse.ArgumentParser()

parser.add_argument('--foo', nargs=1)
parser.add_argument('--goo', nargs=3)

args = parser.parse_args()

print (args.foo)
print (args.goo)
```

Στο παραπάνω παράδειγμα έχουμε δύο παραμέτρους: την ```---foo``` και τη ```--goo```. Η πρώτη παίρνει μία τιμή και η δεύτερη 3. Αν σώσω το παραπάνω παράδειγμα στο αρχείο: ```test.py```, τότε μπορώ να το τρέξω με την παρακάτω εντολή:

```text
python d.py --foo 3  --goo 4 5 6
```

Αυτό θα τυπώσει:

```text
['3']
['4', '5', '6']
```

## Σχόλια!
Βάλτε σχόλια στον κώδικα!! Κάθε συνάρτηση θα πρέπει να έχει documentation, όπως έχουμε πει. Σε κάθε συνάρτηση αναφέρετε το όνομα του φοιτητή ο οποίος ανέλαβε να την υλοποιήσει. Μπορεί να υπάρχουν και παραπάνω από 1 ονόματα σε μία συνάρτηση:

```python
def f():
    '''
    this function does....
    
    author(s): ....
    '''
    pass
```

## Μην σας τρομάζουν οι μεγάλες εκφωνήσεις!
Σε όλα τα project, η υλοποίησή τους είναι μικρότερη από την εκφώνησή τους.

# Project 1

<!-- https://gist.github.com/kantale/24f4f02d5b87ce0146e0455791e71aeb  --> 

Σκοπός του project είναι να φτιάξετε σε python ένα πρόγραμμα με το οποίο θα μπορούν να υπολογιστούν βασικές παράμετροι της πληθυσμιακής γενετική. Αυτές οι παράμετροι είναι πολύ χρήσιμες σε [GWAS](https://en.wikipedia.org/wiki/Genome-wide_association_study) μελέτες. Τα GWAS (Genome Wide Association Studies) είναι μελέτες που προσπαθούν να βρουν μία στατιστική συσχέτιση μεταξύ ενός γονότυπου και ενώς φαινότυπου. Για τους σκοπούς αυτής της εργασίας έχουμε φτιάξει ένα τεχνιτό (artificial) genotype dataset. Αυτό το dataset βρίσκεται εδώ:

https://s3.eu-central-1.amazonaws.com/pythonprojectgwas/gwas.tar.gz

Αφού το κατεβάσετε μπορείτε να το κάνετε uncompress ως εξής:

```bash
tar zxvf gwas.tar.gz
```

ή 

```bash
gunzip gwas.tar.gz
tar xvf gwas.tar
```

Στη συνέχεια θα δείτε ότι υπάρχουν δύο αρχεία: το ```gwas.cases.gen``` και το ```gwas.controls.gen``` .
Τα αρχεία αυτά περιέχουν τα genotypes από 500 controls και 500 cases από μία υποθετική ασθένεια. **Προσοχή** περιέχεται μόνο το χρωμόσωμα 20. [Το φορμάτ των αρχείων](http://www.stats.ox.ac.uk/%7Emarchini/software/gwas/file_format.html#Genotype_File_Format), είναι σύμφωνα με το πρόγραμμα [HAPGEN2](https://mathgen.stats.ox.ac.uk/genetics_software/hapgen/hapgen2.html) το οποίο και χρησιμοποιήθηκε για να φτιαχτεί αυτό το artificial dataset. Λεπτομέρειες για το πως δημιουργήθηκε αυτό το dataset υπάρχουν στο τέλος. 

Κάθε γραμμή σε αυτά τα αρχεία περιέχει και ένα [SNP](https://en.wikipedia.org/wiki/Single-nucleotide_polymorphism) (όλες οι θέσεις είναι στο χρωμόσωμα 20). Η πρώτη στήλη περιέχει έναν μοναδικό κωδικό για κάθε SNP. Η δεύτερη στήλη περιέχει τον rs κωδικό του SNP σύμφωνα με το [dbsnp](https://www.ncbi.nlm.nih.gov/projects/SNP/) (για όσα δεν έχουν dbsnp κωδικό περιέχει απλά τη θέση). Εισάγοντας τον κωδικό αυτόν στο dbsnp μπορείτε να βρείτε περισσότερες πληροφορίες για το SNP. Η τρίτη στήλη περιέχει τη θέση του SNP σύμφωνα με το NCBI build 36. Οι επόμενες δύο στήλες (4η, 5η) περιέχουν τα 2 πιθανά αλληλόμορφα του SNP. Το πρώτο είναι το reference και το δεύτερο το alternative. 

Οι υπόλοιπες στήλες περιέχουν τον γονότυπο για κάθε ένα sample. Ο γονότυπος ενός sample αποτελείται από 3 στήλες από '0' και '1'. Κάθε τριάδα μπορεί να έχει μόνο ένα '1'. Αν το '1' είναι στη πρώτη θέση της τριάδας τότε το δείγμα αυτό είναι homozygous reference. Αν το '1' είναι στη δεύτερη θέση τότε είναι heterozygous και αν είναι στη 3η θέση είναι homozygous alternative. Ή αλλιώς αν υποθέσουμε ότι το SNP έχει reference A και alternative B, τότε:

* 1 0 0 ---> Α Α
* 0 1 0 ---> Α Β
* 0 0 1 ---> Β Β

Για παράδειγμα ας πάρουμε τη πρώτη γραμμή του ```gwas.cases.gen```:

```bash
head -n 1  gwas.cases.gen 
```

Για λόγους συντομίας δεν δείχνουμε όλες τις στήλες. Οι πρώτες 20 στήλες είναι οι παρακάτω:

```
snp_0 rs6078030 9098 C T 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0
```

Άρα ο γονότυπος για τα πρώτα 5 δείγματα είναι (τα spaces είναι δικά μου):

```
1 0 0      0 1 0      0 1 0      0 1 0      1 0 0
 C C        C T        C T        C T        C C          
```

Δηλαδή το πρώτο case είναι CC, το δεύτερο case είναι C T, το πέμπτο case είναι C C κτλ.


Το πρόγραμμά σας σε python θα πρέπει να δέχεται τις εξής υποχρεωτικές παραμέτρους από το command line:
* -controls_file  : Το αρχείο με τα control genotypes (π.χ. gwas.controls.gen)
* -cases_file     : Το αρχείο με τα cases genotyes (π.χ. gwas.controls.gen)
* -output         : Ένα όνομα αρχείου. Το πρόγραμμα θα αποθηκεύει όλα τα αποτελέσματα σε διαφορετικές καταλήξεις αυτού του αρχείου 

Επίσης θα πρέπει να δέχεται τις παρακάτω μη-υποχρεωτικές παραμέτρους για τον χειρισμό SNP/Samples
* -keep_snps      : Ένα αρχείο με κωδικούς SNPs ανά γραμμή. Η ανάλυση θα γίνεται ΜΟΝΟ σε αυτά τα SNPs
* -remove_snps    : Ένα αρχείο με κωδικούς SNPs ανά γραμμή. Η ανάλυση θα γίνεται σε όλα τα SNPs εκτός αυτά.
* -keep_samples   : Ένα αρχείο με κωδικούς sample ανά γραμμή. Ένα sample έχει κωδικό: (case ή control)_αριθμός. Π.χ. το sample control_5 είναι το 5ο control. Το case_100 είναι το 100ό case. Η ανάλυση θα γίνεται ΜΟΝΟ σε αυτά τα samples.
* -remove_samples : Ένα αρχείο με κωδικούς sample ανά γραμμή (δες παραπάνω). Η ανάλυση θα γίνεται σε όλα τα samples εκτός από αυτά.

Αν έχει χρησιμοποιειθεί μία από τις παραπάνω 4 παραμέτρους τότε το πρόγραμμα θα πρέπει να δημιουργεί το αρχείο "output".cases.gen και "output".controls.gen το οποίο θα περιέχει μόνο τα SNPs/samples τα οποία δεν θα έχουν αφαιρεθεί. Το φορμάτ πρέπει να είναι αυτό που έχουμε περιγράψει. Το "output" είναι η τιμή της παραμέτρους -output.  

Για την ανάλυση των genotypes, το πρόγραμμα θα πρέπει να υποστηρίζει τις παρακάτω παραμέτρους:
* -allele_frequency : Τυπώνει στο αρχείο "output".frequency 6 στήλες:
  * Η 1η στήλη είναι ο κωδικός του SNP. 
  * Η 2η είναι η συχνότητα του reference στα controls 
  * Η 3η είναι η συχνότητα του alternative στα controls
  * H 4η είναι συχνότητα του reference στα cases
  * Η 5η είναι η συχνότητα του alternative στα cases
  * H 6η είναι η συχνότητα του reference στα cases και στα controls
  * H 7η είναι η συχνότητα του alternatice στα cases και στα controls

* -HWE : Τυπώνει στο αρχείο "output".hwe 2 στήλες:
  * Η 1η στήλη είναι ο κωδικός του SNP
  * H 2η στήλη θα περιέχει το [Hardy Weinberg Equilibrium](https://en.wikipedia.org/wiki/Hardy%E2%80%93Weinberg_principle) statistic για το ενωμένο cases+controls dataset. Μπορείτε να χρησιμοποιήσετε οποιαδίποτε μέθοδο για τον υπολογισμό του (π.χ.: https://en.wikipedia.org/wiki/Hardy%E2%80%93Weinberg_principle#Significance_tests_for_deviation)

* -LD SNP1 SNP2 : Τυπώνει στο αρχείο "output".ld το Linkage Disequilibrium (LD) R square και D' (D prime) μεταξύ των SNPs με κωδικό SNP1 και SNP2. Εξαιρετικά καλές και εύκολες οδηγίες για τον υπολογισμό του LD βρίσκονται εδώ: http://rannala.org/books/CUPChap3.pdf κεφάλαιο: 3.2.2 EM algorithm for estimating disequilibrium.

Προσοχή! σε αυτό το λινκ http://rannala.org/books/CUPChap3.pdf υπάρχει ένα λάθος στη σελίδα 68 το λάθος είναι:

![slide3](https://cloud.githubusercontent.com/assets/1254711/23204323/c48aa784-f8ee-11e6-9194-fc97ae3e076d.jpg)

Credits στον Παύλο Παυλίδη που το εντόπισε!

* --HWE_filter NUMBER παράγει ένα αρχείο με το όνομα HWE_filter το οποίο περιέχει τους κωδικούς των SNPs που έχου HWE μεγαλύτερο από το NUMBER 
* --AF_filter NUMBER παράγει ένα αρχείο με το όνομα AF_filter το οποίο περιέχει τους κωδικούς των SNPs που έχουν Allele Frequency μεγαλύτερο απο το NUMBER 
* --HWE_plot ONOMA_ARXEIOY.png παράγει ένα plot με τη κατανομή των τιμών του HWE statistic
* --AF_plot ONOMA_ARXEIOY.png παράγει ένα plot με τη κατανομή των τιμών του Allele Frequency
* --LD_run KWDIKOS_SNP threshold ΟΝΟΜΑ_ΑΡΧΕΙΟΥ.png με αυτή την εντολή υπολογίζει το LD μεταξύ του SNP KWDIKOS_SNP και όλων των SNPs downstream (δηλαδή σε μεγαλύτερες θέσεις) ή upstream (δηλαδή σε μικρότερες θέσεις). Μόλις βρει 1 SNP με LD μικρότερο από το threshold σταματάει. Φτιάχνει ένα plot όπου στον Χ είναι τα SNPs και στο Y είναι η τιμή του LD (R-square). Στο plot θα πρέπει να φαίνεται με κάποιο "σημάδι" η θέση του SNP KWDIKOS_SNP. Στο τέλος σώζει το plot στο αρχείο ΟΝΟΜΑ_ΑΡΧΕΙΟΥ.png. 



### Σημείωση: Υπολογισμός Hardy Weinberg Equilibrium < 0.001"

H wikipedia δίνει ένα πολύ καλό παράδειγμα:
https://en.wikipedia.org/wiki/Hardy%E2%80%93Weinberg_principle#Significance_tests_for_deviation

Πρoσέξτε πως υπολογίζει τα expected values (1467.4, 141.2, 3.4) με βάση τα observed values (1469, 138, 5)

Αφού τα υπολογίσετε μετά μπορείτε να εφαρμόσετε το chi square test στη python:

```python
>>> from scipy import stats
>>> s = stats.chisquare([1469, 138, 5], [1467.4, 141.2, 3.4])
>>> print (s)
Power_divergenceResult(statistic=0.82720700518383861, pvalue=0.66126308839474002)
```

Προσέξτε ότι το statistic (0.8272..) είναι το ίδιο που δίνει και η wikipedia (0.83), απλά είναι στρογγυλοποιημένο.
Οπότε αυτό που πρέπει να πάρετε είναι το pvalue:

```python
>>> print (s.pvalue)
0.66126308839474002
```


# Project 2
<!-- https://gist.github.com/kantale/24f4f02d5b87ce0146e0455791e71aeb  --> 

Σκοπός του project είναι να φτιάξετε σε python ένα πρόγραμμα με το οποίο θα μπορεί να γίνουν [GWAS](https://en.wikipedia.org/wiki/Genome-wide_association_study) μελέτες. Τα GWAS (Genome Wide Association Studies) είναι μελέτες που προσπαθούν να βρουν μία στατιστική συσχέτιση μεταξύ ενός γονότυπου και ενώς φαινότυπου. Για τους σκοπούς αυτής της εργασίας έχουμε φτιάξει ένα τεχνιτό (artificial) genotype dataset. Αυτό το dataset βρίσκεται εδώ:

https://s3.eu-central-1.amazonaws.com/pythonprojectgwas/gwas.tar.gz

Αφού το κατεβάσετε μπορείτε να το κάνετε uncompress ως εξής:

```bash
tar zxvf gwas.tar.gz
```

ή 

```bash
gunzip gwas.tar.gz
tar xvf gwas.tar
```

Στη συνέχεια θα δείτε ότι υπάρχουν δύο αρχεία: το ```gwas.cases.gen``` και το ```gwas.controls.gen``` .
Τα αρχεία αυτά περιέχουν τα genotypes από 500 controls και 500 cases από μία υποθετική ασθένεια. **Προσοχή** περιέχεται μόνο το χρωμόσωμα 20. [Το φορμάτ των αρχείων](http://www.stats.ox.ac.uk/%7Emarchini/software/gwas/file_format.html#Genotype_File_Format), είναι σύμφωνα με το πρόγραμμα [HAPGEN2](https://mathgen.stats.ox.ac.uk/genetics_software/hapgen/hapgen2.html) το οποίο και χρησιμοποιήθηκε για να φτιαχτεί αυτό το artificial dataset. Λεπτομέρειες για το πως δημιουργήθηκε αυτό το dataset υπάρχουν στο τέλος. 

Κάθε γραμμή σε αυτά τα αρχεία περιέχει και ένα [SNP](https://en.wikipedia.org/wiki/Single-nucleotide_polymorphism) (όλες οι θέσεις είναι στο χρωμόσωμα 20). Η πρώτη στήλη περιέχει έναν μοναδικό κωδικό για κάθε SNP. Η δεύτερη στήλη περιέχει τον rs κωδικό του SNP σύμφωνα με το [dbsnp](https://www.ncbi.nlm.nih.gov/projects/SNP/) (για όσα δεν έχουν dbsnp κωδικό περιέχει απλά τη θέση). Εισάγοντας τον κωδικό αυτόν στο dbsnp μπορείτε να βρείτε περισσότερες πληροφορίες για το SNP. Η τρίτη στήλη περιέχει τη θέση του SNP σύμφωνα με το NCBI build 36. Οι επόμενες δύο στήλες (4η, 5η) περιέχουν τα 2 πιθανά αλληλόμορφα του SNP. Το πρώτο είναι το reference και το δεύτερο το alternative. 

Οι υπόλοιπες στήλες περιέχουν τον γονότυπο για κάθε ένα sample. Ο γονότυπος ενός sample αποτελείται από 3 στήλες από '0' και '1'. Κάθε τριάδα μπορεί να έχει μόνο ένα '1'. Αν το '1' είναι στη πρώτη θέση της τριάδας τότε το δείγμα αυτό είναι homozygous reference. Αν το '1' είναι στη δεύτερη θέση τότε είναι heterozygous και αν είναι στη 3η θέση είναι homozygous alternative. Ή αλλιώς αν υποθέσουμε ότι το SNP έχει reference A και alternative B, τότε:

* 1 0 0 ---> Α Α
* 0 1 0 ---> Α Β
* 0 0 1 ---> Β Β

Για παράδειγμα ας πάρουμε τη πρώτη γραμμή του ```gwas.cases.gen```:

```bash
head -n 1  gwas.cases.gen 
```

Για λόγους συντομίας δεν δείχνουμε όλες τις στήλες. Οι πρώτες 20 στήλες είναι οι παρακάτω:

```
snp_0 rs6078030 9098 C T 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0
```

Άρα ο γονότυπος για τα πρώτα 5 δείγματα είναι (τα spaces είναι δικά μου):

```
1 0 0      0 1 0      0 1 0      0 1 0      1 0 0
 C C        C T        C T        C T        C C          
```

Δηλαδή το πρώτο case είναι CC, το δεύτερο case είναι C T, το πέμπτο case είναι C C κτλ.


Το πρόγραμμά σας σε python θα πρέπει να δέχεται τις εξής υποχρεωτικές παραμέτρους από το command line:
* -controls_file  : Το αρχείο με τα control genotypes (π.χ. gwas.controls.gen)
* -cases_file     : Το αρχείο με τα cases genotyes (π.χ. gwas.controls.gen)
* -output         : Ένα όνομα αρχείου. Το πρόγραμμα θα αποθηκεύει όλα τα αποτελέσματα σε διαφορετικές καταλήξεις αυτού του αρχείου 

Επίσης θα πρέπει να δέχεται τις παρακάτω μη-υποχρεωτικές παραμέτρους για τον χειρισμό SNP/Samples
* -keep_snps      : Ένα αρχείο με κωδικούς SNPs ανά γραμμή. Η ανάλυση θα γίνεται ΜΟΝΟ σε αυτά τα SNPs
* -remove_snps    : Ένα αρχείο με κωδικούς SNPs ανά γραμμή. Η ανάλυση θα γίνεται σε όλα τα SNPs εκτός αυτά.
* -keep_samples   : Ένα αρχείο με κωδικούς sample ανά γραμμή. Ένα sample έχει κωδικό: (case ή control)\_αριθμός. Π.χ. το sample control_5 είναι το 5ο control. Το case_100 είναι το 100ό case. Η ανάλυση θα γίνεται ΜΟΝΟ σε αυτά τα samples.
* -remove_samples : Ένα αρχείο με κωδικούς sample ανά γραμμή (δες παραπάνω). Η ανάλυση θα γίνεται σε όλα τα samples εκτός από αυτά.

Αν έχει χρησιμοποιειθεί μία από τις παραπάνω 4 παραμέτρους τότε το πρόγραμμα θα πρέπει να δημιουργεί το αρχείο "output".cases.gen και "output".controls.gen το οποίο θα περιέχει μόνο τα SNPs/samples τα οποία δεν θα έχουν αφαιρεθεί. Το φορμάτ πρέπει να είναι αυτό που έχουμε περιγράψει. Το "output" είναι η τιμή της παραμέτρους -output.  

Για την ανάλυση των genotypes, το πρόγραμμα θα πρέπει να υποστηρίζει τις παρακάτω παραμέτρους:

* -association_test : Τυπώνει στο αρχείο "output".association τα αποτελέσματα από το association test μεταξύ genotype και phenotype για όλα τα SNPs. Για το association test χρησιμοποιείστε το απλό Genotypic Association test το οποίο περιγράφεται με μεγαλή σαφήνεια στο paper: [Basic statistical analysis in genetic case-control studies](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3154648/). (Αν θέλετε υλοποιήσετε περισσότερα tests π.χ. Cochran-Armitage trend). Το αρχείο πρέπει έχει μία γραμμή για κάθε SNP. Κάθε γραμμή θα περιέχει τον κωδικό του SNP, τη θέση του (locus), το p-value από το association test και το Odds Ratio. 

* -manhattan ONOMA_ARXEIOY.png : Φτιάχνει ένα [Manhattan plot](https://en.wikipedia.org/wiki/Manhattan_plot) από το p-values του association test και το σώζει στο αρχείο ONOMA_ARXEIOY.png. 

* -qqplot ONOMA_ARXEIOY.png : Φτιάχνει ένα [qq-plot](https://en.wikipedia.org/wiki/Q%E2%80%93Q_plot) από τα p-values του association test και το σώζει στο αρχείο με το όνομα ONOMA_ARXEIOY.png. 


### Σημείωση 1: Πως επαληθεύουμε (δεν είναι υποχρεωτικό).
* Υπάρχουν πολλά εργαλεία που έχουν σχεδιαστεί για GWA Studies και κάνουν κάποια από τα tasks που περιγράφονται εδώ. Δύο από τα πιο γνωστά είναι το [plink](http://pngu.mgh.harvard.edu/~purcell/plink/index.shtml) και το [SNPTEST](https://mathgen.stats.ox.ac.uk/genetics_software/snptest/snptest.html#introduction). Μπορείτε φυσικά αν θέλετε να τα χρησιμοποιήσετε για επιβεβαίωση αλλά θα πρέπει επιπλέον να υλοποιήσετε μεθόδους για τη μετατροπή των δεδομένων στο format των εργαλείων αυτών. 

### Σημείωση 2: Πως δημιουργήθηκε το artificial dataset (για όσους αναρωτιούνται)
Κατεβάζουμε το [hapgen2](https://mathgen.stats.ox.ac.uk/genetics_software/hapgen/hapgen2.html):

```bash
wget https://mathgen.stats.ox.ac.uk/genetics_software/hapgen/download/builds/x86_64/v2.2.0/hapgen2_x86_64.tar.gz
mkdir -p hapgen2
tar zxvf hapgen2_x86_64.tar.gz -C hapgen2 
```

Κατεβάζουμε το 1000 Genomes Project (August 2009 CEU haplotypes) - NCBI Build 36 (dbSNP b126) reference dataset:

```bash
wget https://mathgen.stats.ox.ac.uk/wtccc-software/CEU.0908.impute.files.tgz
tar zxvf CEU.0908.impute.files.tgz
```

Τρέχουμε το hapgen2:

```bash
hapgen2/hapgen2 \
    -m CEU.0908.impute.files/genetic_map_chr20_combined_b36.txt \
    -l CEU.0908.impute.files/CEU.0908.chr20.legend \
    -h CEU.0908.impute.files/CEU.0908.chr20.hap \
    -o ./gwas \
    -dl <location, risk allele and relative risks for each artificial disease risk variant, NOT SHOWN!!!>
    -n 500 500
```


### Παράδειγμα Manhattan plot με ένα χρωμόσωμα

Υπάρχει εδώ: http://2.bp.blogspot.com/-w1h3x3rpOLY/TbXVEHCr1cI/AAAAAAAALqI/wiQqpr1HJ6c/s400/2011-04-19+GGD+manhattan4.png 
(Αγνοήστε τα χρώματα αν θέλετε)


# Project 3
<!-- https://gist.github.com/kantale/81d7d728c22fb35d77112c3633e17389 -->


### Εισαγωγή
Θεωρούμε γνωστό ότι ο άνθρωπος είναι ένας διπλοειδής οργανισμός. Αυτό σημαίνει ότι κάθε χρωμόσωμα έχει δύο αντίγραφα.
Το ένα αντίγραφο το κληρονομούμε από τη μητέρα μας και το άλλο από τον πατέρα μας. Επίσης ο άνθρωπος έχει 2 φυλετικά χρωμοσώματα τα οποία για τους άντρες είναι διαφορετικά (XY) και για τις γυναίκες είναι ίδια (XX). Σε αυτή την εργασία δεν θα ασχοληθούμε με τα φυλετικά χρωμοσώματα. 

Οι διαφορετικές τιμές των νουκλεοτιδίων που υπάρχουν σε μία συγκεκριμένη θέση του γονιδιώματος ονομάζονται "αλληλόμορφα". Μέσω των πειραμάτων γονοτύπησης μπορούμε να "δούμε" ποια αλληλόμορφα έχει ένα άτομα σε διάφορες θέσεις του γονιδιώματος. Για παράδειγμα ο γονότυπος ενός ατόμου στη θέση 1.000.000 του χρωμοσώματος 1 μπορεί να είναι: ```A/C```. Στο παραπάνω παράδειγμα ο γονότυπος ```A/C``` σημαίνει ότι στο ένα σετ χρωμοσωμάτων στη θέση 1.000.000 του χρωμοσώματος 1 έχει ```Α``` ενώ στο άλλο σετ έχει ```C```. Στη συγκεκριμένη περίπτωση, όταν δηλαδή σε μία θέση στο γονιδίωμα υπάρχουν δύο αλληλόμορφα, λέμε ότι ο γονότυπος αυτός είναι *ετερόζυγος*. Ομοίως σε περίπτωση που σε μία θέση του γονιδιώματος υπάρχει ένα κοινό αλληλόμορφο, λέμε ότι στη θέση αυτή ο γονότυπος είναι *ομόζυγος*.

Όπως ξέρετε, κάθε άνθρωπος έχει μία μοναδική κατανομή γονότυπων (εκτός ίσως από τα μονοζυγωτικά δίδυμα). Επίσης, είναι πολύ ενδιαφέρον το γεγονός ότι πολύ σπάνια σε μία συγκεκριμένη περιοχή του γονιδιώματος να παρατηρούμε παραπάνω από 2 αλληλόμορφα μεταξύ των γονοτύπων διαφορετικών ανθρώπων. Αυτό σημαίνει ότι αν σε έναν άνθρωπο παρατηρήσουμε τον γονότυπο ```A/C```, τότε με μεγάλη σιγουριά μπορούμε να πούμε ότι ένας τυχαίος άλλος άνθρωπος θα έχει είτε τον ίδιο γονότυπο είτε θα είναι ομόζυγος στο Α (```Α/Α```) είτε ομόζυγος στο C (```C/C```). Αυτού του τύπου η γονιδιακή διαφορά ονομάζεται διαλληλική (bi-allelic). Φυσικά υπάρχουν και τρι-αλληλικές αλλά και τετρα-αλληλικές διαφορές, αλλά δεν θα μας απασχολήσουν σε αυτή την εργασία. 

Όσο πιο κοντά είναι οι κοινοί πρόγονοι μεταξύ δύο ανθρώπων τόσο πιο πολλές ομοιότητες έχουν στο γωνιδίωμά τους. Αυτό σημαίνει ότι η πιθανότητα μεταξύ δύο ανθρώπων να "έχουν" τον ίδιο γονότυπο σε μία συγκεκριμένη διαλληλική θέση, είναι μεγαλύτερη ανάλογα με το πόσο "συγγενείς" είναι. Αυτή ακριβώς είναι και η βασική αρχή της πληθυσμιακής γενετικής η οποία μελετάει τη σχέση των ανθρώπων/πληθυσμών με βάση τις γενετικές τους διαφορές.

Σήμερα, μέσω των πειραμάτων γονοτύπησης αλλα και αλληλούχησης (sequencing), έχουμε βρει περίπου 1.000.000.000 περιοχές στο γονιδίωμα στις οποίες έχουμε παρατηρήσει να έχουν διαφορετικό γονότυπο τουλάχιστον δύο άνθρωποι. Αυτό σημαίνει ότι κατά τη διάρκεια του χρόνου έχουν συμβεί μεταλλάξεις οι οποίες έχουν "μεταφερθεί" σε μικρά ή μεγαλύτερα τμήματα του πληθυσμού. Οι μεταλλάξεις αυτές που αφορούν μία μοναδική θέση ονομάζονται SNPs (Single Nucleotide Polymorphisms). Ένα διαλληλικό SNP ορίζεται με βάση τα παρακάτω:
* Τη θέση του στο χρωμόσωμα 
* Το πρώτο αλληλόμορφο που παρατηρούμε
* Το δεύτερο αλληλόμορφο που παρατηρούμε

Για παράδειγμα στο χρωμόσωμα 16 και στη θέση 53786615, έχουμε παρατηρήσει ότι [υπάρχει ένα SNP](https://www.ncbi.nlm.nih.gov/snp/rs9939609) το οποίο έχει τα αλληλόμορφα Τ και Α.

Για κάθε SNP ορίζουμε τη συχνότητά του σε έναν πληθυσμό. Αυτή η συχνότητα είναι ο λόγος του πλήθους των αλληλόμορφων που βρίσκουμε στον πληθυσμό για αυτό το SNP προς το πλήθος όλων των αλληλόμορφων. Για παράδειγμα ας υποθέσουμε ότι έχουμε ένα SNP με δύο αλληλόμορφα A και C, και έναν πληθυσμό από 3 ανθρώπους:


| Άνθρωπος | Γονότυπος   |
|----------|-------------|
|  1  |       Α/Α        |
|  2  |       Α/Α        |
|  3  |       C/A        |

Στο παραπάνω SNP, η συχνότητα του Α είναι 5/6 και η συχνότητα του C είναι 1/6. Το ποια από τις δύο συχνότητες θα χρησιμοποιήσουμε για να ορίσουμε τη συχνότητα αυτού του SNP είναι μία παραδοχή που μπορούμε να κάνουμε. Μερικές φορές χρησιμοποιούμε το μικρότερο από τα δύο (1/6). Αυτός ο ορισμός ονομάζεται Minor Allele Frequency (MAF). Διαφορετικά μπορούμε να ορίσουμε από πριν κάποιο αλληλόμορφο ως το "κοινό", με βάση κάποιο γονιδίωμα το οποίο ονομάζουμε γονιδίωμα αναφοράς (reference genome) και να ορίσουμε τη συχνότητα του SNP ως τη συχνότητα του κοινού αλληλόμορφου. 

### Ανάλυση της κατανομής των πληθυσμών με βάση τον γονότυπο
Μέσα σε έναν πληθυσμό λοιπόν, κάθε SNP έχει μία συχνότητα. Οι διαφορές των συχνοτήτων αυτών μεταξύ δύο διαφορετικών πληθυσμών (π.χ Ιταλοί με Σουηδοί) μπορεί να μας δώσει πληροφορία για το πόσο κοντά γενετικά είναι οι πληθυσμοί αυτοί. Ευτυχώς για εμάς, υπάρχουν έτοιμες μέθοδοι που κάνουν ακριβώς αυτό το πράγμα. Ας τις δούμε λίγο πιο αναλυτικά. Ας υποθέσουμε ότι έχουμε γονοτυπήσει ένα σύνολο από 100 ανθρώπους σε 1000 διαφορετικές θέσεις του γονιδιώματος. Υποθέτουμε ότι και οι 100 ανήκουν στον ίδιο πληθησμό αλλά δεν είμαστε σίγουροι για αυτό. Για να το επιβεβαιώσουμε δημιουργούμε έναν πίνακα που περιέχει τους γονότυπους όλων των ατόμων:

| Άνθρωπος | Γονότυπος 1  | Γονότυπος 2  | Γονότυπος 3  | Γονότυπος 4  | ..  |  Γονότυπος 1000  |
|----------|--------------|--------------|-------------|---------------|----|-------------------|
|  1  |       A/A        |     C/T        |     A/A     |    C/C       | ..  |     T/T          |
|  2  |       A/C        |     C/C        |     A/T     |    C/G       | ..  |     G/T          |
|  3  |       A/A        |     C/T        |     A/T     |    C/G       | ..  |     G/T          |
|  ..  |      C/C        |     C/C        |     A/T     |    G/G       | ..  |     G/G          |
|  100  |     A/A        |     T/T        |     A/T     |    G/G       | ..  |     T/T          |

Στη συνέχεια μπορούμε να μετατρέψουμε τον παραπάνω πίνακα ώστε να έχει αριθμητικές τιμές. Για κάθε γραμμή, διαλέγουμε ένα αλληλόμορφο ως το "κοινό". Ένας ομόζυγος γονότυπος που έχει 2 κοινά το κωδικοποιούμε με 0, ένας ετερόζυγος γονότυπος κωδικοποιείται με 1 και ένας ομόζυγος που έχει δύο μη-κοινά κωδικοποιείται με 2. Αν κάνουμε τα παραπάνω και ορίσουμε (αυθαίρετα) το πρώτο αλληλόμορφο του πρώτου ανθρώπου ώς το "κοινό" τότε ο παραπάνω πίνακας γίνεται:

| Άνθρωπος | Γονότυπος 1  | Γονότυπος 2  | Γονότυπος 3  | Γονότυπος 4  | ..  |  Γονότυπος 1000  |
|----------|--------------|--------------|-------------|---------------|----|-------------------|
|  1  |       0        |     1        |     0     |    0       | ..  |     0          |
|  2  |       1        |     0        |     1     |    1       | ..  |     1          |
|  3  |       0        |     1        |     1     |    1       | ..  |     1          |
|  ..  |      2        |     0        |     1     |    2       | ..  |     2          |
|  100  |     0        |     2        |     1     |    2       | ..  |     0          |

Αυτός ο πίνακας έχει 100 δείγματα με 1000 τιμές ο κάθε ένας. Είναι δηλαδή 100 αντικείμενα στον 1000-διάστατο χώρο. Πως μπορούμε να προβάλουμε τον πίνακα αυτό στον διδιάστατο χώρο έτσι ώστε να φαίνοναι οι αποστάσεις μεταξύ των ανθρώπων; Αυτό ακριβώς κάνει η μέθοδος [PCA (Principal Component Analysis)](https://en.wikipedia.org/wiki/Principal_component_analysis) και ευτυχώς για εσάς θα σας δοθεί έτοιμη μέθοδος στη python η οποία την υλοποιεί. Ας δούμε ένα παράδειγμα:

![img](https://i.imgur.com/DLDTKmw.png)

[πηγή](https://faculty.washington.edu/tathornt/SISG2015/lectures/assoc2015session05.pdf)

Σε αυτό το παράδειγμα βλέπουμε το αποτέλεσμα του PCA σε ένα σύνολο που περιείχε ανθρώπους από διάφορες περιοχές της Ευρώπης. Τα αποτελέσματα ήταν εντυπωσιακά δεδομένου ότι το γράφημα προσεγγίζει ικανοποιητικά τον χάρτη της Ευρώπης. Το PCA κάνει προβολή όλων των δεδομένων σε 2 ή παραπάνω διαστάσεις. Οι διαστάσεις αυτές επιλέγονται έτσι ώστε να υπάρχει όσο το δυνατόν μεγαλύτερο variance μεταξύ των δεδομένων. Περισσότερα για το PCA μπορείτε να βρείτε εδώ:
* [Meng's Notes: An intuitive explanation of PCA (Principal Component Analysis)](http://mengnote.blogspot.co.uk/2013/05/an-intuitive-explanation-of-pca.html)
* [rincipal Component Analysis 4 Dummies: Eigenvectors, Eigenvalues and Dimension Reduction](http://georgemdallas.wordpress.com/2013/10/30/principal-component-analysis-4-dummies-eigenvectors-eigenvalues-and-dimension-reduction/)

### Το πρόβλημα
Στο site του [GGV](http://popgen.uchicago.edu/ggv/) μπορείτε να δείτε τη συχνότητα ενός SNP σε διάφορες περιοχές της γης. Όπως παρατηρείτε, υπάρχουν SNPs των οποίων η συχνότητα έχει μεγάλες διαφορές μεταξύ πληθυσμών αλλά υπάρχουν και SNPs των οποίων η συχνότητα είναι κοινή. Οι αλγόριθμοι PCA κάνουν ό,τι μπορούν ώστε να εντοπίσουν και να προβάλουν τις διαφορές που υπάρχουν αλλά η ύπαρξη πολλών SNPs με κοινές συχνότητες μεταξύ των πληθυσμών μπορούν να κάνουν τη PCA ανάλυση εξαιρετικά δύσκολη. Σε αυτό το project θα πρέπει να κάνετε μία ανάλυση του παραπάνω προβλήματος. Συγκεκριμένα θα πρέπει να απαντήσετε στην ερώτηση:
* **Ποιο είναι το ελάχιστο ποσοστό των SNPs με διαφορετικές πληθυσμιακές συχνότητες που πρέπει να έχει ένα πείραμα γονοτύπησης ώστε να είναι ορατές οι διαφορετικές πληθυσμιακές ομάδες που υπάρχουν;**


### Δημιουργία τεχνητών γονοτυπικών δεδομένων
Το πρόγραμμά σας θα πρέπει να μπορεί να παράγει τυχαίους γονότυπους για ένα πλήθος από τεχνητά (μη-υπαρκτά) SNPs. Για να παραχθεί ένα τυχαίο SNP κάνουμε το εξής: 
* Επιλέγουμε ποια θα είναι η συχνότητά του, έστω p (θα δούμε μετά πως θα γίνει αυτό)
* Επιλέγουμε πόσα samples (άτομα) θα "γονοτυπίσουμε" (θα δούμε μετά και αυτό)
* Για κάθε sample διαλέγουμε τυχαία δύο αλληλόμορφα. Το κάθε αλληλόμορφο μπορεί να πάρει μία δυνατή τιμή: Α ή Β. Η πιθανότητα να πάρουμε το Α είναι p και η πιθανότητα να πάρουμε το Β είναι 1-p. Δηλαδή οι δυνατοί γονότυποι είναι: Α/Α, Α/Β, Β/Α και Β/Β. 

Για να παράγουμε αληθοφανείς γονότυπους πρέπει η κατανομή των συχνοτήτων των SNPs να είναι όσο το δυνατόν πιο κοντά στη πραγματικότητα. Για το λόγο αυτό θα χρησιμοποιήσετε τις συχνότητες των SNPs που υπάρχουν στο 1000 Genomes Project.

### Το 1000 Genomes Project
Το [1000 Genomes Project](https://en.wikipedia.org/wiki/1000_Genomes_Project) (1KGP για συντομία) είναι ίσως το δεύτερο πιο σημαντικό project στη γενετική μετά το [Human Genome Project](https://en.wikipedia.org/wiki/Human_Genome_Project) (HGP). Αν το HGP δημιούργησε το πρώτο πλήρες γονιδίωμα του ανθρώπου, το 1KGP ήταν το πρώτο που μελέτησε τη γενετική ετερογένεια ενός μεγάλου μέρους του ανθρώπινου πληθυσμού. Στη τελική του φάση, το 1KGP είχε αλληλουχίσει το γονιδίωμα από 2504 ανθρώπους οι οποίοι ανήκουν σε 26 διαφορετικούς πληθυσμούς. 

Ας παίξουμε λίγο με τα δεδομένα από το 1KGP!

Τα δεδομένα από τη τελευταία (τρίτη) φάση του 1KGP βρίσκονται σε αυτό το link: [ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/](ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/)

Αυτό το site (στη πραγματικότητα [ftp site](https://en.wikipedia.org/wiki/File_Transfer_Protocol) αλλά αυτό δεν έχει σημασία) περιέχει όλες τις μεταλλάξεις (variants) που εντοπίστηκαν. Όλα τα variants περιγράφονται σε [VCF](https://en.wikipedia.org/wiki/Variant_Call_Format) φορμάτ και είναι συμπιεσμένα με το πρόγραμμα [gzip](https://en.wikipedia.org/wiki/Gzip). Κάθε αρχείο έχει τη κατάλληξη .vcf.gz και υπάρχει ένα αρχείο για κάθε χρωμόσωμα. Ας "παίξουμε" με το μικρότερο χρωμόσωμα το οποίο είναι το 22. 

Αρχικά κατεβάζουμε το αρχείο. **ΠΡΟΣΟΧΗ** Το αρχείο αυτό, αν και συμπιεσμένο, είναι 205 ΜΒ:



```python
!wget -O 1kgp_chr1.vcf.gz ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ALL.chr22.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz
```

    --2017-12-16 18:32:50--  ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ALL.chr22.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz
               => ‘1kgp_chr1.vcf.gz’
    Resolving ftp.1000genomes.ebi.ac.uk... 193.62.192.8
    Connecting to ftp.1000genomes.ebi.ac.uk|193.62.192.8|:21... connected.
    Logging in as anonymous ... Logged in!
    ==> SYST ... done.    ==> PWD ... done.
    ==> TYPE I ... done.  ==> CWD (1) /vol1/ftp/release/20130502 ... done.
    ==> SIZE ALL.chr22.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz ... 214453750
    ==> PASV ... done.    ==> RETR ALL.chr22.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz ... done.
    Length: 214453750 (205M) (unauthoritative)
    
    ALL.chr22.phase3_sh 100%[===================>] 204.52M   995KB/s    in 3m 31s  
    
    2017-12-16 18:36:24 (991 KB/s) - ‘1kgp_chr1.vcf.gz’ saved [214453750]
    


Ας επιβεβαιώσουμε ότι το αρχείο έχει κατέβει:


```python
!ls -lh 1kgp_chr1.vcf.gz
```

    -rw-r--r--  1 alexandroskanterakis  staff   205M Dec 16 18:36 1kgp_chr1.vcf.gz


Αφού το αρχείο είναι συμπιεσμένο μπορούμε να το ανοίξουμε με τη βιβλιοθήκη [gzip](https://docs.python.org/3/library/gzip.html) της python: 


```python
import gzip
```

Ένα gzip αρχείο το ανοίγουμε όπως και τα υπόλοιπα, απλά χρησιμοποιούμε τη ```gzip.open```:


```python
filename = '1kgp_chr1.vcf.gz'
file = gzip.open(filename, 'rt')
```

Ας διαβάσουμε τη πρώτη γραμμή του αρχείου:


```python
line = file.readline()
print (line)
```

    ##fileformat=VCFv4.1
    


Η πρώτη γραμμή μας ενημερώνει την έκδοση του VCF φορμάτ που χρησιμοποιεί. Μπορούμε να το αγνοήσουμε αυτό. Επίσης οι πρώτες γραμμές του αρχείου περιέχουν διάφορες (μετα)πληροφορίες για το περιεχόμενο του αρχείου τις οποίες μπορούμε να αγνοήσουμε. Αυτές οι γραμμές αρχίζουμε με: ```##```. Οπότε ας αγνοήσουμε όλες τις γραμμές που ξεκινάν με ```##```:


```python
while line[:2] == '##':
    line = file.readline()
```

Η μεταβλητή ```line``` τώρα είναι μια γραμμή η οποιά ΔΕΝ ξεκινάει με: ```##```. Η ```line``` τώρα είναι:


```python
line
```




    '#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\tHG00096\tHG00097\tHG00099...\n'



παρατηρούμε ότι περιέχει διάφορα πεδία χωρισμένα με tabs. Ας τη κάνουμε split:


```python
line_splitted = line.split()
line_splitted
```




    ['#CHROM',
     'POS',
     'ID',
     'REF',
     'ALT',
     'QUAL',
     'FILTER',
     'INFO',
     'FORMAT',
     'HG00096',
     'HG00097',
     ...]



Αυτή η γραμμή μας δίνει τους τίτλους των πεδίων (header) του αρχείου. Έτσι λοιπόν:
* Το 1ο πεδίο (#CHROM) είναι το χρωμόσωμα
* Το 2ο πεδίο (POS) είναι η θέση στο χρωμόσωμα
* Το 3ο πεδίο (ID) είναι ένα μοναδικό ID για αυτή τη θέση.
* Το 4ο πεδίο (REF) είναι το reference sequence αυτού του variant. Δηλαδή η ακολουθία που θεωρούμε ως αναφορά.
* Το 5ο πεδίο (ALT) είναι το alternative sequence αυτού του variant. Δηλαδή η ακολουθια που βρήκαμε αντί για το reference sequence
* Το 6ο πεδίο (QUAL) είναι ένα quality metric το οποίο μας λέει πόσο σίγουροι είμαστε ό,τι δεν έχει γίνει λάθος κατά τη γονοτύπηση αυτής της θέσης. Μπορούμε να αγνοήσουμε αυτό το πεδία.
* Το 7ο πεδίο (FILTER) μας λέει αν ο συγκεκριμένος γονότυπος πέρασε ή όχι το quality metric. Συνήθως η τιμή του είναι ```PASS```
* Το 8ο πεδίο (INFO) μας δίνει κάποιες επιπλέον πληροφορίες για αυτή τη θέση, τις οποίες θα τις δούμε μετά. 
* Το 9ο πεδίο (FORMAT) μπορούμε να το αγνοήσουμε (μας λέει πως περιγράφονται ο γονότυπος)
* Το 10ο πεδίο μέχρι και το τελευταίο περιέχει το κωδικό όνομα των samples. Δηλαδή κάθε sample (άνθρωπος) έχει ένα κωδικό όνομα σε όλο το 1KGP. 

Ας σώσουμε τη πρώτη γραμμή με το όνομα: ```header```


```python
header = line_splitted
```

Ας διαβάσουμε τώρα την επόμενη γραμμή


```python
line_splitted = file.readline().split()
line_splitted
```




    ['22',
     '16050075',
     'rs587697622',
     'A',
     'G',
     '100',
     'PASS',
     'AC=1;AF=0.000199681;AN=5008;NS=2504;DP=8012;EAS_AF=0;AMR_AF=0;AFR_AF=0;EUR_AF=0;SAS_AF=0.001;AA=.|||;VT=SNP',
     'GT',
     '0|0',
     '0|0',
     '0|0',
     ...]



**Κάθε μία από τις υπόλοιπες γραμμές του VCF αρχείου περιγράφει μία μοναδική μετάλλαξη**

Άρα, αυτή η γραμμή περιέχει τις πληροφορίες για τον πρώτο variant του αρχείου. Για να δούμε λοιπόν:
* Το 1ο πεδίο είναι '22' το οποίο είναι το χρωμόσωμα
* Το 2ο πεδίο είναι '16050075' το οποίο είναι η θέση του variant στο χρωμόσωμα 22.
* Το 3ο πεδίο είναι ο κωδικός (ID) του variant ο οποίο είναι rs587697622.
* Το 4ο πεδίο είναι το reference sequence το οποίο για αυτό το variant είναι: ```A```.
* Το 5ο πεδίο είναι το alternative sequence το οποίο για αυτό το variant είναι: ```G```.
* Το 6ο πεδίο είναι το quality του variant το οποίο είναι 100 (το οποίο σημαίνει κάτι σαν "100% σίγουροι")
* Το 7ο πεδίο μας λέει αν πέρασε το quality filter ή όχι. Το ```PASS``` που περιέχει μας λέει ότι το πέρασε.
* Το 8ο πεδίο περιέχει κάποιες επιπλέον πληροφορίες για αυτόν τον variant. Οι πληροφορίες αυτές κωδικοποιούνται ως εξής: ```ΤΙΤΛΟΣ_1=ΤΙΜΗ_1;ΤΙΤΛΟΣ_2=ΤΙΜΗ_2...ΤΙΤΛΟΣ_N=ΤΙΜΗ_Ν```

Ας φτιάξουμε ένα dictionary με αυτές τις τιμές για αυτόν τον variant:


```python
INFO_index = header.index('INFO')
info = line_splitted[INFO_index]
info_dict = dict([x.split('=') for x in info.split(';')])
info_dict
```




    {'AA': '.|||',
     'AC': '1',
     'AF': '0.000199681',
     'AFR_AF': '0',
     'AMR_AF': '0',
     'AN': '5008',
     'DP': '8012',
     'EAS_AF': '0',
     'EUR_AF': '0',
     'NS': '2504',
     'SAS_AF': '0.001',
     'VT': 'SNP'}



Ας αναλύσουμε αυτές τις πληροφορίες:
* Το ```AA``` μπορούμε να το αγνοήσουμε
* Το ```NS``` είναι το Number of Samples. Δηλαδή σε πόσους ανθρώπους μπόρεσαν να ανιχνεύσουν αν αυτό το variant υπάρχει ή όχι. Το συγκεκριμένο είναι 2504
* Το ```AN``` είναι το Allele Number,  Δηλαδή σε πόσα χρωμοσώματα μπόρεσαν να ανιχνεύσουν αν αυτό το variant υπάρχει ή όχι. Το συγκεκριμένο είναι 5008 (δηλαδή 2504 * 2).
* Το ```AC``` είναι το "Allele Count". Δηλαδή σε πόσα χρωμοσώματα βρέθηκε το alternative sequence. Εδώ είναι μόνο 1. 
* Το ```AF``` είναι το Allele Frequency του alternative sequence. Αυτό είναι ίσο με AC/AN. Δηλαδή το συγκεκριμένο είναι: 1/5008 = 0.000199681
* Το ```AFR_AF``` είναι το Allele Frequency του variant στα samples με καταγωγή από Αφρική.
* Το ```AMR_AF``` είναι το Allele Frequency του variant στα samples με καταγωγή από Αμερική.
* Το ```EAS_AF``` είναι το Allele Frequency του variant στα samples με καταγωγή από ανατολική Ασία (East Asia).
* Το ```SAS_AF``` είναι το Allele Frequency του variant στα samples με καταγωγή από νότια Ασία (Sout Asia).
* Το ```EUR_AF``` είναι το Allele Frequency του variant στα samples με καταγωγή από Ευρώπη.
* Το ```VT``` είναι το Variant Type. Δηλαδή ο τύπος του variant. **ΠΡΟΣΟΧΗ! Σε αυτό το project θα ασχοληθούμε μόνο με variants που ο τύπος τους είναι "SNP"**.
* Το ```DP``` (DePth) μπορούμε να το αγνοήσουμε.

Συνεχίζουμε με τη περιγραφή των πεδίων του πρώτου variant.
* Το 9ο πεδίο είναι 'GT' και μπορούμε να το αγνοήσουμε. 

Τα επόμενα πεδία από το 10ο μέχρι το τέλος, περιέχουν τους γονότυπους των samples:


```python
genotypes = line_splitted[9:]
```

Πόσα samples υπάρχουν;


```python
len(genotypes)
```




    2504



Ας διαβάσουμε τον γονότυπο του πρώτου sample:


```python
genotypes[0]
```




    '0|0'



Ας αναλύσουμε λίγο αυτό το '0|0'

Αυτοί οι δύο αριθμοί μας λένε ποιο αλληλόμορφο έχει το κάθε ένα από τα 2 σετ χρωμοσωμάτων στη θέση αυτού του variant:
* Αν ο αριθμός είναι 0, τότε το αλληλόμορφο είναι ίδιο με το reference sequence
* Αν ο αριθμός είναι 1, τότε το αλληλόμορφο είναι ίδιο με το alternative sequence

Δηλαδή δεδομένου ότι το reference sequence αυτού του variant είναι ```A``` και το alternative sequence είναι ```G```. τότε ο γονότυπος αυτού του sample είναι: ```A/A```.

Ο γονότυπος του 1438-ου sample είναι:


```python
genotypes[1437]
```




    '0|1'



Αυτό σημαίνει ότι ο γονότυπος του 1438-ού sample είναι: ```A/G```

Σημείση 1: Ο γονότυπος 1|0 και ο γονότυπος 0|1 θα θεωρείται ότι είναι ο ίδιος. (Στη πραγματικότητα επείδη οι γονότυποι του 1KGP είναι [phased](https://en.wikipedia.org/wiki/Haplotype_estimation) το πρώτο νούμερο είναι το αλληλόμορφο στο πρώτο σετ χρωμοσωμάτων και το δεύτερο αλληλόμορφο στο δεύτερο)

Σημείωση 2: Ο αριθμός αυτός μπορεί να είναι και μεγαλύτερος του 1. Για παράδειγμα, αν έχουμε κάποιο SNP το οποίο είναι tri-allelic, μπορεί ένα sample να έχει γονότυπο 0|1 (π.χ. Α/Τ) και ένα άλλο sample να έχει γονότυπο 0|2 (π.χ. Α/G). Αυτό σημαίνει ότι αυτό το variant έχει τρία διαφορετικά αλληλόμορφά. Αγνοήστες αυτά τα variants.

Το κάθε sample στο 1KGP, ανήκει σε 1 από 5 διαφορετικές περιοχές (European, African, American, East Asia, South Asian) και σε 1 από 26 διαφορετικούς πληθυσμούς. Για αρχή ας φτιάξουμε μία λίστα που θα έχει όλους τους κωδικούς των samples:


```python
sample_ids = header[9:]
sample_ids
```




    ['HG00096',
     'HG00097',
     'HG00099',
     ...]



Η πληροφορία για τις περιοχές και τους πληθυσμούς που ανήκει κάθε sample υπάρχει στο αρχείο που βρίσκεται σε αυτό το link: [ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/integrated_call_samples_v3.20130502.ALL.panel](ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/integrated_call_samples_v3.20130502.ALL.panel) . Ας το κατεβάσουμε:


```python
!wget -O sample_information.csv ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/integrated_call_samples_v3.20130502.ALL.panel
```

    --2017-12-16 20:41:20--  ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/integrated_call_samples_v3.20130502.ALL.panel
               => ‘sample_information.csv’
    Resolving ftp.1000genomes.ebi.ac.uk... 193.62.192.8
    Connecting to ftp.1000genomes.ebi.ac.uk|193.62.192.8|:21... connected.
    Logging in as anonymous ... Logged in!
    ==> SYST ... done.    ==> PWD ... done.
    ==> TYPE I ... done.  ==> CWD (1) /vol1/ftp/release/20130502 ... done.
    ==> SIZE integrated_call_samples_v3.20130502.ALL.panel ... 55156
    ==> PASV ... done.    ==> RETR integrated_call_samples_v3.20130502.ALL.panel ... done.
    Length: 55156 (54K) (unauthoritative)
    
    integrated_call_sam 100%[===================>]  53.86K   183KB/s    in 0.3s    
    
    2017-12-16 20:41:24 (183 KB/s) - ‘sample_information.csv’ saved [55156]
    


Για να δούμε τι πληροφορία έχει:


```python
sample_filename = 'sample_information.csv'
sample_file = open(sample_filename)
sample_data = sample_file.read()
sample_file.close()

sample_data
```




    'sample\tpop\tsuper_pop\tgender\t\t\nHG00096\tGBR\tEUR\tmale\nHG00097\tGBR\tEUR\tfemale\nHG00099\n'



Παρατηρούμε ότι είναι ένα tab delimited αρχείο:


```python
sample_data_splitted = [x.split() for x in sample_data.split('\n')]
sample_data_splitted
```




    [['sample', 'pop', 'super_pop', 'gender'],
     ['HG00096', 'GBR', 'EUR', 'male'],
     ['HG00097', 'GBR', 'EUR', 'female'],
     ['HG00099', 'GBR', 'EUR', 'female'],
     ...]



Η πρώτη γραμμή είναι το header του αρχείου. Οι υπόλοιπες γραμμές περιέχουν την εξής πληροφορία:

* Το 1ο πεδίο (sample) περιέχει τον κωδικό του sample όπως υπάρχει και στο VCF αρχείο
* Το 2ο πεδίο (pop) περιέχει τον πληθυσμό στον οποίο ανήκει (έναν από τους 26)
* Το 3ο πεδίο (super_pop) περιέχει τη περιοχή στην οποία ανήκει (μία από τις 5)
* Το 4ο πεδίο (gender) περιέχει το φύλο του sample. Δυνατές τιμές είναι 'male' και 'female'. Μπορούμε να την αγνοήσουμε αυτή τη πληροφορία. 

Για παράδειγμα ας πάρουμε όλους τα samples που είναι βρετανοί:


```python
sample_ids_british = [x[0] for x in sample_data_splitted[1:] if x and x[1] == 'GBR']
sample_ids_british
```




    ['HG00096',
     'HG00097',
     'HG00099',
     'HG01791',
     ...]



## Γενικά 
Το πρόγραμμά σας θα πρέπει να δέχεται διάφορες παραμέτρους από το command line. Η βασική παράμετρος είναι η ```--action <ACTION_NAME>```. Ανάλογα με τη τιμή της παραμέτρου αυτής, το πρόγραμμά σας θα πρέπει να κάνει διάφορες λειτουργίες. 

### Μέρος 1ο
Το πρόγραμμά σας θα πρέπει να δέχεται τις εξής παραμέτρους:
* ```--vcf <FILENAME>``` θα παίρνει ένα vcf ή ένα vcf.gz αρχείο (ό,τι θέλετε). 
* Με το ```--action VCF_INFO```. Το πρόγραμμά σας θα τυπώνει πόσα SNPs έχει το vcf και πόσα samples.

Π.χ:
```text
> python project.py --vcf 1kgp_chr1.vcf.gz --action VCF_INFO

File has 2502 samples
File has 1234567 SNPs
```

### Μέρος 2ο
Το πρόγραμμα σας θα πρέπει να δέχεται τις εξής παραμέτρους:
* ```--sample_filename <FILENAME>``` όπου θα παίρνει ΕΠΙΠΛΕΟΝ το όνομα του αρχείου που θα περιέχει τη πληθυσμιακη πληροφορία των samples
* ```--action SAMPLE_INFO``` θα τυπώνει πόσα samples περιέχει το sample_filename και πόσα samples έχει ο κάθε πληθυσμός. Μαζί με τον πληθυσμό θα τυπώνει και σε ποια περιοχή ανήκει αυτός ο πληθυσμός. 
* ```--action VALIDATE_SAMPLE_INFO``` θα επιβεβαιώνει ότι όλα τα samples που υπάρχουν στο vcf υπάρχουν και στο sample_filename και το αντίστροφο.

Π.χ:
```text
> python project.py --sample_filename sample_information.csv --action SAMPLE_INFO

File has 5 Areas.
Area 1 is EUR and contains 1234 samples splitted in the following populations:
GBR 100 samples
ITA 109 samples
Area 2 is AMR and contain 5678 samples splitted in the following populations:
...
```

Και:

```text
> python project.py --vcf 1kgp_chr1.vcf.gz --sample_filename sample_information.csv --action VALIDATE_SAMPLE_INFO

Everything is OK!

or..

These samples are present in VCF but not in SAMPLE:
XYZ
KLM
```

### Μέρος 3ο
* ```--population <POPULATION_NAME> <NUMBER_OF_SAMPLES> --SNPs <Number of SNPs> --output <FILENAME> --action SIMULATE``` 

Με αυτές τις παραμέτρους το πρόγραμμά σας θα πρέπει να δημιουργεί ένα αρχείο με το όνομα ```<FILENAME>```. Το αρχείο θα περιέχει ```<SNPs>``` *διαφορετικά* SNPs και ```<NUMBER_OF_SAMPLES>``` διαφορετικά samples. Οι γονότυποι αυτών των SNPs θα είναι τυχαίοι. Τα allele frequencies αυτών των SNPS θα πρέπει να ίδια με τυχαία (αλλά υπαρκτά) SNPs από το αρχείο που έχει δηλωθεί με τη ```--vcf``` παράμετρο. Το φορμάτ του αρχείο του αρχείου ```<FILENAME>``` μπορεί να είναι ό,τι θέλετε εσείς αλλά συνίσταται να είναι σε VCF.

Π.χ: Η παρακάτω εντολή θα πρέπει να παράγει ένα αρχείο με το όνομα ```random_genotypes.vcf``` το οποίο θα έχει 100 samples και 1000 SNPs. Το κάθε SNP θα έχει το ίδιο allele frequency με το allele frequency κάποιου υπαρκτού SNP στο ```1kgp_chr1.vcf.gz```  το οποίο θα έχετε επιλέξει τυχαία (το SNP). Για να υπολογίσετε το allele_frequency θα πάρετε ΜΟΝΟ τα samples που ανήκουν στον GBR πληθυσμό:

```text
> python project.py --vcf 1kgp_chr1.vcf.gz --sample_filename sample_information.csv --population GBR 100 --SNPs 1000 --output random_genotypes.vcf --action SIMULATE
```

### Μέρος 4ο
Στο 4ο μέρος θα πρέπει το πρόγραμμά σας να δέχεται πολλές διαφορετικές παράμετρους ```--population```. Με αυτόν τον τρόπο θα μπορεί να δημιουργεί αρχεία τα οποία θα έχουν samples από πολλούς διαφορετικούς πληθυσμούς. Για παράδειγμα η παρακάτω εντολή θα πρέπει να παράγει το αρχείο ```random_genotypes.vcf``` το οποίο θα έχει 100 samples με allele frequencies από τον GBR πληθυσμό και 200 samples από τον IBS πληθυσμό και θα παράγει στο σύνολο 1000 SNPs:

```text
> python project.py --vcf 1kgp_chr1.vcf.gz --sample_filename sample_information.csv --population GBR 100 --population IBS 200 --SNPs 1000 --output random_genotypes.vcf --action SIMULATE
```

**ΠΡΟΣΟΧΗ!** Τα allele frequencies θα πρέπει να προέρχονται από το ΙΔΙΟ τυχαία επιλεγμένο SNP και για τους δύο πληθυσμούς. Απλά θα υπολογίζετε ένα allele frequency για τους GBR και ένα για τους IBS. Στη συνέχεια χρησιμοποιείται αυτά τα 2 allele frequencies για να φτιάξετε τους 100 τυχαίους GBR και τους 200 τυχαίους IBS. Για παράδειγμα αν επιλέξουμε τυχαία ένα SNP από το 1KGP του οποίου το allele freuquency στα GBR samples είναι 0.25 και το allele frequency στα IBS samples είναι 0.29, τότε θα πρέπει να χρησιμοποιήσετε τις αντίστοιχες συχνότητες (0.25 και 0.29) όταν δημιουργείτε τα τυχαία δείγματά σας.

**ΠΡΟΣΟΧΗ!** Το πρόγραμμά σας δεν πρέπει να έχει όριο στο πλήθος από διαφορετικούς πληθυσμούς που δηλώνονται στο command line. Δηλαδή θα πρέπει να μπορεί ο χρήστης να δημιουργεί 100 τυχαίους ITA, 200 τυχαίους GBR και 150 τυχαίους PEL με ένα και μόνο command.

### Μέρος 5ο
Το πρόγραμμά σας θα πρέπει να δέχεται τη παράμετρο ```--independent <NUMBER_OF_INDEPENDENT_SNPs>``` το οποίο θα προσθέτει SNPs των οποίων τα allele frequencies θα υπολογίζεται με βάση ΟΛΟΥΣ τους πληθυσμούς που έχουν δηλωθεί μέσω των ```--population parameters```. Για παράδειγμα η παρακάτω εντολή:

```bash
> python project.py \
   --vcf 1kgp_chr1.vcf.gz --sample_filename sample_information.csv \
   --population GBR 100 \
   --population IBS 200 \
   --SNPs 1000 \
   --independent 700 \
   --output random_genotypes.vcf \
   --action SIMULATE
```

θα πρέπει να παράγει συνολικά 1.700 SNPs. Από αυτά, τα 1000 θα έχουν allele frequencies που θα υπολογίζονται με βάση το 4ο μέρος. Τα 700 θα έχουν το allele frequency των GBR και των IBS, αν θεωρήσουμε ότι αυτά τα δείγματα ανήκουν στον ίδιο πληθυσμό. 

Ένα επιπλέον παράδειγμα: Ας υποθέσουμε ότι έχουμε το παρακάτω SNP:

```text
IBS_1 IBS_2 IBS_3 GBR_1 GBR_2
 A/A   A/C   A/A   A/A   A/C 
```

Τα ```IBS_1, IBS_2, IBS_3``` είναι 3 samples από IBS.

Τα ```GBR_1, GBR_2``` είναι 2 samples από GBR.

Τότε το allele frequency των IBS είναι 1/6. Το allele frequency των GBR είναι 1/4. Το allele frequency όλων είναι 2/10. 

Οπότε με βάση αυτό το SNP, θα πρέπει να φτιάξετε 1000 SNPs των οποίων τα 100 samples να έχουν allele frequency 1/4 και 200 samples με allele frequency 1/6. Θα πρέπει επιπλέον να φτιάξετε 700 SNPs τα οποία θα έχουν allele frequency 2/10 και για τα 300 samples (100+200).


### Μέρος 6ο
Σε αυτό το μέρος θα παίρνει ένα αρχείο που εσείς θα έχετε παράξει (με τη παράμετρο ```--output <FILENAME>```) με βάση τις εντολές που περιγράφονται στα μέρη 3,4,5,6 και θα κάνει PCA. Πως κάνουμε όμως PCA στη python; Ας το εξερευνήσουμε! 

Για αρχή ας φτιάξουμε μερικές συναρτήσεις που δημιουργούν τυχαίους γονότυπους για δύο πληθυσμούς. Για κάθε SNP διαλέγουμε μία τυχαία τιμή από το 0 μέχρι το 0.5. Αυτό θα είναι το allele frequency του reference allele. Στη συνέχεια διαλέγουμε δύο τυχαίους αριθμός από το -0.2 μέχρι το 0.2 και φτιάχνουμε δύο perturbations (διακυμάνσεις) του allele frequency. Για παράδειγμα αν υποθέσουμε ότι το τυχαίο allele frequency είναι 0.3 και τα δύο τυχαία perturbations είναι 0.1 και -0.05 τότε τα allele frequencies για τους δύο πληθυσμούς θα είναι:

* Allele frequency για τον πληθυσμό 1: 0.3 + 0.1\*0.3 = 0.33
* Allele frequency για τον πληθυσμό 2: 0.3 - 0.05\*0.3 = 0.285

Στη συνέχεια φτιάχνουμε δύο τυχαίες λίστες με γονότυπους χρησιμοποιώντας τα παραπάνω allele frequencies. Η πρώτη λίστα είναι η εξομείωση του SNP στον πρώτο πληθυσμό και η δεύτερη η εξομείωση για τον δεύτερο.


```python
import random
def random_frequency():
    '''
    Generate a random number between 0.0 and 0.5
    '''
    return random.uniform(0.0, 0.5)

def random_perturbation(r, perturbation=0.2):
    '''
    Takes a random value and returns a random perturbation in the range of -perturbation to +perturbation 
    '''
    perturbation = random.uniform(-perturbation, perturbation)
    return r + (r*perturbation)
    
def generate_random_frequencies(n):
    '''
    Simulates n random allele frequencies from n different populations
    '''
    base_frequency = random_frequency()
    return [random_perturbation(base_frequency) for i in range(n)]

def generate_random_allele(p, reference='A', alternative='B'):
    '''
    Generates a random allele.
    It selects "alternative" with propability p and "reference" with probability 1-p 
    '''
    if random.random() <= p:
        return alternative
    return reference

def generate_random_genotype(frequency):
    '''
    Generates a random genotype
    '''
    return [generate_random_allele(frequency) for i in range(2)]

def generate_random_genotypes(frequency, n):
    '''
    Generates n random SNPs with specific frequency
    '''
    return [generate_random_genotype(frequency) for i in range(n)]
    
    
def generate_random_population(pop_1, pop_2, SNPs):
    '''
    Generates a dataset that contains:
    pop_1 samples belonging to #1 population
    pop_2 samples belonging to #2 population
    
    SNPs is the number of SNPs
    '''
    
    ret = [] # We will return this
    
    for snp_counter in range(SNPs):
        # Take 2 different allele grequencies
        fr_1, fr_2 = generate_random_frequencies(2)
        
        # Generate genotypes
        pop_1_genotypes = generate_random_genotypes(fr_1, pop_1)
        pop_2_genotypes = generate_random_genotypes(fr_2, pop_2)
        
        #Merge into a single list add it to the ret
        merged = pop_1_genotypes + pop_2_genotypes
        ret.append(merged)
        
    return ret


```

Στη συνέχεια φτιάχνουμε ένα τυχαίο dataset με δύο πληθυσμούς, 100 samples ο κάθε ένας και 1000 SNPs:


```python
genotypes = generate_random_population(100, 100, 1000)
```

Για να συνεχίσουμε θα πρέπει να φτιάξουμε μία συνάρτηση που μετατρέπει τους γονότυπους σε αριθμητικές τιμές:
* Ο γονότυπος Α/Α (ομόζυγο reference) γίνεται 0
* Ο γονότυπος Α/Β (ετερόζυγο) γίνεται 1
* Ο γονότυπος Β/Β (ομόζυγο alternative) γίνεται 2



```python
def convert_genotype_to_numeral(genotype):
    if genotype == ['A', 'A']:
        return 0
    if genotype == ['A', 'B']:
        return 1
    if genotype == ['B', 'A']:
        return 1
    if genotype == ['B', 'B']:
        return 2
    
    assert False # This should never happen
    
def convert_genotype_data_to_numeral(genotypes):
    ret = []
    for snp in genotypes:
        snp_numerical = [convert_genotype_to_numeral(g) for g in snp]
        ret.append(snp_numerical)
        
    return ret

```

Μετατρέπουμε τα genotypes σε numerical:


```python
genotypes_numerical = convert_genotype_data_to_numeral(genotypes)
```

Τώρα έχουμε μία λίστα από λίστες με αριθμητικές τιμές που περιέχει τους γονότυπους. Για να συνεχίσουμε θα πρέπει να χρησιμοποιήσουμε τη βιβλιοθήκη [numpy](http://www.numpy.org/). Το numpy είναι μια βιβλιοθήκη για αλγορίθμους γραμμικής άλγεβρας και [αριθμητικής ανάλυσης](https://en.wikipedia.org/wiki/Numerical_analysis). Είναι υλοποιημένη σε [γλώσσες χαμηλού επιπέδου](https://en.wikipedia.org/wiki/Low-level_programming_language) και δίνει στη python τη δυνατότητα να επεξεργαστεί με εξαιρετική ταχύτητα μεγάλα αριθμητικά δεδομένα.


```python
import numpy
```

Μετατρέπουμε το genotypes_numerical σε έναν πίνακα ώστε να μπορεί να τον διαχειριστές η numpy:


```python
genotypes_array = numpy.array(genotypes_numerical)
```

Στη συνέχεια πρέπει να εφαρμόσουμε PCA στον πίνακα genotypes_numerical. Το κάνουμε αυτό μέσω της βιβλιοθήκης [sklearn](http://scikit-learn.org/). Αρχικά εγκαθιστούμε τη βιβλιοθήκη: 


```python
!conda install -y scikit-learn
```

    Fetching package metadata .........
    Solving package specifications: .
    
    Package plan for installation in environment /Users/alexandroskanterakis/anaconda3/envs/arkalos:
    
    The following NEW packages will be INSTALLED:
    
        scikit-learn: 0.19.0-np113py36_0
        scipy:        0.19.1-np113py36_0
    
    scipy-0.19.1-n 100% |################################| Time: 0:04:11  64.85 kB/s
    scikit-learn-0 100% |################################| Time: 0:00:42 130.11 kB/s


Κάνουμε import τις συναρτήσεις που κάνουν PCA:


```python
from sklearn.decomposition import PCA
```

Δηλώνουμε ότι μέσω του PCA θα κάνουμε προβολή των δεδομένων μας στις δύο διαστάσεις: 


```python
pca = PCA(n_components=2)
```

Κάνουμε fit το pca. Προσοχή: Ο πίνακας genotypes_array έχει 1000 γραμμές (SNPs) και 200 στήλες (samples). Η συνάρτηση PCA θεωρεί ότι οι γραμμές είναι data και οι στήλες διαστάσεις. Οπότε πρέπει να κάνουμε [transpose](https://en.wikipedia.org/wiki/Transpose) τον πίνακα: 


```python
pca.fit(genotypes_array.T)
```




    PCA(copy=True, iterated_power='auto', n_components=2, random_state=None,
      svd_solver='auto', tol=0.0, whiten=False)



Κάνουμε προβολή στις 2 διαστάσεις που υπολόγισε το pca.fit:


```python
genotypes_PCA = pca.transform(genotypes_array.T)
```

Ελέγχουμε τις διαστάσεις του genotypes_PCA:


```python
genotypes_PCA.shape
```




    (200, 2)



Προσέχτε ότι από τις 1000 διαστάσεις, πήγαμε στις 2. Τώρα μπορούμε να "δούμε" τα δεδομένα μας στις δύο διαστάσεις:


```python
import matplotlib.pyplot as plt
```

Τα πρώτα 100 samples ανήκουν στον πρώτο πληθυσμό και θα είναι με κόκκινο χρώμα. Τα υπόλοιπα 100 samples ανήκουν στον δεύτερο πληθυσμό και θα τα δείξουμε με μπλε χρώμα:


```python
plt.plot(genotypes_PCA[:100,0], genotypes_PCA[:100,1], '.', color="red")
plt.plot(genotypes_PCA[100:,0], genotypes_PCA[100:,1], '.', color="blue")
plt.show()
```


    
![png](output_77_0.png)
    


Παρατηρούμε ότι το PCA μπόρεσε και διαχώρισε σε έναν βαθμό τους δύο πληθυσμούς. Οπότε σε αυτό το μέρος θα πρέπει το πρόγραμμά σας να δέχεται τους παρακάτω παραμέτρους:
* ```--input_filename <FILENAME>``` αυτό είναι το αρχείο με τους τυχαίους γονότυπους που έχετε φτιάξει στο μέρος 3,4 ή 5.
* ```--action PCA``` δηλώνουμε ότι θέλουμε να κάνουμε PCA. Δηλαδή το πρόγραμμά σας θα πρέπει να κάνει την ανάλυση που περιγράφηκε παραπάνω
* ```--PCA_filename <FILENAME>``` στο αρχείο αυτό θα σώζετε τα δι-διάστατα δεδομένα από το PCA.
* ```--PCA_plot <FILENAME>``` στο αρχείο αυτό θα πρέπει να σώζετε το plot από το PCA (σε ό,τι φορμάτ θέλετε)



### Σημειώσεις
1. Ο κώδικας που δίνεται εδώ είναι ενδεικτικός. Μπορείτε να τον χρησιμοποιήσετε, αλλάξετε κτλ.
2. Μπορείτε να χρησιμοποιήσετε όποια μέθοδο θέλετε για PCA.
3. Ποτέ δεν ξεχνάμε να κλείσουμε τα αρχεία που έχουμε ανοίξει!


```python
file.close()
```



# Project 4
<!--  https://gist.github.com/kantale/93df74b2b69890b57677e43158994a1a -->

## Μέρος 1
Ας υποθέσουμε ότι υπάρχει ένα mutation σε κάποια θέση του γονιδιώματος, το οποίο έχει δύο αλληλόμορφα: το A και το B.
Ας ορίσουμε ως pB τη πιθανότητα, να εμφανιστεί το αλληλόμορφο Β σε ένα σετ από τα 2 σετ χρωμοσωμάτων που έχει ο άνθρωπος. 
Τότε η πιθανότητα να έχει δύο B (ομόζυγος) είναι ```pB**2```. Επίσης η πιθανότητα να έχει ένα Α και ένα Β (ετερόζυγος) είναι ```(1-pB)*pB```.
Φτιάξτε μία συνάρτηση η οποία θα παίρνει δύο ορίσματα: το pB και το Ν. Η συνάρτηση θα επιστρέφει μία λίστα με τους γονότυπους από Ν "τυχαίους" ανθρώπους. Ο κάθε γονότυπος θα είναι είτε (Α,Α), είτε (Α,Β), είτε (Β,Β). Όπως είπαμε η πιθανότητα να "εμφανιστεί" ένα Β θα πρέπει να είναι pB. Η πιθανότητα να "εμφανιστεί" ένα Α είναι 1-pΒ. 

Η παρακάτω εντολή παράγει ένα τυχαίο δεκαδικό (float) αριθμό από το 0 μέχρι το 1.
```python
import random
random.random()
```

Η παρακάτω εντολή τυπώνει "κιθαρίστας" με πιθανότητα 80% και "ντράμερ" με πιθανότητα 20%.
```python
if random.random() < 0.8:
   print ('κιθαρίστας')
else:
   print ('ντράμερ')
```

**ΠΡΟΣΟΧΗ 1** Θεωρούμε ότι τα δύο χρωμοσώματα έχουν "ανεξάρτητες τιμές". Δηλαδή η πιθανότητα το ένα να είναι Β είναι ανεξάρτητη από τη πιθανότητα το άλλο να είναι Β. 

**ΠΡΟΣΟΧΗ 2** Κάποια βασικά: Το σύνολο όλου του γενετικού υλικού ενός οργανισμού ονομάζεται γονιδίωμα. Ο άνθρωπος έχει 2 σετ από [autosome](https://en.wikipedia.org/wiki/Autosome) χρωμοσώματα στο γονιδίωμά του. Το κάθε σετ έχει 22 χρωμοσώματα. Το ένα σετ το έχουμε πάρει από τον πατέρα μας και το άλλο από τη μητέρα μας. Θεωρούμε ότι η μετάλλαξη για την οποία μιλάει αυτή η άσκηση εμφανίζεται σε μία και μόνο μία θέση σε όλο το γωνιδίωμα. Δεν έχει σημασία σε ποιο χρωμόσωμα εμφανίζεται. Το θέμα είναι ότι η μετάλλαξη αυτή μπορεί είτε να υπάρχει, είτε να μην υπάρχει σε έναν άνθρωπο. Αν υπάρχει τότε μπορεί να εμφανιστεί με δύο τρόπους: ως ετερόζυγη (Α/Β), είτε ως ομόζυγη (Β/Β). Αν δεν υπάρχει τότε έχουμε Α/Α. Α/Β σημαίνει ότι το ένα σετ από χρωμοσώματσα δεν έχει τη μετάλλαξη, ενώ το άλλο την έχει (ή αλλιώς έχουμε πάρει τη μετάλλαξη ή από τον πατέρα μας ή από τη μητέρα μας). Β/Β σημαίνει ότι η μετάλλαξη υπάρχει και στα δύο σετ από χρωμοσώματα (ή αλλιώς την μετάλλαξη την έχουμε κληρονομήσει και από τον πατέρα μας και από τη μητέρα μας). Α/Α σημαίνει ότι ΔΕΝ έχουμε κληρονομήσει τη μετάλλαξη. 
Τα Α/Α, Α/Β και Β/Β ονομάζονται γονότυπος. Τα Α και Β ονομάζονται αλληλόμορφα. 

Ένας άλλος τρόπος να διατυπωθεί η άσκηση είναι:

Μία μπάλα μπορεί να είναι είτε άσπρη, είτε μαύρη. Η πιθανότητα να είναι μαύρη μία μπάλα είναι pB και η πιθανότητα να είναι άσπρη είναι 1-pB. Ένα κουτί έχει 2 μπάλες. Άρα ένα κουτί μπορεί να έχει είτε Άσπρη/Άσπρη, είτε Άσπρη/Μαύρη είτε Μαύρη/Μαύρη μπάλες. Η πιθανότητα η μία μπάλα να είναι μαύρη **είναι ανεξάρτητη** από τη πιθανότητητα η άλλη μπάλα να είναι μαύρη στο ίδιο κουτί. Φτιάξτε μία συνάρτηση που να παίρνει δύο παρπαμέτρους: pB και Ν. Η συνάρτηση επιστρέφει Ν κουτιά από ζευγάρια από μπάλες (ή αλλιώς μία λίστα μεγέθους Ν όπου το κάθε αντικείμενο της λίστας θα είναι ένα tuple με δύο strings). Η πιθανότητα κάθε μπάλα να είναι μαύρη είναι pB. 


## Μέρος 2ο
Συνεχίζουμε από το μέρος 1ο. Ας υποθέσουμε ότι αν ένας άνθρωπος έχει ένα (ή παραπάνω) 'B' τότε έχει αυξημένες πιθανότητες να έχει κάποια ασθένεια. Ορίζουμε τρεις πιθανότητες:
* pAA = Η πιθανότητα ένας άνθρωπος να έχει (A,A) και να έχει την ασθένεια
* pAB = Η πιθανότητα ένας άνθρωπος να έχει (Α,Β) και να έχει την ασθένεια 
* pBB = Η πιθανότητα ένας άνθρωπος να έχει (Β,Β) και να έχει την ασθένεια

ισχύει ότι: pΑΑ < pAB < pBB 

Φτιάξτε μία συνάρτηση η οποία θα παίρνει 5 παραμέτρους: το Ν, το pB, το pAA, το pAB και το pBB.
H συνάρτηση θα πρέπει να επιστρέφει μία λίστα με τον γονότυπο από Ν ανθρώπους (όπως ακριβώς στην άσκηση 14) μαζί με το αν έχουν την ασθένεια ή όχι. Δηλαδη θα πρέπει να επιστρέφει μία λίστα της μορφής:

```python
a = [
   ('A', 'A', False), # είναι Α/Α και ΔΕΝ έχει την άσθένεια,
   ('A', 'B', True), # είναι A/B και Έχει την ασθένεια,
   ...
] 
```

Το αν έχουν την ασθένεια (ή όχι) καθορίζεται τυχαία, ανάλογα με τις παραμέτρους pAA, pAB, pBB. Δηλαδή παίρνουμε έναν άνθρωπο και ελέγχουμε τι γονότυπο έχει. Ας υποθέσουμε ότι έχει Α/Β. Άραγε έχει την ασθένεια; Για να το βρούμε αυτό παίρνουμε έναν **καινούργιο** τυχαίο αριθμό (```random.random()```) και ελέγχουμε αν αυτός ο αριθμός είναι μικρότερος από pAB. Αν είναι τότε αυτός ο άνθρωπος έχει την ασθένεια. Αν όχι τότε δεν έχει την ασθένεια. Ένα άλλο παράδειγμα: Παίρνουμε έναν άλλο άνθρωπο και ελέγχουμε τον γονότυπό του. Ας υποθέσουμε ότι είναι A/A, άραγε έχει την ασθένεια; Για να το βρούμε παίρνουμε έναν **άλλο και καινούργιο** τυχαίο αριθμό (```random.random()```) και κοιτάμε αν αυτός ο αριθμός είναι μικρότερος από το pAA. Αν είναι τότε ο άνθρωπος αυτός έχει την ασθένεια, αλλιώς δεν την έχει. 

**ΠΡΟΣΟΧΗ 1!** το pAB ΔΕΝ είναι η πιθανότητα να έχει γονότυπο Α/Β αλλά η πιθανότητα ΑΝ έχει γονότυπο Α/Β τότε να έχει την ασθένεια. 

Ένας άλλος τρόπος να το δούμε (με μπάλλες). Έχετε ένα κουτί με 100 ζευγάρια από μπάλες. Κάθε μπάλα του ζευγαριού μπορεί να είναι είτε άσπρη, είτε μαύρη. Η πιθανότητα μία μπάλα να είναι μαύρη είναι pB. Κάθε ζευγάρι μπορεί να είναι είτε Άσπρη/Άσπρη, είτε Άσπρη/Μαύρη, είτε Μαύρη/Μαύρη. Κάθε ζευγάρι μπορεί να είναι είτε Κινέζικης, είτε Ελληνικής κατασκευής. Οι πιθανότητες ένα ζευγάρι να είναι Ελληνικής κατασκευής εξαρτιώνται από το χρώμμα τους. Η πιθανότητα ένα ζευγάρι να είναι Άσπρη/Άσπρη και να είναι Ελληνικής κατασκευής είναι pAA, η πιθανότητα ένα ζευγάρι να είναι Ελληνικής κατασκευής και να είναι Άσπρη/Μαύρη είναι pAB και η πιθανότητα ένα ζευγάρι να είναι Ελληνικής κατασκευής και να είναι Μαύρη/Μαύρη είναι pBB. 

## Μέρος 3ο
Συνεχίζουμε από το 2ο μέρος, και κάνουμε τώρα την εξής υπόθεση: Αν μετρήσουμε τον μέσο όρο των "Β" σε αυτούς που έχουν την ασθένεια και το μέσο όρο των "Β" σε αυτούς που ΔΕΝ έχουν την ασθένεια, θα πρέπει αυτοί που έχουν την ασθένεια να έχουν μεγαλύτερο μέσο όρο. Θα πρέπει να φτιάξετε μία συνάρτηση η οποία θα παίρνει ως παράμετρο τη λίστα που επιστρέφει η συνάρτηση της άσκησης 15, και να επιστρέφει True ή False ανάλογα με το αν η παραπάνω υπόθεση είναι σωστή ή όχι.  

Για παράδειγμα έστω ότι οι "υγιείς" είναι ```healthy = ['AA', 'AA', 'AB']``` και οι "ασθενείς" είναι ```disease = ['AB', 'AA', 'BB']``` Τότε: Ο μέσος όρος των Β στους healthy είναι: 1/6 και ο μέσος όρος των Β στους disease είναι: 3/6. Αφού ```3/6>1/6``` τότε η συνάρτηση επιστρέφει True. Διαφορετικά επιστρέφει False.

## Μέρος 4ο
Τώρα μπορούμε να κάνουμε το εξής πείραμα: Αν έχουμε τους 5 παραμέτρους της συνάρτησης του 2ου μέρος, μπορούμε να δούμε με τη συνάρτηση του 2ου μέρους αν η υπόθεση του 3ου μέρους είναι σωστή. Φυσικά αυτό είναι μία μοναδική παρατήρηση. Θα ήταν ενδιαφέρον να επαναλάβουμε αυτή τη διαδικασία πολλές φορές και να μετρήσουμε το ποσοστό τους που η υπόθεση **ΔΕΝ** ήταν σωστή. Φτιάξτε μία συνάρτηση η οποία να παίρνει 6 ορίσματα: τα ορίσματα του 2ου μέρους και ένα όρισμα Τ το οποίο είναι πόσες φορές θέλουμε να επαναλάβουμε το πείραμα. Η συνάρτηση θα επιστρέφει έναν αριθμό από το 0 μέχρι 100 το οποίο θα είναι το ποσοστό των Τ επαναλήψεων για τις οποίες η υπόθεση του 3ου μέρου είναι Λάθος. 

**Αν έχετε φτάσεις μέχρι εδώ συγχαρητήρια μόλις υλοποιήσατε ένα [False Discovery Rate](https://en.wikipedia.org/wiki/False_discovery_rate), ή αλλιώς FDR**

## Μέρος 5ο
Τώρα, ήρθε η ώρα να απαντήσουμε σε ένα βιολογικό ερώτημα! Ας υποθέσουμε ότι οι πιθανότητες pAA, pAB και PBB είναι:
* pAA = 0.1
* pAB = 0.15
* pBB = 0.2

Η ερώτηση είναι: ποια πρέπει να είναι η μικρότερη τιμή της πιθανότητας pB, ώστε να μπορώ να επιβεβαιώσω τη συσχέτιση με την ασθένεια με FDR<0.05, σε έναν πληθυσμό με Ν=1000 και Τ=2000; Για να απαντήσουμε στην ερώτηση αυτή, τρέχτε τη συνάρτηση του 4ου μέρους για διάφορες τιμές του pB. Ξεκινήστε από 0.01 και αυξήστε το με βήμα 0.005. Για κάθε τιμή του pB υπολογίστες το FDR. Όταν το FDR πάρει τιμή κάτω από 0.05 σταματήστε και τυπώστε τη τιμή του pB που βρήκατε.  

Φτιάξτε μία συνάρτηση η οποία παίρνει τις παραμέτρους: N, T, pAA, pAB, pBB και επιστρέφει το μικρότερη τιμή του pB ώστε να μπορεί να επιβεβαιωθεί η συσχέτιση με την ασθένεια με FDR<0.05. Η συνάρτηση θα πρέπει να κάνει ό,τι και αυτό το βήμα. Δηλαδή ξεκινάει με pB=0.01, υπολογίζει το FDR και αν αυτό είναι μεγαλύτερο από 0.05 αυξάνει το pB με βήμα 0.005 και συνεχίζει. Όταν βρει FDR<0.05 σταματάει και επιστέφει το pB που βρήκε.  

το ζητούμενο σε αυτό το project είναι ένα πρόγραμμα το οποίο θα παίρνει τις παρακάτω παραμέτρους από το command line:
--T <ΑΚΕΡΑΙΑ ΤΙΜΗ>, 
--pAA <ΔΕΚΑΔΙΚΗ ΤΙΜΗ>, 
--pAB <ΔΕΚΑΔΙΚΗ ΤΙΜΗ>
--pBB <ΔΕΚΑΔΙΚΗ ΤΙΜΗ>
--FDR <ΔΕΚΑΔΙΚΗ ΤΙΜΗ>   (προαιρετικό, αν δεν δοθεί, θεωρείτε ότι η τιμή του είναι 0.05)
--N <ΑΚΕΡΑΙΑ ΤΙΜH> <ΑΚΕΡΑΙΑ ΤΙΜH> <ΑΚΕΡΑΙΑ ΤΙΜΕ>

Στη συνέχεια θα φτιάχνει και θα σώζει σε ένα αρχείο ένα plot όπου στον X άξονα θα είναι οι τιμές του N από το Α μέχρι μέχρι Β με βήματα Γ, όπου Α,Β,Γ είναι οι τρεις ακέραιες τιμές της παραμέτρου N (χρησιμοποιήστε τη np.linspace). Στον Υ άξονα θα είναι η ελάχιστη τιμή του pB για το κάθε Ν τέτοιο ώστε το FDR να είναι μικρότερο από τη τιμή που δόθηκε στην αντίστοιχη παράμετρο (--FDR);  

# Project 5 & Project 6

Η εισαγωγή για αυτά τα δύο projects είναι κοινή.

<!-- https://gist.github.com/kantale/993abe0fedb45703b0528abd7f048b42 -->
### Εισαγωγή
Σήμερα υπάρχουν πάρα πολλές βάσεις δεδομένων που περιέχουν πολύτιμη πληροφορία για οποιαδήποτε έννοια της γενετικής.
Κλασικά παραδείγματα είναι πληροφορίες για την ακολουθία ενός γονιδίου, τη θέση του στο γονιδιώματα, πόσα exons/introns έχει, κτλ.
Η αναζήτηση σε μία τέτοια βάση δεδομένων γίνεται συνήθως με δύο τρόπους. 
Ο πρώτος είναι να πάμε σε κάποιο site (π.χ. http://www.ensembl.org) και μέσα από τη περιήγησή μας αλλά και τα πεδία που θα δώσουμε σε διάφορες φόρμες να βρούμε τη πληροφορία που θέλουμε.
Ο δεύτερος τρόπος είναι να κάνουμε το ίδιο τρόπο προγραμματιστικά. 
Δηλαδή να φτιάξουμε ένα πρόγραμμα/script το οποίο θα "ρωτάει" μία βάση δεδομένων και θα τυπώνει το αποτέλεσμα.

Είναι προφανές ότι κάθε μέθοδος έχει τα θετικά και τα αρνητικά της. 
Το να αλληλεπιδρούμε με ένα site είναι αργό (και βαρετό) για επαναλαμβανόμενες ερωτήσεις ενώ ο προγραμματιστικός τρόπος απαιτεί τη γνώση κάποιας γλώσσας προγραμματισμού αλλά και τον τρόπο με τον οποία θα πρέπει να "μιλήσει" το πρόγραμμα με τη βάση.
Ένας τρόπος να το διαπιστώσουμε αυτό είναι να ρωτήσουμε κάποιον έμπειρο βιολόγο κάτι απλό, π.χ: πόσα exons έχει το γονίδιο APOE;
Μπορούμε στη συνέχεια να κάνουμε την ίδια ερώτηση σε έναν βιοπληροφορικό και να δούμε τον τρόπο που θα απαντήσουν στην ερώτηση. 
Με όποιον τρόπο επιλέξουν να απαντήσουν, θα διαπιστώσουμε (ίσως με έκπληξη) ότι μία τέτοια απλή ερώτηση απαιτεί αρκετή ώρα "ψαξίματος".
Δεν θα ήταν ωραίο, λοιπόν, να υπήρχε κάποιο site το οποίο να μπορούσες να του θέσεις σε φυσική γλώσσα, απλές ερωτήσεις της γενετικής και αυτό να σου απαντούσε;

Αυτό λοιπόν είναι και το αντικείμενο του project!
Θα πρέπει να φτιάξετε ένα πρόγραμμα το οποίο θα παίρνει ως είσοδο απλές ερωτήσεις γενετικής, να ψάχνει τις κατάλληλες βάσεις δεδομένων και να τυπώνει την απάντηση. Οι ερωτήσεις θα πρέπει να είναι στα Αγγλικά. 

### Οντότητες
Το πρόγραμμά σας καταρχήν θα πρέπει να μπορεί να αναγνωρίζει τις παρακάτων οντότητες από το κείμενο της ερώτησης:

* Γονίδιο
    * Ένα από τα ονόματα που αναγνωρίζει επίσημα το HGNC. Μπορείτε να πάρετε τη λίστα όπως είχε περιγραφεί στην [άσκηση 18, της 3ης σειράς](https://gist.github.com/kantale/ae81d885cc84ee03edb7d39513b7deaf). Το link είναι: ftp://ftp.ebi.ac.uk/pub/databases/genenames/new/tsv/locus_groups/protein-coding_gene.txt 

* Μετάγραφο (transcript)
    * [RefSeq μετάγραφα](https://www.ncbi.nlm.nih.gov/refseq/). π.χ: ```NM_001350497.1``` ή ```NM_001350497``` . Λίστα με όλα τα μετάγραφα σε RefSeq, υπάρχει [εδώ](https://www.ncbi.nlm.nih.gov/projects/genome/guide/human/index.shtml) (RefSeq Reference Genome Annotation). Δεν είναι απαραίτητο να κατεβάσετε αυτό το αρχείο.
    * [ENSEMBL μετάγραφα](https://www.ensembl.org/info/genome/genebuild/genome_annotation.html). Για παράδειγμα: ```ENST00000003084```.

* Μετάλλαξη: (σε αυτό το project θα ασχοληθούμε μόνο με [Single Nucleotide Polymorphisms](https://en.wikipedia.org/wiki/Single-nucleotide_polymorphism))
    * ```rs12345678``` . [dbSNP](https://www.ncbi.nlm.nih.gov/projects/SNP/) variants
    * ```chr1:1234567A>G``` . Δηλαδή στο χρωμόσωμα 1, στη θέση 1234567 το Α γίνεται G.
    * ```1:1234567A>G```
    * <Γονίδιο>:c.100A>G . Δηλαδή στη 100η coding θέση του γονιδίου το Α, γίνεται G. 
    * <Μετάγραφο>:c.100A>G . Στη 100η coding θέση του μετάγραφου το Α, γίνεται G.

* Θέση στο γονιδίωμα: (θα το αναφέρουμε απλά ως "Θέση")
    * ```1:1234567``` (Χρωμόσωμα 1, θέση 1234567)
    * ```chr1:1234567```
    * ```chromosome 1, position 1234567```
    * ```chromosome 1 and position 1234567```
    * <Μετάλλαξη> , η θέση της μετάλλαξης στο γονιδίωμα


### requests
H βιβλιοθήkη [requests](http://docs.python-requests.org/en/master/) είναι ίσως η πιο δημοφιλής βιβλιοθήκη της python η οποία δεν είναι μέρος της "επίσημης" έκδοσης της python. Παρέχει πολύ απλούς μηχανισμούς για να έχετε πρόσβαση σε online πηγές δεδομένων. Για να την εγκαταστήσετε κάντε στο shell:
```bash
pip install requests 
```

Στη συνέχεια μπορείτε να τη κάνετε import στη python:
```python
import requests
```

Μέσω της ```requests``` μπορείτε να χρησιμοποιείτε τους μηχανισμούς [GET και POST που υποστηρίζει το HTTP πρωτόκολο](https://www.w3schools.com/tags/ref_httpmethods.asp) για να ζητάτε και να παίρνετε δεδομένα από άλλα sites. Μπορείτε να δείτε και τις [περσινές σημειώσεις](https://gist.github.com/kantale/66e077dd377b2459fe58f854467c40cd) για το πως μπορείτε να το κάνετε αυτό. 

### Βασικές πηγές πληροφορίας
Πριν ξεκινήσετε θα πρέπει να μελετήσετε τις παρακάτω πολύ βασικές πηγές βιολογικής πληροφορίας.

#### [mygene.info](http://docs.mygene.info/en/latest/doc/data.html)
Το mygene.info είναι μία από τις πιο δημοφιλής, γρήγορη και σύγχρονη πηγή (μετα)μεταπληροφορία για γονίδια. Περιέχει πληροφορία για τη θέση, λειτουργία, μονοπάτια κτλ για όλα τα γονίδια από πολλούς οργανισμούς. 

Υπάρχει [αναλυτική περιγραφή στο documentation του mygene.info για το πως μπορούμε να κάνουμε GET requests για να πάρουμε διάφορες πληροφορίες για γονίδια](http://docs.mygene.info/en/latest/doc/query_service.html). 

Για παράδειγμα έστω ότι θέλουμε να βρούμε ποια είναι η θέση του γονιδίου TPMT. Μέσω της ```requests```:

```python
import requests

parameters = {
  'fields': 'genomic_pos',
  'species': 'human',
  'q' : 'symbol:tpmt',
}
url = 'http://mygene.info/v3/query'

response = requests.get(url, params=parameters)

```

Στη συνέχεια μπορούμε να δούμε αν όλα πήγαν καλά:

```python
response.ok # Αυτό πρέπει να είναι True
```

Αφού επιβεβαιώσουμε ότι το ```response.ok``` είναι ```True```, μπορούμε να πάρουμε το αποτέλεσμα σε μορφή json:

```python
data = response.json()
print (data)
```
```text
{'max_score': 88.12873,
 'took': 4,
 'total': 1,
 'hits': [{'_id': '7172',
   '_score': 88.12873,
   'genomic_pos': {'chr': '6',
    'end': 18155074,
    'ensemblgene': 'ENSG00000137364',
    'start': 18128311,
    'strand': -1}}]}
```

Βλέπουμε ότι υπάρχει ένα ```start``` και ένα ```end```. Μπορούμε να τα προσπελάσουμε:

```python
chromosome = data['hits'][0]['genomic_pos']['chr']
start = data['hits'][0]['genomic_pos']['start']
end = data['hits'][0]['genomic_pos']['end']
print (chromosome, start, pos)
# Τυπώνει: ('6', 18128311, 18155074)
```  

#### [myvariant.info](http://docs.myvariant.info/en/latest/)
Παρόμοια με το mygene.info υπάρχει και το [myvariant.info το οποίο παρέχει ένα API για πληροφορίες για μεταλλάξεις](http://docs.myvariant.info/en/latest/). 
Η πρόσβαση γίνεται μέσω GET requests. 
Για παράδειγμα ποια είναι η θέση της μετάλλαξης rs58991260;

```python
url = 'http://myvariant.info/v1/query'
parameters = {
    'q': 'rs58991260',
    'fields': 'dbsnp',
}

data = requests.get(url, params=parameters)
```
```python
data.ok # True
```
```python
chromsome = d['hits'][0]['dbsnp']['chrom']
start = d['hits'][0]['dbsnp']['hg19']['start']
end = d['hits'][0]['dbsnp']['hg19']['end']
print (chromosome, start, end)
## Τυπώνει: 6 218631822 218631822 
# To start με το end είναι το ίδιο αφού πρόκειται για SNP
```

Αν θέλετε μπορείτε να διαβάσετε και τη δημοσίευση:

> [Xin, Jiwen, et al. "High-performance web services for querying gene and variant annotation." Genome biology 17.1 (2016): 91.](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-0953-9)


#### GENCODE
Η [GENCODE](https://www.gencodegenes.org/) είναι μία προσπάθεια ώστε να καταγραφούν όλα τα "λειτουργικά" κομμάτια του ανθρώπινου γονιδιώματος.
[Χρησιμοποιώντας διάφορες μεθοδολογίες](https://en.wikipedia.org/wiki/GENCODE#Methodology) (αυτόματες και με ανθρώπινο curation), καταγράφει σε ποιες περιοχές υπάρχουν γονίδια και πως τα γoνίδια αυτά χωρίζονται σε υπο-περιοχές (introns, exons, CDS, stop codons, start codon, 5' UTR και 3'UTR).


Σε αυτό το ftp site: ```ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_29/``` υπάρχουν όλα τα αρχεία με τη τελευταία έκδοση της GENCODE.
Ειδικά σε αυτό το αρχείο: ```ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_29/_README.TXT``` περιγράφεται τι περιέχει το κάθε αρχείο. Εκεί διαβάζουμε:

```
1. gencode.vX.annotation.{gtf,gff3}.gz:
  Main file, gene annotation on reference chromosomes in GTF and GFF3 file formats.
  These are the main GENCODE gene annotation files. They contain annotation (genes, 
  transcripts, exons, start_codon, stop_codon, UTRs, CDS) on the reference chromosomes,
  which are chr1-22, X, Y, M in human and chr1-19, X, Y, M in mouse.
```

Οπότε για αυτό το project θα χρησιμοποιήσουμε το ```gencode.v29.annotation.gff3.gz``` το οποίο μπορούμε να κατεβάσουμε απο εδώ: ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_29/gencode.v29.annotation.gff3.gz
Επίσης μπορείτε να μελετήσετε το [format gff3](http://gmod.org/wiki/GFF3) το οποίο χρησιμοποιεί η GENCODE.
Η ίδια πληροφορία υπάρχει και σε ένα άλλο format το οποίο λέγεται GTF, αλλά το GFF3 θεωρείται λίγο πιο εξελιγμένο. Μπορείτε να [διαβάσετε περισσότερα εδώ](https://www.biostars.org/p/99462/).

Ας κατεβάσουμε λοιπόν το αρχείο από το command line:
```bash
wget ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_29/gencode.v29.annotation.gff3.gz 
```

Μέσα σε αυτό το αρχείο βρίσκουμε αυτές τις γραμμές:
(Εχω κρατήσει μόνο ένα συγκεκριμμένο μήκος για κάθε γραμμή)
```
chr1    ENSEMBL transcript      2586750 2591467 .       +       .       ID=ENST00000444521.6;Parent=ENSG00000157870.15;
chr1    ENSEMBL exon    2586750 2586948 .       +       .       ID=exon:ENST00000444521.6:1;Parent=ENST00000444521.6;
chr1    ENSEMBL CDS     2586796 2586948 .       +       0       ID=CDS:ENST00000444521.6;Parent=ENST00000444521.6;
chr1    ENSEMBL start_codon     2586796 2586798 .       +       0       ID=start_codon:ENST00000444521.6;Parent=ENST00000444521.6;
chr1    ENSEMBL exon    2587091 2587295 .       +       .       ID=exon:ENST00000444521.6:2;Parent=ENST00000444521.6;
chr1    ENSEMBL CDS     2587091 2587295 .       +       0       ID=CDS:ENST00000444521.6;Parent=ENST00000444521.6;
chr1    ENSEMBL exon    2587741 2587792 .       +       .       ID=exon:ENST00000444521.6:3;Parent=ENST00000444521.6;
chr1    ENSEMBL CDS     2587741 2587792 .       +       2       ID=CDS:ENST00000444521.6;Parent=ENST00000444521.6;
chr1    ENSEMBL exon    2588336 2588453 .       +       .       ID=exon:ENST00000444521.6:4;Parent=ENST00000444521.6;
chr1    ENSEMBL CDS     2588336 2588453 .       +       1       ID=CDS:ENST00000444521.6;Parent=ENST00000444521.6;
chr1    ENSEMBL exon    2588550 2588625 .       +       .       ID=exon:ENST00000444521.6:5;Parent=ENST00000444521.6;
chr1    ENSEMBL CDS     2588550 2588625 .       +       0       ID=CDS:ENST00000444521.6;Parent=ENST00000444521.6;
chr1    ENSEMBL exon    2588922 2589040 .       +       .       ID=exon:ENST00000444521.6:6;Parent=ENST00000444521.6;
chr1    ENSEMBL CDS     2588922 2589040 .       +       2       ID=CDS:ENST00000444521.6;Parent=ENST00000444521.6;
chr1    ENSEMBL exon    2589410 2591467 .       +       .       ID=exon:ENST00000444521.6:7;Parent=ENST00000444521.6;
chr1    ENSEMBL CDS     2589410 2589427 .       +       0       ID=CDS:ENST00000444521.6;Parent=ENST00000444521.6;
chr1    ENSEMBL stop_codon      2589425 2589427 .       +       0       ID=stop_codon:ENST00000444521.6;Parent=ENST00000444521.6;
chr1    ENSEMBL five_prime_UTR  2586750 2586795 .       +       .       ID=UTR5:ENST00000444521.6;Parent=ENST00000444521.6;
chr1    ENSEMBL three_prime_UTR 2589428 2591467 .       +       .       ID=UTR3:ENST00000444521.6;Parent=ENST00000444521.6;
chr1    ENSEMBL transcript      2586750 2591467 .       +       .       ID=ENST00000378425.9;Parent=ENSG00000157870.15;
```

Τι σημαίνουν όλα αυτά; Αυτά είναι τα δομικά στοιχεία μίας μεταγραφής (ENST00000444521.6) ενός γονιδίου (PRXL2B). 
Ένα γονίδιο μπορεί να μεταγραφεί με πολλούς τρόπους, ή αλλιώς σε πολλά μετάγραφα (transcripts). 
Στο παράδειγμά μας βλέπουμε τα δομικά στοιχεία του μετάγραφου ENST00000444521.6 .
Ένα μετάγραφο περιέχει exons και introns.
Το πρώτο exon αποτελείται από τη περιοχή 5'UTR και τη περιοχή CDS (CoDing Sequence).
H περιοχή CDS του πρώτου exon αρχίζει από το start codon.
Στα exons που δεν είναι πρώτα ή τελευταία η περιοχή CDS ταυτίζεται με τη περιοχή του exon.
Το τελευταίο exon αποτελείται από το CDS και 3'UTR. 
To CDS του τελευταίου exon τελειώνει με το stop codon.

Παρακάτω υπάρχει ένα διάγραμμα με τη παραπάνω πληροφορία ([powerpoint version](https://www.dropbox.com/s/vo36k1syab5fp35/6b1cafa6581b4ae1b90d69b93858c49e.pptx?dl=0)). 
![img](https://i.imgur.com/84rY2x0.png)


Άρα από το αρχείο ```gencode.v29.annotation.gff3.gz``` μπορούμε να ξέρουμε τι ακριβώς μπορεί να βρούμε σε οποιαδήποτε περιοχή του γoνιδιώματος. 


Αν παρατηρήσουμε το αρχείο θα δούμε ένα βασικό πρόβλημα: Για κάθε γονίδιο υπάρχουν πολλά transcripts. 
Αυτό είναι γνωστό από τη βιολογία, ότι ένα γονίδιο μπορεί να έχει πολλά μετάγραφα λόγω ενός φαινομένου που ονομάζεται [alternative splicing](https://en.wikipedia.org/wiki/Alternative_splicing).
Πως μπορώ να ξέρω εγώ ποιο είναι το πιο "βασικό";
Δηλαδή για πιο transcript θα απαντάει το πρόγραμμά μου;
Για να το λύσουμε αυτό υπάρχουν δύο τρόποι. 

Ο πρώτος είναι να συμβουλευτούμε τη βάση δεδομένων [appris](http://appris.bioinfo.cnio.es), η οποία έχει τη πληροφορία "πόσο βασικό" είναι ένα transcript για όλα τα γονίδια. 
Η appris έχει φτιάξει ένα [σύστημα ιεραρχικοποιήσης των transcripts](http://appris.bioinfo.cnio.es/#/downloads).
Ιεραρχικοποιεί τα transcripts με 8 tags: PRINCIPAL:1, PRINCIPAL:2, PRINCIPAL:3, PRINCIPAL:4, PRINCIPAL:5, ALTERNATIVE:1, ALTERNATIVE:2 και MINOR.
Τα transcripts τα οποία είναι πιο "πάνω" στην ιεραρχία είναι και τα πιο βασικά. 
Μπορείτε να κατεβάσετε και όλη τη βάση appris από [αυτό το link](http://appris.bioinfo.cnio.es/#/downloads).

Ο δεύτερος τρόπος είναι να χρησιμοποιήσετε το πεδίo ```tag```, στο αρχείο από το GENCODE. 
Εκεί θα δείτε να υπάρχει σε κάποια transcripts, η πληροφορία ```tag=basic,appris_principal_2,CCD``` το οποίο αντιστιχεί και στη τιμή που έχει δόσει η appris. 
Αν ένα entry δεν έχει αυτή τη πληροφορία μπορείτε να το αγνοείται.

Μπορείτε να υλοποιήσετε οποιαδήποτε από τις δύο μεθόδους για να βρίσκετε το primary transcript ενός γονιδίου. 

#### Ensembl Sequence Region
H Ensembl δίνει το παρακάτω API: https://rest.ensembl.org/documentation/info/sequence_region με το οποίο μπορείτε να ζητήσετε το γονιδίωμα αναφοράς για οποιαδήποτε περιοχή.
Στο site αυτό δίνονται παραδείγματα καθώς και python 3 κώδικας. 

#### Ensembl Variant Effect Predictor (VEP)
Επίσης η Ensembl δίνει το παρακάτω API: https://rest.ensembl.org/documentation/info/vep_hgvs_get . To API αυτό δίνει πληροφορίες για μεταλλάξεις. Όπως βλέπετε και από το documentation υποστηρίζει μεταλλάξεις όπως: ```<Γονίδιο>:c.100A>T``` και ```<Ensembl Transcript>:c.100A>G```.

Αν έχετε βρει κάποιο άλλο API ή dataset το οποίο κάνει αυτές τις λειτουργίες εννοείται ότι μπορείτε να το χρησιμοποιήσετε. 

### Tasks
Τώρα που ξέρουμε πως να πάρουμε πληροφορία από το mygene.info, myvariant.info, το GENCODE, Ensembl Sequence Region και VEP, μπορούμε επιτέλους να απαντάμε στις πιο συχνές ερωτήσεις που έχουν οι βιολόγοι και βιοπληροφορικοί σχετικά με το ανθρώπινο γονιδίωμα. 
Σε αυτό το project λοιπόν, θα πρέπει να υλοποιήσετε ένα πρόγραμμα σε python το οποίο θα παίρνει σαν input μία ερώτηση στην Αγγλική γλώσσα και θα τυπώνει την απάντηση.
Το πρόγραμμά σας θα πρέπει να τρέχει από command line και θα πρέπει να δέχεται μία παράμετρο: ```-q <question>``` ή ```--question <question>```. 
Για παράδειγμα:
```bash
python project.py -q "What is the location of the gene TPMT?"
```
Στο οποίο θα τυπώνει κάτι σαν:
```text
chr 6
18128311-18155074
6p22.3
```

Στη python μπορείτε να πάρετε ορίσματα από τη γραμμή εντολών χρησιμοποιώντας τη βιβλιοθήκη [argparse](https://docs.python.org/3/library/argparse.html).
Για παράδειγμα για να διαβάσετε το όρισμα που δίνεται είτε με ```-q``` είτε με ```--question```, ένας τρόπος είναι:

```python
import argparse

if __name__ == '__main__':
   parser = argparse.ArgumentParser(description='The best python project ever')
   
   parser.add_argument('-q', '--question', help='Your question in english')

   args = parser.parse_args()
   question = args.question

   print ('The question asked is:', question)
```

Σε [αυτό το post](https://stackoverflow.com/questions/419163/what-does-if-name-main-do) υπάρχει μία πολύ καλή εξήγηση του τι κάνει το ```if __name__ == '__main__':```.

###  Project 5. Εμφάνιση exon/intron map 
Ο σκοπός αυτού του project είναι να φτιάξετε ένα γράφημα με τα intron/exon maps όπως κωδικοποιείται στο GENCODE.

Το πρόγραμμά σας θα παίρνει μία από τις παρακάτω παραμέτρους
* --gene όνομα_γονιδίου
* --transcript όνομα_ματάγραφου 
* --mutation όνομα_μετάλλαξης

Αν δοθεί η παράμετρος ```--gene``` τότε θα φτιάχνει το intron / exon map του κύριου μετάγραφου (primary transcript) του γονιδίου της παραμέτρου. Αν δοθεί η παράμετρος ```--transcript``` τότε θα φτιάχνει το intro/exon map αυτού του μετάγραφου. Αν δοθεί η παράμετρος ```--mutation``` τότε θα φτιάχνει το intro/exon map του κύριου μετάγραφου του γονιδίου που βρίσκεται η μετάλλαξη (αν η μετάλλαξη δεν είναι σε γονίδιο, πετάει ένα μήνυμα λάθους). 

Το πρόγραμμά σας λοιπόν θα πρέπει να βγάζει ένα γράφημα με το intron/exon map κάποιου μετάγραφου. 
Τι είναι αυτό όμως;

Ένα παράδειγμα αμφιβόλου αισθητικής, που έφτιαξα, είναι εδώ:

![img](https://i.imgur.com/5Tze5nC.png)

Μπορείτε να βρείτε πολλά παρόμοια στα Internets αν γκουγκλάρετε "exon/intron map" και ψάξετε για images. Υπάρχει και [σχετική συζήτηση στο biostars](https://www.biostars.org/p/17841/)
Προσέξτε ότι αν δηλωθεί η παράμετρος ```--mutation``` τότε η θέση της μετάλλαξης θα πρέπει να φαίνεται στο γράφημα. 


#### intron/exon map with string representation.
Αντί για το γράφημα με το intron/exon map που σας ζητήθηκε, αν θέλετε μπορείτε να το υλοποιήσετε έτσι ώστε το πρόγραμμά σας να βγάζει το ίδιο γράφημα αλλά σε text!
Μπορείτε να "πάρετε" χαρακτήρες για τους πίνακες από της [σελίδα της wikipedia για box drawing](https://en.wikipedia.org/wiki/Box-drawing_character#Unicode):
Δηλαδή μία αναπαράσταση σε κείμενο του γραφήματος που έδωσα στο παράδειγμα είναι:
```text
      Gene: PRXL2B
      Transcript: ENST00000444521.6

      ╔═════════════════════════════╗      ╱╲      ╔══════════════════════════════╗      ╱╲      ╔══════════════╗      ╱╲      ╔════════════════════════════╗
      ║            Exon 1           ║     ╱  ╲     ║            Exon 2            ║     ╱  ╲     ║    Exon 3    ║     ╱  ╲     ║            Exon 4          ║
      ╟──────────────┬──────────────╢    ╱    ╲    ╟──────────────┬───────────────╢    ╱    ╲    ╟──────────────╢    ╱    ╲    ╟──────────────┬─────────────╢
      ║    5'UTR     │    CDS       ║   ╱      ╲   ║              █               ║   ╱      ╲   ║              ║   ╱      ╲   ║     CDS      │    3'UTR    ║
      ╟──────────────┼──────────────╢  ╱        ╲  ║              █               ║  ╱        ╲  ║              ║  ╱        ╲  ╟──────────────┼─────────────╢
      ║              │              ║ ╱          ╲ ║              █               ║ ╱          ╲ ║              ║ ╱          ╲ ║              │             ║
      ║              │              ║╱            ╲║              █               ║╱            ╲║              ║╱            ╲║              │             ║
 123,456,789    123,456,890    123,458,895    123,459,345    123,459,445     123,459,545    123,460,765    123,460,865    123,461,865    123,462,543   123,462,865
                                                               **A>G**

```

Σημείωση: στο τερματικό μου [εμφανίζει κάτι σαν χριστουγεννιάτικα δέντρα](https://i.imgur.com/U2uC8t8.png), στις συνδέσεις των exons (γραμματοσειρά: Andale Mono).


### Project 6. Απάντηση ερωτημάτων του χρήστη.
Σε αυτό το project το πρόγραμμά σας θα πρέπει να απαντάει στις ερωτήσεις. 
Παραθέτω τα ελάχιστα ερωτήματα που πρέπει να υποστηρίζει το πρόγραμμά σας (και στα οποία θα βαθμολογηθείτε). 
Προφανώς και μπορείτε να τα επεκτείνετε όπως θέλετε εσείς. 
Για κάθε ερώτημα παραθέτω μερικές οδηγίες ή links για το πως μπορεί το πρόγραμμα σας να τις απαντήσει και κάποιες ενδεικτικές απαντήσεις. 
Εσείς μπορείτε να ακολουθήσετε διαφορετικές προσεγγίσεις για να τις απαντήσετε και μπορούν οι απαντήσεις σας να έχουν διαφορετική μορφή (αρκεί φυσικά να υπάρχει η ζητούμενη πληροφορία). 


1. "Which gene is upstream to gene <Γονίδιο> ?". Χρησιμοποιήστε το GENCODE. 
```
NHLRC1
```

Επίσης: "Which gene is downstream?", "Which gene is closest?"

2. "How many transcripts does the gene <Γονίδιο> have?" Χρησιμοποιήστε το GENCODE ή το mygene.info [link](http://mygene.info/v3/query?q=symbol:tpmt&fields=exons&species=human) (ή και τα δύο..)
```
[Τυπώστε μία λίστα με όλα τα διαφορετικά μετάγραφα και αναφέρεται πιο είναι το primary]
```

Επίσης: "Which transcripts exist for gene <Γονίδιο> ?"

3. "What is in <Θέση> ?" (Χρησιμοποιήστε το GENCODE)  

Παράδειγμα απάντησης:
```
This the 100th nucleotide of the 2nd exon of gene PRXL2B for transcript ENST00000444521.6. The length of this exon is XXX . downstream element is an intron in XXX bases. upstream element is an intron in XXX bases.
[Συμπληρώστε κατάλληλες τιμές για τα XXX]
Προσθέστε την ακολουθία του γονιδιώματος αναφοράς για -50 και +50 θέσεις από τη <Θέση> 
```

Για να βρείτε την ακολουθία μίας περιοχής του γονιδιώματος, μπορείτε να χρησιμοποιήσετε το ```sequence_region``` service της Ensembl: https://rest.ensembl.org/documentation/info/sequence_region

Αν δεν υπάρχει γονίδιο σε αυτή τη θέση μπορείτε να τυπώσετε:
```
This is an intergenic region.
Upstream closest gene is TP73 upstream in XXX bases.
Downstream closest gene is YYY downstream in ZZZ bases
```

Αν είναι μετάλλαξη αναφέρεται και το reference, alternative, sequence change και protein change [link](http://myvariant.info/v1/query?q=rs1815739)

Π.χ: "What is the location of the mutations <Μετάλλαξη> ?" ή ""What is the location of <Μετάλλαξη> ?"
```
chromosome: 11
position: 66328095
reference: C
alternative: T
Type: SNP
Gene: ACTN3
Transcript NM_001104.3, sequence change: c.1729C>T, protein change: p.Ter577Ter
Transcript NM_003793.3, sequence change: c.*3309G>A, protein change: ---
```

Η πληροφορία για τα transcripts, sequence change και protein change, υπάρχει στη myvariant.info. Παράδειγμα screenshot output από το myvariant.info: https://imgur.com/GOUFskO 

To myvariant.info μπορεί να επιστρέψει και πληροροφορίες για μια μετάλλαξη έχοντας μόνο της θέση της. Π.χ: http://myvariant.info/v1/query?q=chr3:8762685-8762685 

Επίσης: "What is the reference and alternative of <Μετάλλαξη> ?", "What type of mutation is <Μετάλλαξη> ?"


4. "What is the name of the gene <Γονίδιο> ?" (Χρησιμοποιήστε το mygene.info) [link](http://mygene.info/v3/query?q=symbol:tpmt&fields=name&species=human) [link2](http://mygene.info/v3/query?q=symbol:TPMT&fields=other_names&species=human)

Παράδειγμα για TPMT:
```
thiopurine methyltransferase

Other names:
S-adenosyl-L-methionine:thiopurine S-methyltransferase
thiopurine S-methyltransferase
```

5. "Where is the location of <Γονίδιο, μετάγραφο ή μετάλλαξη> ?" [link 1](http://mygene.info/v3/query?q=symbol:TPMT&fields=map_location&species=human) [link 2](http://mygene.info/v3/query?q=symbol:tpmt&fields=genomic_pos&species=human) [link 3](http://mygene.info/v3/query?q=symbol:tpmt&fields=genomic_pos.chr&species=human)

Π.χ για γονίδιο:
```
chr 6
18128311-18155074
6p22.3
```

Επίσης: "What is the chromosome of <...> ?", "What is the size of <...> ?", "Where is the start of <...> ?", "Where is the end of <...> ?"


6. "Which are the refseq transcripts of the gene <Γονίδιο> ?". Μπορείτε να χρησιμoποιήσετε το ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_29/gencode.v29.metadata.RefSeq.gz όπου υπάρχει αντιστοιχία μεταξύ ENSEMBL και RefSeq transcripts. Εναλλακτικά μπορείτε να χρησιμοποιήστε το mygene.info [link](http://mygene.info/v3/query?q=symbol:TPMT&fields=refseq&species=human)

Για παράδειγμα:
```
Which are the refseq transcripts of the gene TPMT?
```

```
[NM_000367, NM_001346817, NM_001346818]
[Also report which is the primary transcript. For example: NM_000367 is the primary]
```

7. "How many exons does <Γονίδιο ή Μετάγραφο> have ?". Μπορείτε να χρησιμοποιήσετε το GENCODE ή το mygene.info [link](http://mygene.info/v3/query?q=symbol:TPMT&fields=exons&species=human). Αν είναι γονίδιο πάρτε το primary transcript.

```
[List the start/end positions for all exons]
Chromosome 9
[18128313, 18130780],
[18132132, 18132177],
[18133803, 18133889],
[18138962, 18139037],
[18139664, 18139717],
[18143595, 18143728],
[18147822, 18147915],
[18148987, 18149171],
[18155032, 18155169]
```

Επίσης: "What are the locations of the exons of the gene <Γονίδιο> ?"


8. "Where is the location of the CDS of the <Γονίδιο ή Μετάγραφο> ?". Επίσης GENCODE ή mygene.info ([ίδιο link με πριν](http://mygene.info/v3/query?q=symbol:TPMT&fields=exons&species=human)). Αν είναι <Γονίδιο> πάρτε το primary transcript
```
Chromosome 9
[18149127, 18130667]
```

Επίσης: "Where is the location of the start codon?", "Where is the location of end codon?", "Where is the location of 3' UTR?", "Where is the location of the 5' UTR?"

9. "What is the primary transcript of the gene <Γονίδιο> ?" 
```
Refseq: NM_000367
Ensembl: ENST00000419916
```

10. "In which gene does <Μετάγραφο, Μετάλλαξη ή θέση> belong"? 

<!--
11. "What is the fasta sequence of the transcript NM_001346817 ?"
```python
entrez_request()
```


Επίσης: "What is the fasta sequency of the gene TPMT" (φέρνει το FASTA από το primary transcript)
-->


# Project 7
<!-- https://github.com/kantale/python_lessons/blob/master/2019_2020/assignment_5.ipynb -->

## Μέρος 1
Χρησιμοποιώντας το [Rest API της ENSEMBL](https://rest.ensembl.org/), φτιάξτε μία συνάρτηση η οποία θα παίρνει ένα χρωμόσωμα μία αρχή και ένα τέλος και θα επιστρέφει την ακολουθία του ανθρώπινου γονιδιώματος για αυτή τη περιοχή. 

Hint: https://rest.ensembl.org/documentation/info/sequence_region

## Μέρος 2
Χρησιμοποιώντας το REST API του [myvariant.info](http://docs.myvariant.info/en/latest/), φτιάξτε μία συνάρτηση η οποία θα παιρνει ένα χρωμόσωμα μία αρχή και ένα τέλος και θα επιστρέφει μία λίστα με γνωστές μεταλλάξεις που ανήκουν σε αυτή τη περιοχή. Κάθε μετάλλαξη θα πρέπει να έχει τον κωδικό ```rs<Number>```.

Προσοχή το myvariant.info δεν επιστρέφει όλες τις μεταλλάξεις γιατί ειδικά σε μεγάλες περιοχές αυτή η λίστα μπορεί να έχει τεράστιο μέγεθος. Αντίθετα έχει δύο διαφορετικούς μηχανισμούς ώστε να μπορεί να πάρει κάποιος όλα τα αποτελέσματα.

Ο πρώτος μηχανισμός περιγράφεται εδώ:
http://docs.myvariant.info/en/latest/doc/variant_query_service.html#faceted-queries

Και ο δεύτερος περιγράφεται εδώ:
http://docs.myvariant.info/en/latest/doc/variant_query_service.html#scrolling-queries 

Εσείς μπορείτε να υλοποιήσετε όποιον θέλετε (ή και τους δύο..)

### Μέρος 3
Χρησιμοποιώντας το REST API του myvariant.info, φτιάξτε μία συνάρτηση η οποία θα παίρνει μία μετάλλαξη με τη μορφή ```rs<number>``` και θα επιστρέφει την ασθένεια με την οποία σχετίζεται. 

Για παράδειγμα για το rs374032054 [θα πρέπει να βγάλει](http://myvariant.info/v1/query?q=rs374032054): ```["Congenital disorder of glycosylation type Ir (CDG1R)"]```. Το αποτέλεσμα θα είναι μία λίστα με όλες τις πιθανές ασθένειες (μπορεί να είναι πάνω από μία). Η λίστα μπορεί να είναι και άδεια.


### Μέρος 4
Έστω ότι έχουμε μία ακολουθία DNA. Δίνεται ο παρακάτω κώδικας για τη μετατροπή της ακολουθίας σε φορμάτ fasta


```python
from Bio import SeqIO
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord

def convert_sequence_to_fast(sequence, fasta_filename, id, description):
    sequence = Seq(sequence)
    # http://biopython.org/DIST/docs/tutorial/Tutorial.html#htoc16
    sequence_record = SeqRecord(sequence, id=id, description=description)

    with open(fasta_filename, "w") as output_handle:
        SeqIO.write(sequence_record, output_handle, "fasta")


```


```python
convert_sequence_to_fast('AGAAGACGATGCTGTAGATGAAGAGCCCCA', 'example.fasta', 'mitsos', 'my precious sequence')
```


```python
!cat example.fasta
```

    >mitsos my precious sequence
    AGAAGACGATGCTGTAGATGAAGAGCCCCA


Δίνεται επίσης ο παρακάτω κώδικας ο οποίος διαβάζει μία ακολουθία από ένα αρχείο fasta και τη κάνει [BLAT](https://en.wikipedia.org/wiki/BLAT_(bioinformatics) ) στο ανθρώπινο γονιδιώμα χρησιμοποιώντας την [αντίστοιχη υπηρεσία του NCBI](https://blast.ncbi.nlm.nih.gov/Blast.cgi)


```python
# Running BLAST over the Internet
# http://biopython.org/DIST/docs/tutorial/Tutorial.html#htoc16

from Bio.Blast import NCBIWWW

def blat_fasta(fasta_filename, output_filename):
    fasta_string = open(fasta_filename).read()
    #result_handle = NCBIWWW.qblast("blastn", "nt", fasta_string)
    #result_handle = NCBIWWW.qblast("blastn", "Human G+T", fasta_string)
    print ('fasta string:')
    print (fasta_string)
    result_handle = NCBIWWW.qblast(
        "blastn", 
        #"Human G+T",
        #"GPIPE/9606/current/ref_top_level", # GRCH38
        "GPIPE/9606/105/ref_top_level", #GRCH37
        fasta_string, 
        short_query=True,
        expect=1000,
        nucl_reward=1,
        nucl_penalty=-3,
        filter='F',
    )
    
    # Gia th diafora meta3u 'nt' kai 'Human G+T' deite edw:
    # https://ftp.ncbi.nlm.nih.gov/pub/factsheets/HowTo_BLASTGuide.pdf 
    # Source code of qblast: https://biopython.org/DIST/docs/api/Bio.Blast.Applications-pysrc.html
    with open(output_filename, "w") as out_handle:
        out_handle.write(result_handle.read())

    
```


```python
blat_fasta('example.fasta', 'example_blat_results.xml')
```

    fasta string:
    >mitsos my precious sequence
    AGAAGACGATGCTGTAGATGAAGAGCCCCA
    


Επίσης δίνεται και ο παρακάτω **ενδεικτικός** κώδικας ο οποίος διαβάζει και "παρσάρει" τα αποτελέσματα του BLAT alignment:


```python
# http://biopython.org/DIST/docs/tutorial/Tutorial.html#htoc16
# 7.3  Parsing BLAST output
from Bio.Blast import NCBIWWW
from Bio.Blast import NCBIXML

def parse_BLAT_output(blat_filename):
    result_handle = open(blat_filename)
    blast_records = NCBIXML.parse(result_handle)
    
    E_VALUE_THRESH = 0.04
    for blast_record in blast_records:
        for alignment in blast_record.alignments:
            for hsp in alignment.hsps:
                if hsp.expect < E_VALUE_THRESH:
                    print("****Alignment****")
                    print ('Query start:', hsp.query_start)
                    print ('Query end:', hsp.query_end)
                    print ('Subject start:', hsp.sbjct_start)
                    print ('Subject end:', hsp.sbjct_end)
                    print("sequence:", alignment.title)
                    print("length:", alignment.length)
                    print("e value:", hsp.expect)
                    print(hsp.query)
                    print(hsp.match)
                    print(hsp.sbjct)
                    #print (dir(hsp))
                    return alignment, hsp
        
```


```python
parse_BLAT_output('example_blat_results.xml')
```

    ****Alignment****
    Query start: 1
    Query end: 30
    Subject start: 20978904
    Subject end: 20978933
    sequence: gi|224589800|ref|NC_000001.10| Homo sapiens chromosome 1, GRCh37.p13 Primary Assembly
    length: 249250621
    e value: 8.41803e-06
    AGAAGACGATGCTGTAGATGAAGAGCCCCA
    |||||||||||||| |||||||||||||||
    AGAAGACGATGCTGAAGATGAAGAGCCCCA





    (<Bio.Blast.Record.Alignment at 0x106817810>,
     <Bio.Blast.Record.HSP at 0x103fe5090>)



Προσέχτε ότι:
* Tο hsp.sbjct_start περιέχει τη θέση τη θέση της ακολουθίας όπου έγινε το allignment
* Από τα hsp.query, hsp.match, hsp.sbjct μπορούμε να δούμε που έγινε misalignment
* Το blast_records είναι τόσα όσα οι ακολουθίες του fasta αρχείου (στη περίπτωσή μας 1)
* Το blast_record.alignments περιέχει όλα τα alignments που βρέθηκαν για τη κάθε ακολουθία. Μία ακολουθία μπορεί να έχει γίνει align σε παραπάνω από μία περιοχή του γονιδιώματος
* Το alignment.hsps περιέχει όλες τις διαφορετικές ακολουθίες του κάθε algignment.
* Το hsp.expect είναι ένα metric του πόσο καλά πήγε το alignment, όσο μικρότερο τόσο το καλύτερο..

Χρησιμοποιώντας τα παραπάνω φτιάξτε μία συνάρτηση η οποία θα πάρει ένα DNA sequence και θα επιστρέφει τη θέση στο ανθρώπινο γονιδίωμα με τις οποίες διαφέρει. 

Για να γίνει αυτό θα πρέπει να βρείτε ένα κατάλληλο alignment. Το aligment αυτό θα πρέπει να έχει μικρό hsp.expect και επίσης να έχει στη περιγραφή του το "Primary Assembly".

Πάρτε μόνο το πρώτο blast_record.alignments και από αυτό, πάρτε μόνο το πρώτο alignment.hsps. 

Για να τα υλοποιήσετε θα πρέπει ίσως να χρειαστεί να αλλάξετε τη συνάρτηση parse_BLAT_output. Επίσης η δυνάρτησή σας θα πρέπει να επιτρέφει μία μόνο μετάλλαξη (αν βρει πολλές απλά πάρτε τη πρώτη).

Για παράδειγμα για το sequence 'AGAAGACGATGCTGTAGATGAAGAGCCCCA'. Είδαμε ότι η αρχή το (Α) έγινε allign στη θέση 20652411. Επίσης βλέπουμε ότι στη θέση 15 της ακολουθίας υπάρχει ένα misalignment:



```python
alignment, hsp = parse_BLAT_output('example_blat_results.xml')
```

    ****Alignment****
    Query start: 1
    Query end: 30
    Subject start: 20978904
    Subject end: 20978933
    sequence: gi|224589800|ref|NC_000001.10| Homo sapiens chromosome 1, GRCh37.p13 Primary Assembly
    length: 249250621
    e value: 8.41803e-06
    AGAAGACGATGCTGTAGATGAAGAGCCCCA
    |||||||||||||| |||||||||||||||
    AGAAGACGATGCTGAAGATGAAGAGCCCCA



```python
print (hsp.query)
print (hsp.match)
print (hsp.sbjct)
```

    AGAAGACGATGCTGTAGATGAAGAGCCCCA
    |||||||||||||| |||||||||||||||
    AGAAGACGATGCTGAAGATGAAGAGCCCCA



```python
print (hsp.query[14])
print (hsp.match[14])
print (hsp.sbjct[14])
```

    T
     
    A


H θέση αυτή του misalignment είναι η:


```python
position = hsp.sbjct_start + 14
position
```




    20978918



Και σύμφωνα με το ID της ακολουθίας:


```python
alignment.title
```




    'gi|224589800|ref|NC_000001.10| Homo sapiens chromosome 1, GRCh37.p13 Primary Assembly'



Το χρωμόσωμα είναι το 1 και η έκδοση του γονιδιώματος είναι η 37. Επίσης είδαμε ότι το reference είναι το A και το alternative το T (που έχει η ακολουθία μας)

Άρα θα πρέπει να φτιάξετε μία συνάρτηση η οποία παίρνει ένα sequence και θα πρέπει να επιστρέφει τη μετάλλαξη που περιέχει αυτό το sequence αν το συγκρίνουμε με το γονδίωμα αναφοράς. Για παράδειγμα αν f είναι αυτή η συνάρτηση τότε θα πρέπει:

```python
f('AGAAGACGATGCTGTAGATGAAGAGCCCCA')
```

Αυτό θα πρέπει να επιστρέφει:
```
{
    'chromosome': 1,
    'position': 20978918,
    'reference: 'A',
    'alternative': 'T',
    'assembly': 'GRCh37',
}
```

Αν δεν βρει μετάλλαξη τότε θα επιστρέφει None.

## Μέρος 5
(συνέχεια από το προηγούμενο μέρος)

Άραγε αυτή η μετάλλαξη που βρήκαμε στο 4ο μέρος, είναι γνωστή, και αν είναι σχετίζεται με κάποια ασθένεια; Ας ψάξουμε αν το myvariant.info έχει πληροφορία από τη clinvar:


```python
import requests

r = requests.get("http://myvariant.info/v1/variant/chr1:g.20978918A>T", headers={ "Content-Type" : "application/json"})
```


```python
data = r.json()
'clinvar' in data
```




    True



Παρατηρούμε ότι όντως έχει πληροφορία!


```python
data['clinvar']
```




    {'_license': 'http://bit.ly/2SQdcI0',
     'allele_id': 576081,
     'alt': 'T',
     'chrom': '1',
     'cytogenic': '1p36.12',
     'gene': {'id': '1650', 'symbol': 'DDOST'},
     'hg19': {'end': 20978918, 'start': 20978918},
     'hg38': {'end': 20652425, 'start': 20652425},
     'hgvs': {'coding': 'NM_005216.4:c.1325T>A',
      'genomic': ['NC_000001.10:g.20978918A>T',
       'NC_000001.11:g.20652425A>T',
       'NG_008164.1:g.23971A>T',
       'NG_032064.1:g.14120T>A']},
     'rcv': {'accession': 'RCV000709770',
      'clinical_significance': 'not provided',
      'conditions': {'identifiers': {'medgen': 'C3281084',
        'omim': '614507',
        'orphanet': '300536'},
       'name': 'Congenital disorder of glycosylation type Ir (CDG1R)'},
      'number_submitters': 1,
      'origin': 'unknown',
      'preferred_name': 'NM_005216.4(DDOST):c.1325T>A (p.Phe442Tyr)',
      'review_status': 'no assertion provided'},
     'ref': 'A',
     'type': 'single nucleotide variant',
     'variant_id': 585026}



Με ποιες παθήσεις έχει συνδεθεί αυτή η μετάλλαξη;


```python
data['clinvar']['rcv']['conditions']['name']
```




    'Congenital disorder of glycosylation type Ir (CDG1R)'



Άρα βρήκαμε ότι αν ένας άνθρωπος έχει το sequence: ```AGAAGACGATGCTGTAGATGAAGAGCCCCA```, τότε μπορεί να έχει το condition: ```'Congenital disorder of glycosylation type Ir (CDG1R)'```

Εσείς θα πρέπει να φτιάξετε μία συνάρτηση η οποία θα παίρνει ως είσοδο ένα DNA sequence. Στη συνέχεια θα χρησιμοποιεί τη συνάρτηση του μέρους 4 για να βρει (αν υπάρχει) τη μετάλλαξη που περιέχει το sequence. Στη συνέχεια θα ψάχνει τη myvariant.info για να βρει (αν υπάρχει) τις ασθένειες με τις οποίες έχει συνδεθεί, σύμφωνα με τη clinvar. Αν f είναι αυτή η συνάρτηση, τότε Θα πρέπει να μπορώ να γράφω:

```python
f('AGAAGACGATGCTGTAGATGAAGAGCCCCA')
```

Αυτό θα πρέπει να επιστρέφει
```
['Congenital disorder of glycosylation type Ir (CDG1R)']
```

Παρατηρήστε ότι επιτρέφει λίστα. Δηλαδή μπορεί να υπάρχουν περισσότερες από μία ασθένειες. Εννοείται ότι μπορείτε να χρησιμοποιήσετε τη συνάρτηση του 3ου μέρους.


Σε αυτό το project θα πρέπει να φτιάξετε ένα πρόγραμμα το οποίο θα παίρνει μία παράμετρο:
* --seq ΑΚΟΛΟΥΘΙΑ_DNA 

το πρόγραμμα θα τυπώνει μία αναφορά με:
* Σε ποιες περιοχές του γονιδιώματος έγινε allign αυτή η ακολουθία και με ποια ποιότητα (hsp).
* Ποιες μεταλλάξεις βρέθηκαν σε αυτή την ακολουθία
* Τι ασθένειες έχουν βρεθεί να έχουν συσχετιστεί με αυτές τις μεταλλάξεις. 

Δεν υπάρχει κάποιο συγκεκριμένο φορμάτ για την αναφορά. Ένα απλό αρχείο κειμένου αρκεί. 

# Project 8
<!-- https://github.com/kantale/python_lessons/blob/master/assignment_5.ipynb -->

Μία πόλη έχει P=10.000 κατοίκους.
Κάθε κάτοικος ζει σε ένα σπίτι μόνος του.
H πόλη δυστυχώς χτυπάται ανελέητα από τον κοροναϊό!
Η διάδοση του ιού έχει τα εξής χαρακτηριστικά:

Κάθε μέρα τυχαίοι N κάτοικοι πάνε να επισκεφτούν άλλα σπίτια. Αν είναι μολυσμένοι οι επισκέπτες και δεν είναι μολυσμένοι οι.. οικοδεσπότες τότε μολύνουν τα άλλα σπίτια.. (και το ανάποδο αν οι επισκέπτες ΔΕΝ είναι μολυσμένοι αλλά είναι μολυσμένοι οι οικοδεσπότες, τότε μολύνονται οι επισκέπτες). Αν ένα σπίτι μολυνθεί από ιό τη μέρα D, τότε από τη μέρα D+3 μέχρι και τη μέρα D+14 μπορεί να μεταδόσει τον ιό. από τη μέρα D+15 και μετά δεν μπορεί να μεταδόσει αλλά ούτε και να προσβληθεί από τον ιό (έχει αποκτήσει ανοσία). 

Αρχικά η πόλη έχει I=100 κρούσματα σε τυχαία σπίτια. To πρόγραμμά σας θα πρέπει να έχει μία συνάρτηση η οποία θα υπολογίζει το μέγιστο πλήθος από αρρώστους που θα έχει η πόλη μέχρι κανένας να μην μπορεί πλέον να μεταδόσει τον ιό (herd immunity); Ας ονομάσουμε αυτή τη τιμή Μ. 

Σε αυτό το project θα πρέπει να φτιάξετε ένα πρόγραμμα σε python το οποία να δέχεται τις εξής παραμέτρους:
* P : πλήθος από κατοίκους. Αν δεν δοθεί αυτή η παράμετρος τότε θεωρούμε ότι P=10.000
* I : πλήθος από αρχικά κρούσματα. Αν δεν δοθεί αυτή η παράμετρος τότε θεωρούμε ότι Ι=100
* Ν : πλήθος από άτομα που "σπάνε" τη καταντίνα κάθε μέρα (ας τους ονομάσουμε cheaters!) Αν ο χρήστης δεν δόσει τιμή τότε το πρόγραμμά σας θα πρέπει να "πετάει" ένα μήνυμα λάθους και να τερματίζει. 
* D1 : μέρες κατά τις οποίες αν προσβληθεί κάποιος δεν μπορεί να μεταδόσει τον ιό (χρόνος επώασης). Αν δεν δοθεί αυτή η παράμετρος τότε θεωρούμε ότι D1=3
* D2 : μέρες μετά από τη προσβολή με τον ιό, που δεν μπορεί κάποιος να θεωρείτε μολυσματικός. Αν δεν δοθεί αυτή η παράμετρος τότε θεωρούμε D2=14

Το πρόγραμμά σας θα πρέπει επίσης να δέχεται **μόνο μία** από τις παρακάτω παραμετρους:
* --plot_population A B Γ : εμφανίζει ένα plot όπου στον άξονα X είναι οι τιμές του πληθυσμού (παράμετρος P) από Α μέχρι Β με Γ βήματα (δηλαδή np.linspace(Α,Β,Γ)). Στο άξονα Y είναι οι αντίστοιχες τιμές του Μ.
* --plot_initial Α Β Γ  : εμφανίζει ένα plot όπου στον άξονα X είναι οι τιμές των αρχικών κρουσμάτων (παράμετρος I) από Α μέχρι Β με Γ βήματα (δηλαδή np.linspace(Α,Β,Γ)). Στο άξονα Y είναι οι αντίστοιχες τιμές του Μ.
* --plot_cheaters Α Β Γ : εμφανίζει ένα plot όπου στον άξονα X είναι οι τιμές των ατόμων που σπάνε τη καραντίνα (cheaters) (παράμετρος N) από Α μέχρι Β με Γ βήματα (δηλαδή np.linspace(Α,Β,Γ)). Στο άξονα Y είναι οι αντίστοιχες τιμές του Μ.
* --compute_cheaters Μ: Επιστρέφει τη τιμή του N, το οποίο είναι το μέγιστο πλήθος από cheaters που μπορεί να υπάρχουν αν θέλουμε το M να μην ξεπεράσει αυτή τη τιμή. Για παράδειγμα:

```bash
python program.py --compute_cheaters 1500
# επιστρέφει και τυπώνει ποιο είναι το μέγιστο πλήθος από cheaters που μπορούν να υπάρχουν αν δεν θέλουμε το μέγιστο πλήθος από κρούσματα να ξεπεράσει το 1500, με τις default τιμές των υπόλοιπων παραμέτρων. 

python program.py Ν 100000 --compute_cheaters 1500
# επιστρέφει και τυπώνει ποιο είναι το μέγιστο πλήθος από cheaters που μπορούν να υπάρχουν αν δεν θέλουμε το μέγιστο πλήθος από κρούσματα να ξεπεράσει το 1500, σε μια πόλη από 100.0000 κατοίκους και τις υπόλοιπες τιμές (I, N, D1 και D2) ίσες με τις default τιμές τους. 
```

# Project 9
<!-- https://github.com/kantale/python_lessons/blob/master/assignment_5.ipynb -->


Όπως γνωρίζουμε από τη βιολογία στο τέλος κάθε μετάγραφου υπάρχει η περιοχή 3'UTR. Σύμφωνα με τη wikipedia: https://en.wikipedia.org/wiki/Three_prime_untranslated_region 

> The length of the 3′-UTR is significant since longer 3′-UTRs are associated with lower levels of gene expression. 

Δηλαδή όσο πιο μεγάλη αυτή η περιοχή τόσο μεγαλύτερη η έκφραση του μετάγραφου. Νομίζω ότι μπορούμε να ερευνήσουμε λίγο αυτή τη διαπίστωση..

Καταρχή μπορούμε να πάμε στο [Expression Atlas](https://www.ebi.ac.uk/gxa/experiments/E-MTAB-5214/Downloads) και να κατεβάσουμε τα δεδομένα από [αυτό το paper](https://europepmc.org/article/MED/25954001). Σε αυτό το πείραμα οι συγγραφείς μελέτησαν την έκφραση σχεδόν όλων των γονιδίων σε 53 διαφορετικούς ιστούς. Μπορείτε να κατεβάσετε το αρχείο [Expression values across all genes (TPM)](https://www.ebi.ac.uk/gxa/experiments-content/E-MTAB-5214/resources/ExperimentDownloadSupplier.RnaSeqBaseline/tpms.tsv) και να το μελετήσετε.. Θα δείτε ότι η πρώτη στήλη είναι το ENSEMBL code για το γονίδιο, η 2η στήλη έχει το όνομα του γονιδίου και οι υπόλοιπες στήλες έχουν την έκφραση του γονιδίου σε διάφορους ιστούς (δεν μας ενδιαφέρει εδώ πως το μετρήσανε ή τι δείχνουν αυτές οι ποσότητες). 

Τώρα αυτό που χρειάζεται να βρούμε είναι το μήκος της περιοχής 3'UTR για όλα αυτά τα γονίδια. Μπορούμε να πάμε στη GENCODE: https://www.gencodegenes.org/human/  και να κατεβάσουμε το αρχείο GFF3 Comprehensive gene annotation (this is the main annotation file for most users): ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_36/gencode.v36.annotation.gff3.gz . Μέσα σε αυτό το αρχείο υπάρχουν πληροφορίες για όλα τα γονίδια / μετάγραφα / εξόνια / 5'UTR / 3'UTR του ανθρώπινου γονιδιώματος. 

Η δομή του αρχείου εξηγείται [εδώ](https://www.gencodegenes.org/pages/data_format.html) (παρόλο που αναφέρεται στο GTF format, το φορμάτ GFF3 είναι παρόμοιο), και [εδώ](https://www.gencodegenes.org/pages/faq.html)

Στο αρχείο αυτό υπάρχει για παράδειγμα η εγγραφή:
```
chrX  HAVANA  three_prime_UTR 100627108 100629986 . - . ID=UTR3:ENST00000373020.9;Parent=ENST00000373020.9;gene_id=ENSG00000000003.15;transcript_id=ENST00000373020.9;gene_type=protein_coding;gene_name=TSPAN6;transcript_type=protein_coding;transcript_name=TSPAN6-201;exon_number=8;exon_id=ENSE00001459322.5;level=2;protein_id=ENSP00000362111.4;transcript_support_level=1;hgnc_id=HGNC:11858;tag=basic,MANE_Select,appris_principal_1,CCDS;ccdsid=CCDS14470.1;havana_gene=OTTHUMG00000022002.2;havana_transcript=OTTHUMT00000057483.2
```

Το οποίο σημαίνει ότι το γονίδο με κωδικό gene_id=ENSG00000000003.15, έχει ένα μετάγραφο (transcript) με κωδικό transcript_id=ENST00000373020.9 το οποίο έχει ένα 3'UTR (three_prime_UTR) το οποίο ξεκινάει από τη θέση 100627108 και τελειώνει στη θέση 100629986. 


Άρα ξέρουμε ότι το γονίδιο ENSG00000000003 (είναι το πρώτο γονίδιο που αναφέρεται στο Expression Atlas) έχει ένα 3'UTR μς μέγεθος 100629986-100627108=2878. 

Εδώ όμως υπάρχει ένα πρόβλημα:
* Ένα γονίδιο (μπορεί να) έχει πολλά μετάγραφα
* Ένα μετάγραφο (μπορεί να) έχει πολλά 3'UTR

Για το 2ο πρόβλημα η απάντηση είναι εύκολη. Παίρνουμα απλά το "τελευταίο" 3'UTR (το οποίο είναι και συνήθως το μεγαλύτερο). 

Για το 1ο η απάντηση είναι πιο πολύπλοκη. Όπως παρατηρούμε στα πεδία της εγγραφής του ENSG00000000003 στο GFF3 αρχείο, βλέπουμε διάφορα πεδία. Μερικά από αυτά είναι:
* tag=basic,MANE_Select,appris_principal_1,CCDS
* transcript_support_level=1 
* level=2 

Εσείς θα πρέπει να ιεραρχήσετε τα μετάγραφα με βάση αυτή τη πληροφορία! Ο αλγόριθμος που θα χρησιμοποιήσουμε είναι ο εξής:
* Πάρε αυτό που έχει tag MANE_Select
* Αν υπάρχουν παραπάνω από 1 μετάγραφα με MANE_Select, ή κανένα:
   * Πάρε αυτό που έχει tag appris_principal_1 
   * Αν υπάρχουν παραπάνω 1 μετάγραφα με tag appris_principal_1 ή κανένα:
      * Πάρε αυτό που έχει tag basic 
      * Αν υπάρχουν παραπάνω από 1 μετάγραφα με tag basic, ή κανένα:
         * Πάρε αυτό που έχει tag CCDS.
         * Αν υπάρχουν παραπάνω από 1 μετάγραφα με tag CCDS ή κανένα: 
            * Πάρε αυτό που έχει το μεγαλύτερο transcript_support_level 
            * Αν υπάρχουν παραπάνω από 1 με το ίδιο (μεγαλύτερο) transcript_support_level ή κανένα:
               * Πάρε αυτό με το μεγαλύτερο level
               * Αν υπάρχει παραπάνω από 1 με το ίδιο (μεγαλύτερο) level ή κανένα:
                  * Αγνόησε αυτό το transcript, αφού τυπώσεις ένα μήνυμα!
                     
Και αφού αυτή η εκφώνηση με βοήθησε να φτάσω τα markdown bullets του Jupyter στα άκρα μπορούμε να συνεχίσουμε. 

Φτιάξτε ένα πρόγραμμα το οποίο θα παίρνει μία μόνο προαιρετική παράμετρο:
* ```--tissues```: λίστα με ονόματα ιστών που υπάρχουν στο Expression Atlas. Η λίστα πρέπει να είναι διαχωρίσμένη με κενά (space separated)

Το πρόγραμμά σας λοιπόν θα πρέπει για κάθε γονίδιο που υπάρχει στο Expression Atlas να υπολογίζει τον μέσο όρο της έκφρασής του για όλους τους ιστούς της παραμέτρους ```--tissues```. Αν δεν υπάρχει καθόλου η παράμετρος αυτή τότε θα παίρνει όλους τους ιστούς. Στη συνέχεια θα βρίσκει το μέγεθος του 3'UTR του κάθε γονιδίου από το GENCODE με βάση τη μέθοδο που περιγράψαμε πριν. Το πρόγραμμα θα φτιάχνει και θα σώζει σε ένα αρχείο ένα scatter plot για όλα τα γονίδια όπου X=μήκος 3'UTR του γονιδίου και Y=μέσος όρος της έκφρασης. 

Προαιρετικά:
* Ποιοι ιστοί φαίνονται να εξαρτώνται περισσότερο από το μέγεθος του 3'UTR και ποιοι το λιγότερο;

# Project 10
<!-- https://github.com/kantale/python_lessons/blob/master/assignment_5.ipynb --> 

## Μέρος 1

Αυτό το αρχείο:
https://www.dropbox.com/s/brqaopz8g2vs0ox/covid_fasta.gz?dl=1

Περιέχει 8,728 ακολουθίες του ιού COVID. Οι ακολουθίες είναι όσες:
* Είναι complete (δεν έχουν missing nucleotides)
* Έχουν μεγάλο coverage
* Έχουν συλλεχθεί μετά τις 1 Ιουνίου 2020

Αφού κατεβάσετε το αρχείο μπορείτε να το ανοίξετε με:


```python
import gzip

with gzip.open('../Downloads/covid_fasta.gz', 'rt') as f:
    first_line = f.readline()
    second_line = f.readline()
    print (first_line)
    print (second_line)

```

    >hCoV-19/Italy/FVG-ICGEB-S208/2020|EPI_ISL_498558|2020-07
    
    ATTAAAGGTTTATACTTTCCCAGGTAACAAACCAACCAACTTTCGATCTCTTGTAGATCTGTTCTCTAAACGAACTTTAA
    


Το αρχείο είναι σε φορμά fasta. Δηλαδή έχει μία επικεφαλίδα και μετά ακολουθούν πολλές γραμμές με την ακολουθία, όπου κάθε γραμμή έχει 80 βάσεις. 


Βρείτε μία τυχαία ακολουθία από το αρχείο που κατεβάσατε και κάνετε ένα plot με το [ποσοστό των GC νουκλεοτιδίων](https://en.wikipedia.org/wiki/GC-content) που έχει. Για να το κάνουμε αυτό χρησιμοποιούμε ένα "παράθυρο" συγκεκριμένου μήκους στο οποίο μετράμε τον λόγο:

$GC=\cfrac{G+C}{A+T+G+C}$

* Θέτουμε σαν μέγεθος παραθύρου το 500 και σαν βήμα το 30
* Στην αρχή πάρτε το τμήμα της ακολουθία από 1 μέχρι 500 της ακολουθίας που επιλέξατε. Υπολογίστε το λόγο GC και αποθηκεύστε τον.
* Μεταφέρετε το παράθυρο κατα 30 νουκλεοτίδια δεξιά. Οπότε η θέση του έγινε από 31 μέχρι 530. Πάλι υπολογίστε τον λόγο  GC και αποθηκεύστε τον
* Όταν το τέλος του παραθύρου ξεπεράσει τον μήκος της ακολουθία σταματήστε.
* Κάντε ένα πλοτ: βάλτε στο Χ άξονα την αρχή του παραθύρου που έγινε η μέτρηση και στον Υ η μέτρηση του GC που κάνατε.

## Μέρος 2

Ο υπολογισμός του ποσοστού GC είναι ενδιαφέρον, αλλά το τελευταίο διάστημα έχουν εμφανιστεί και άλλες μετρικές! Μία από αυτές είναι το [Mutual Information](https://en.wikipedia.org/wiki/Mutual_information). Συγκεκριμμένα θα εφαρμόσουμε τη μετρική που έχει παρουσιαστεί σε [αυτό το paper](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2335307/)

Οπότε:
* πάρτε πάλι μία τυχαία ακολουθία από το αγαπημένο μας αρχείο.
* Θέστε σαν μέγεθος παραθύρου k=5
* Έστω Ν<sub>k</sub>(C,G) είναι το πλήθος των φορών που συναντάμε το C και το G σε απόσταση k μέσα στην ακολουθία. Δηλαδή κοιτάμε τη 1η και τη 6η βάση, μετά τη 2η και την 7η, μετά τη 3η και την 8η κτλ.. Αθροίζουμε λοιπόν πόσες φορές τα C και G βρέθηκαν σε απόσταση k.
* Τώρα μετράμε τα Ν<sub>k</sub>(Χ,Υ) όπου Χ είναι όλες οι τιμές A,C,G,T και Υ πάλι όλες οι τιμές A,C,G,T. Συνολικά δηλαδή θά πάρουμε 4\*4=16 μετρήσεις.
* Αθροιζουμε όλες αυτές τις 16 μετρήσεις και παίρνουμε μία τιμή. Ας την ονομάζουμε S<sub>k</sub>.
* Στη συνέχεια υπολογίζουμε το P<sub>k</sub>(Χ,Υ) το οποίο ορίζεται ως: Ν<sub>k</sub>(Χ,Υ) / S<sub>k</sub>.
* Στη συνέχεια υπολογίζουμε το P(X) το οποίο είναι απλά ο λόγος των εμφανίσεων της βάσης Χ μέσα στην ακολουθία, όπου Χ=A,C,G,T. Δηλαδή αν η ακολουθία είναι AACGTT, τότε P(C)=1/6, P(A)=2/6.
* Στη συνέχεια υπολογίζουμε το Ι<sub>k</sub> σύμφωνα με τον παρακάτω τύπο:

$I_{k}=\sum_{X=\{A,C,G,T\}}^{}\sum_{Y=\{A,C,G,T\}}^{}p_{k}(X,Y)*\log\left ( \frac{p_{k}(X,Y)}{p(X)*p(Y)} \right ) $


* Υπολογίζουμε τώρα το Ι<sub>k</sub> για όλες τις τιμές του k από το 5 μέχρι και το 454 (σύνολο 450 διαφορετικές μετρήσεις).
* Φτιάχνουμε ένα plot όπου X είναι οι τιμές του k και Y είναι οι αντίστοιχες τιμές του Ι<sub>k</sub>.

## Μέρος 3

Από το μέρος 2, για κάθε ακολουθία μπορούμε να φτιάξουμε έναν πίνακα από περίπου \~25.000 τιμές. Για παράδειγμα αν μία ακολουθία αποτελείται από 30.000 βάσεις και το μέγεθος του παραθύρου είναι 500 με βήμα 30, τότε θα έχουμε (30.000-500)/30 = 983 μετρήσεις. 

Κάντε τις ανάλογες αλλαγές (ό,τι θέλετε: αλλαγή του μέγεθους του παραθύρου ή του βήματος, ή και τα δύο), ώστε το αποτέλεσμα να βγαίνει πάντα 900 μετρήσεις **Για οποιαδήποτε ακολουθία του αρχείου**

Στη συνέχεια υπολογίστε
* τις τιμές της μετρικής της άσκηση 13 (με τη διόρθωση που μόλις παρουσίασαμε) για όλες τις ακολουθίες
* τις τιμές της μετρικής της άσκησης 14 για όλες τις ακολουθίες. 
* Αν αργεί πολύ αυτή η διαδικασία απλά επιλέξτε 1000 (ή.. λιγότερες) τυχαίες ακολουθίες.

Στο τέλος πρέπει να έχετε έναν πίνακα:
* Α = 8728 Χ 900, από τις μετρήσεις της 1ης μετρικής (άσκηση 13+διόρθωση)
* Β = 8728 Χ 450, από τις μετρήσεις της 2ης μετρικής (άσκηση 14) 

### Μέρος 4

Όταν έχουμε πολυδιάστατα δεδομένα, ένας ωραίος τρόπος για να τα οπτικοποιήσουμε στις 2 διαστάσεις είναι το PCA. Ας δούμε λίγο πως δουλεύει..

Για αρχή φτιάχνουμε έναν τυχαίο πίνακα 100\*1000


```python
import numpy as np
a = np.random.random((100, 1000))
```

Φτιάχνουμε τώρα και έναν 2ο και.. του προσθέτουμε μία μικρή παραμόρφωση ώστε να τον διαφοροποιήσουμε από τον πρώτο:


```python
b = np.random.random((100, 1000)) + 0.04
```

Ας ενώσουμε τους δύο πίνακες σε έναν:


```python
c = np.vstack((a,b))
c.shape
```




    (200, 1000)



Στη συνέχεια εφαρμόζουμε PCA στον c, για 2 διαστάσεις:


```python
from sklearn.decomposition import PCA

pca = PCA(n_components=2)
pca.fit(c)
# Κάνουμε προβολή στις 2 διαστάσεις που υπολόγισε το pca.fit:
c_PCA = pca.transform(c)
c_PCA.shape
```




    (200, 2)



Βλέπουμε τώρα από τις 1000 διαστάσεις πήγαμε στις 2! Άρα μπορούμε να "πλοτάρουμε" στις 2 διαστάσεις:



```python
fig, ax = plt.subplots()

ax.plot(c_PCA[:100,0], c_PCA[:100,1], 'r.') # Τα 100 του a είναι κόκκινες κουκίδες
ax.plot(c_PCA[100:,0], c_PCA[100:,1], 'b.') # Τα 100 του b είναι μπλε κουκίδες

```




    [<matplotlib.lines.Line2D at 0x1a2dac3860>]




    
![png](output_79_1.png)
    


Βλέπουμε δηλαδή ότι παρόλη τη μικρή παραμόρφωση που βάλαμε, το PCA μπόρεσε να δείξει τις διαφορές των a και b σε έναν ικανοποιητικό βαθμό.

Σε αυτή την άσκηση θα πρέπει να εφαρμόσετε PCA στις δύο διαστάσεις στους πίνακες Α και Β που φτιάξατε στην άσκηση 15. Θα πρέπει δηλαδή να φτιάξετε 2 plots. 

**Προαιρετικό:** 
* Χρωματίστε τις ακολουθίες ανάλογα με τις ηπείρους από όπου προέρχονται τα δείγματα. 
* Χρωματίστε τις ακολουθίες ανάλογα με τις χώρες που προέρχονται, βάλτε τις 10 μεγαλύτερες σε πληθυσμό χώρες του κόσμου μόνο.
* Βάλτε μόνο τις ευρωπαϊκές χώρες και χρωματίστες τις ακολουθίες ανάλογα με τη χώρα από όπου προέρχονται


### Μέρος 5

Τώρα φτάσαμε στο σημείο να μπορέσουμε να συγκρίνουμε δύο διαφορετικές ακολουθίες του ιού. Οι κλασσσικές μέθοδοι δυστυχώς είναι πολύ αργές για τόσο πολλές ακολουθίες (π.χ. pairwise aligment). Για αυτό θα κάνουμε τη δική μας μετρική. Για μία ακολουθία μετράμε το πλήθος όλως των διαδορετικών κωδικόνιων. Για παράδειγμα το πλήθος όλων των διαφορετικών κωδικόνιων είναι  τη 1η ακολουθία είναι:

```python
Counter({'TTT': 385, 'TGT': 368, 'TAA': 343, 'TGA': 305, 'AAA': 304, 'TAT': 278, 'AGA': 277, 'TGC': 268, 'TGG': 261, 'AAT': 260, 'ACA': 249, 'GTT': 234, 'TTA': 233, 'CAA': 232, 'TAC': 227, 'ACT': 220, 'AAC': 212, 'TTC': 210, 'ATT': 207, 'CTT': 207, 'AGT': 197, 'TCT': 190, 'GAA': 184, 'TTG': 179, 'TCA': 173, 'CAT': 172, 'GCT': 169, 'GAT': 167, 'CAC': 160, 'ACC': 150, 'GGT': 149, 'AGC': 141, 'TAG': 128, 'AGG': 123, 'GAC': 123, 'GTA': 121, 'ATG': 117, 'GCA': 116, 'ATA': 116, 'CCA': 115, 'ATC': 112, 'GGA': 111, 'AAG': 110, 'CTA': 109, 'CCT': 106, 'GTC': 101, 'GTG': 93, 'CAG': 92, 'GAG': 85, 'GGC': 84, 'CTC': 79, 'CTG': 79, 'TCC': 75, 'GCC': 68, 'ACG': 60, 'CGT': 53, 'GGG': 50, 'CCC': 42, 'CGC': 40, 'TCG': 34, 'CGG': 33, 'CGA': 31, 'CCG': 28, 'GCG': 22})

```

και για τη 2η:

```python
Counter({'TTT': 383, 'TGT': 368, 'TAA': 343, 'TGA': 304, 'AAA': 303, 'TAT': 278, 'AGA': 277, 'TGC': 268, 'TGG': 262, 'AAT': 260, 'ACA': 248, 'TTA': 235, 'CAA': 233, 'GTT': 233, 'TAC': 227, 'ACT': 219, 'AAC': 212, 'ATT': 210, 'TTC': 210, 'CTT': 209, 'AGT': 198, 'TCT': 191, 'GAA': 186, 'TTG': 178, 'CAT': 172, 'TCA': 170, 'GCT': 168, 'GAT': 167, 'CAC': 160, 'ACC': 150, 'GGT': 149, 'AGC': 140, 'TAG': 128, 'AGG': 123, 'GAC': 122, 'GTA': 120, 'ATA': 117, 'CCA': 117, 'GCA': 116, 'ATG': 116, 'ATC': 112, 'GGA': 111, 'AAG': 110, 'CTA': 109, 'CCT': 106, 'GTC': 101, 'GTG': 93, 'CAG': 92, 'GGC': 85, 'GAG': 84, 'CTG': 80, 'CTC': 78, 'TCC': 75, 'GCC': 68, 'ACG': 60, 'CGT': 53, 'GGG': 49, 'CCC': 42, 'CGC': 40, 'TCG': 34, 'CGG': 33, 'CGA': 31, 'CCG': 28, 'GCG': 23})
```

Παρατηρούμε ότι δεν διαφέρουν και πάρα πολύ! Πράγματικά μπορούμε να φτιάξουμε δύο πίνακες 1X64 (64 = 4\*4\*4) με τις διαφορετικές τιμές μεταξύ της 1ης και της 2ης ακολουθίας:



```python
a = np.array([304, 212, 110, 260, 249, 150,  60, 220, 277, 141, 123, 197, 116,
        112, 117, 207, 232, 160,  92, 172, 115,  42,  28, 106,  31,  40,
         33,  53, 109,  79,  79, 207, 184, 123,  85, 167, 116,  68,  22,
        169, 111,  84,  50, 149, 121, 101,  93, 234, 343, 227, 128, 278,
        173,  75,  34, 190, 305, 268, 261, 368, 233, 210, 179, 385])
b = np.array([303, 212, 110, 260, 248, 150,  60, 219, 277, 140, 123, 198, 117,
        112, 116, 210, 233, 160,  92, 172, 117,  42,  28, 106,  31,  40,
         33,  53, 109,  78,  80, 209, 186, 122,  84, 167, 116,  68,  23,
        168, 111,  85,  49, 149, 120, 101,  93, 233, 343, 227, 128, 278,
        170,  75,  34, 191, 304, 268, 262, 368, 235, 210, 178, 383])
```

Στη συνέχρια μπορούμε να υπολογίσουμε τη chi-square distance (κατάλληλη για διαφορές σε επίπεδο ιστογράμματος μεταξύ δύο δειγμάτων). Για αυτόν τον υπολογισμό μπορούμε να χρησιμοποιήσουμε είτε τη scipy:


```python
from scipy.stats import chi2_contingency

chi2, p, dof, ex = chi2_contingency(np.array([a,b]))
chi2

```




    0.20114259183383668



Είτε το κώδικα που μπορούμε να βρούμε.. στα Internets!


```python
# Function to calculate Chi-distace 
# Source: https://www.geeksforgeeks.org/chi-square-distance-in-python/
def chi2_distance(A, B): 
  
    # compute the chi-squared distance using above formula 
    chi =  np.sum([((a - b) ** 2) / (a + b)  
                      for (a, b) in zip(A, B)])
    
    return chi


chi2_distance(a,b)

```




    0.20114259183383668



Οπότε τώρα έχουμε μία (σχετικά..) γρήγορη μέθοδο για να συγκρίνουμε ακολουθίες. Το επόμενο στάδιο είναι να.. πετάξουμε έξω όσες ακουλουθίες "μοιάζουν" μέσα στο αρχείο. Για να το κάνουμε αυτό τρέχουμε τον εξής αλγόριθμο.

* Συγκρίνουμε τη 1η με τη 2η. Αν το ch-square distance είναι μικρότερο από 1 τότε πετάμε τη 1η ακολουθία και ξεκινάμε από την αρχή.
* Αν δεν είναι ίδιο συγκρίνουμε τη 1η με τη 3η, αν το distance είναι μικρότερο από 1.0 πετάμε τη 1η και ξεκινάμε από την αρχή, αλλιώς συγκρίνουμε τη 1η με τη 4η κτλ..
* Συνεχίζουμε συγκρίνοντας τη 2η με τη 3η, 2η με 4η, ...
* Συνεχίζουμε αυτή τη διαδικασία μέχρι να μην υπάρχει ζευγάρι από ακολουθίες με distance < 1.0

Αυτή η διαδικασία δεν πρέπει να παίρνει παραπάνω από 15 λεπτά υπολογισμών (η δική μου υλοποίηση έκανε 5 λεπτά). Μόλις τελειώσει θα έχουν μείνει 14 ακολουθίες (από τις 8728!) που διαφέρουν τελείως μεταξύ τους. Δηλαδή θα έχετε ανακαλύψει τα 14 βασικά strains του ιού. Ποιες είναι αυτές οι ακολουθίες (τυπώστε τις επικεφαλίδες τους);

## Μέρος 6
Φτιάξτε ένα δενδρόγραμμα με τις 14 ακολουθίες που βρήκατε από το μέρος 5. Χρησιμοποιήστε τη μεθοδολογία που έχουμε δείξει στις σημειώσεις για να φτιάξετε το δενδρόγραμμα. Ως μετρική για την απόσταση χρησιμοποιήστε το chi square distance. Αν θέλετε μπορείτε να χρησιμοποιήσετε όποια άλλη μετρική απόστασης θέλετε!


Σε αυτό το project θα πρέπει να φτιάξετε ένα πρόγραμμα το οποίο θα παίρνει τις εξής παραμέτρους. 
* ```--file PATH ``` όνομα αρχείου και διαδρομή (path) του αρχείου, το οποίο περιέχει τις ακολουθίες. (υποχρεωτική παράμετρο)
* ```--pca_plot FILENAME``` όνομα του αρχείου στο οποίο θα σώσει το PCA_plot  (προαιρετική παράμετρος)
* ```--dendrogram_plot FILENAME``` όνομα του αρχείου στο οποίο θα σώσει το dedrogram plot (προαιρετική παράμετρος)








