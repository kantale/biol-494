
# Project 10
<!-- https://github.com/kantale/python_lessons/blob/master/assignment_5.ipynb --> 

## Μέρος 1

Αυτό το αρχείο:
https://www.dropbox.com/s/brqaopz8g2vs0ox/covid_fasta.gz?dl=1

Περιέχει 8,728 ακολουθίες του ιού COVID. Οι ακολουθίες είναι όσες:
* Είναι complete (δεν έχουν missing nucleotides)
* Έχουν μεγάλο coverage
* Έχουν συλλεχθεί μετά τις 1 Ιουνίου 2020

Αφού κατεβάσετε το αρχείο μπορείτε να το ανοίξετε με:


```python
import gzip

with gzip.open('../Downloads/covid_fasta.gz', 'rt') as f:
    first_line = f.readline()
    second_line = f.readline()
    print (first_line)
    print (second_line)

```

    >hCoV-19/Italy/FVG-ICGEB-S208/2020|EPI_ISL_498558|2020-07
    
    ATTAAAGGTTTATACTTTCCCAGGTAACAAACCAACCAACTTTCGATCTCTTGTAGATCTGTTCTCTAAACGAACTTTAA
    


Το αρχείο είναι σε φορμά fasta. Δηλαδή έχει μία επικεφαλίδα και μετά ακολουθούν πολλές γραμμές με την ακολουθία, όπου κάθε γραμμή έχει 80 βάσεις. 


Βρείτε μία τυχαία ακολουθία από το αρχείο που κατεβάσατε και κάνετε ένα plot με το [ποσοστό των GC νουκλεοτιδίων](https://en.wikipedia.org/wiki/GC-content) που έχει. Για να το κάνουμε αυτό χρησιμοποιούμε ένα "παράθυρο" συγκεκριμένου μήκους στο οποίο μετράμε τον λόγο:


<!-- $GC=\cfrac{G+C}{A+T+G+C}$ -->

![img](https://i.imgur.com/OBcWQ7v.png)

* Θέτουμε σαν μέγεθος παραθύρου το 500 και σαν βήμα το 30
* Στην αρχή πάρτε το τμήμα της ακολουθία από 1 μέχρι 500 της ακολουθίας που επιλέξατε. Υπολογίστε το λόγο GC και αποθηκεύστε τον.
* Μεταφέρετε το παράθυρο κατα 30 νουκλεοτίδια δεξιά. Οπότε η θέση του έγινε από 31 μέχρι 530. Πάλι υπολογίστε τον λόγο  GC και αποθηκεύστε τον
* Όταν το τέλος του παραθύρου ξεπεράσει τον μήκος της ακολουθία σταματήστε.
* Κάντε ένα πλοτ: βάλτε στο Χ άξονα την αρχή του παραθύρου που έγινε η μέτρηση και στον Υ η μέτρηση του GC που κάνατε.

## Μέρος 2

Ο υπολογισμός του ποσοστού GC είναι ενδιαφέρον, αλλά το τελευταίο διάστημα έχουν εμφανιστεί και άλλες μετρικές! Μία από αυτές είναι το [Mutual Information](https://en.wikipedia.org/wiki/Mutual_information). Συγκεκριμμένα θα εφαρμόσουμε τη μετρική που έχει παρουσιαστεί σε [αυτό το paper](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2335307/)

Οπότε:
* πάρτε πάλι μία τυχαία ακολουθία από το αγαπημένο μας αρχείο.
* Θέστε σαν μέγεθος παραθύρου k=5 (μην το μπερδεύεται με το παράθυρο του του 1ου μέρους, αυτή είναι μία άλλη μέθοδος).
* Έστω Ν<sub>k</sub>(C,G) είναι το πλήθος των φορών που συναντάμε το C και το G σε απόσταση k μέσα στην ακολουθία. Δηλαδή κοιτάμε τη 1η και τη 6η βάση, μετά τη 2η και την 7η, μετά τη 3η και την 8η κτλ.. Αθροίζουμε λοιπόν πόσες φορές τα C και G βρέθηκαν σε απόσταση k.
* Τώρα μετράμε τα Ν<sub>k</sub>(Χ,Υ) όπου Χ είναι όλες οι τιμές A,C,G,T και Υ πάλι όλες οι τιμές A,C,G,T. Συνολικά δηλαδή θά πάρουμε 4\*4=16 μετρήσεις.

Επεξήγηση:

```text
 μέτρηση 1:  Α...<-απόσταση κ->... Α
 μέτρηση 2:  Α...<-απόσταση κ->... C
 μέτρηση 3:  Α...<-απόσταση κ->... G
 μέτρηση 4:  Α...<-απόσταση κ->... T
 μέτρηση 5:  C...<-απόσταση κ->... Α
 μέτρηση 6:  C...<-απόσταση κ->... C
 μέτρηση 7:  C...<-απόσταση κ->... G
 μέτρηση 8:  C...<-απόσταση κ->... T
 μέτρηση 9:  G...<-απόσταση κ->... Α
μέτρηση 10:  G...<-απόσταση κ->... C
μέτρηση 11:  G...<-απόσταση κ->... G
μέτρηση 12:  G...<-απόσταση κ->... T
μέτρηση 13:  T...<-απόσταση κ->... Α
μέτρηση 14:  T...<-απόσταση κ->... C
μέτρηση 15:  T...<-απόσταση κ->... G
μέτρηση 16:  T...<-απόσταση κ->... T

Για παράδειγμα: μέτρηση 9:  G...<-απόσταση κ->... Α  σημαίνει: πόσες φορές βρήκαμε τα G και A να έχουν απόσταση κ;
```

```text
Έστω η ακολουθία: 
ACACTTCT

και έστω κ=5. Παίρνουμε το πρώτο και τελευταίο γράμμα κάθε παράθυρου:
ACACTTCT
|    |
Α    T

ACACTTCT
 |    |
 C    C

ACACTTCT
  |    |
  A    T

```

* Σε αυτό το παράδειγμα:
   * Ν<sub>5</sub>(A,T) = 2  (2 φορές)
   * Ν<sub>5</sub>(C,C) = 1  (1 φορά)

* Αθροιζουμε όλες αυτές τις 16 μετρήσεις και παίρνουμε μία τιμή. Ας την ονομάζουμε S<sub>k</sub>.
* Στη συνέχεια υπολογίζουμε το P<sub>k</sub>(Χ,Υ) το οποίο ορίζεται ως: Ν<sub>k</sub>(Χ,Υ) / S<sub>k</sub>.
* Στη συνέχεια υπολογίζουμε το P(X) το οποίο είναι απλά ο λόγος των εμφανίσεων της βάσης Χ μέσα στην ακολουθία, όπου Χ=A,C,G,T. Δηλαδή αν η ακολουθία είναι AACGTT, τότε P(C)=1/6, P(A)=2/6.
* Στη συνέχεια υπολογίζουμε το Ι<sub>k</sub> σύμφωνα με τον παρακάτω τύπο:

![img](https://i.imgur.com/fDewycT.png)

<!--
$I_{k}=\sum_{X=\{A,C,G,T\}}^{}\sum_{Y=\{A,C,G,T\}}^{}p_{k}(X,Y)*\log\left ( \frac{p_{k}(X,Y)}{p(X)*p(Y)} \right ) $
-->

* Υπολογίζουμε τώρα το Ι<sub>k</sub> για όλες τις τιμές του k από το 5 μέχρι και το 454 (σύνολο 450 διαφορετικές μετρήσεις).
* Φτιάχνουμε ένα plot όπου X είναι οι τιμές του k και Y είναι οι αντίστοιχες τιμές του Ι<sub>k</sub>.

## Μέρος 3

Από το μέρος 2, για κάθε ακολουθία μπορούμε να φτιάξουμε έναν πίνακα από περίπου \~25.000 τιμές. Για παράδειγμα αν μία ακολουθία αποτελείται από 30.000 βάσεις και το μέγεθος του παραθύρου είναι 500 με βήμα 30, τότε θα έχουμε (30.000-500)/30 = 983 μετρήσεις. 

Κάντε τις ανάλογες αλλαγές (ό,τι θέλετε: αλλαγή του μέγεθους του παραθύρου ή του βήματος, ή και τα δύο), ώστε το αποτέλεσμα να βγαίνει πάντα 900 μετρήσεις **Για οποιαδήποτε ακολουθία του αρχείου**

Στη συνέχεια υπολογίστε
* τις τιμές της μετρικής της άσκηση 13 (με τη διόρθωση που μόλις παρουσίασαμε) για όλες τις ακολουθίες
* τις τιμές της μετρικής της άσκησης 14 για όλες τις ακολουθίες. 
* Αν αργεί πολύ αυτή η διαδικασία απλά επιλέξτε 1000 (ή.. λιγότερες) τυχαίες ακολουθίες.

Στο τέλος πρέπει να έχετε έναν πίνακα:
* Α = 8728 Χ 900, από τις μετρήσεις της 1ης μετρικής (άσκηση 13+διόρθωση)
* Β = 8728 Χ 450, από τις μετρήσεις της 2ης μετρικής (άσκηση 14) 

### Μέρος 4

Όταν έχουμε πολυδιάστατα δεδομένα, ένας ωραίος τρόπος για να τα οπτικοποιήσουμε στις 2 διαστάσεις είναι το PCA. Ας δούμε λίγο πως δουλεύει..

Για αρχή φτιάχνουμε έναν τυχαίο πίνακα 100\*1000


```python
import numpy as np
a = np.random.random((100, 1000))
```

Φτιάχνουμε τώρα και έναν 2ο και.. του προσθέτουμε μία μικρή παραμόρφωση ώστε να τον διαφοροποιήσουμε από τον πρώτο:


```python
b = np.random.random((100, 1000)) + 0.04
```

Ας ενώσουμε τους δύο πίνακες σε έναν:


```python
c = np.vstack((a,b))
c.shape
```




    (200, 1000)



Στη συνέχεια εφαρμόζουμε PCA στον c, για 2 διαστάσεις:


```python
from sklearn.decomposition import PCA

pca = PCA(n_components=2)
pca.fit(c)
# Κάνουμε προβολή στις 2 διαστάσεις που υπολόγισε το pca.fit:
c_PCA = pca.transform(c)
c_PCA.shape
```




    (200, 2)



Βλέπουμε τώρα από τις 1000 διαστάσεις πήγαμε στις 2! Άρα μπορούμε να "πλοτάρουμε" στις 2 διαστάσεις:



```python
fig, ax = plt.subplots()

ax.plot(c_PCA[:100,0], c_PCA[:100,1], 'r.') # Τα 100 του a είναι κόκκινες κουκίδες
ax.plot(c_PCA[100:,0], c_PCA[100:,1], 'b.') # Τα 100 του b είναι μπλε κουκίδες

```




    [<matplotlib.lines.Line2D at 0x1a2dac3860>]




    
![png](output_79_1.png)
    


Βλέπουμε δηλαδή ότι παρόλη τη μικρή παραμόρφωση που βάλαμε, το PCA μπόρεσε να δείξει τις διαφορές των a και b σε έναν ικανοποιητικό βαθμό.

Σε αυτή την άσκηση θα πρέπει να εφαρμόσετε PCA στις δύο διαστάσεις στους πίνακες Α και Β που φτιάξατε στην άσκηση 15. Θα πρέπει δηλαδή να φτιάξετε 2 plots. 

**Προαιρετικό:** 
* Χρωματίστε τις ακολουθίες ανάλογα με τις ηπείρους από όπου προέρχονται τα δείγματα. 
* Χρωματίστε τις ακολουθίες ανάλογα με τις χώρες που προέρχονται, βάλτε τις 10 μεγαλύτερες σε πληθυσμό χώρες του κόσμου μόνο.
* Βάλτε μόνο τις ευρωπαϊκές χώρες και χρωματίστες τις ακολουθίες ανάλογα με τη χώρα από όπου προέρχονται


### Μέρος 5

Τώρα φτάσαμε στο σημείο να μπορέσουμε να συγκρίνουμε δύο διαφορετικές ακολουθίες του ιού. Οι κλασσσικές μέθοδοι δυστυχώς είναι πολύ αργές για τόσο πολλές ακολουθίες (π.χ. pairwise aligment). Για αυτό θα κάνουμε τη δική μας μετρική. Για μία ακολουθία μετράμε το πλήθος όλως των διαδορετικών κωδικόνιων. Για παράδειγμα το πλήθος όλων των διαφορετικών κωδικόνιων είναι  τη 1η ακολουθία είναι:

```python
Counter({'TTT': 385, 'TGT': 368, 'TAA': 343, 'TGA': 305, 'AAA': 304, 'TAT': 278, 'AGA': 277, 'TGC': 268, 'TGG': 261, 'AAT': 260, 'ACA': 249, 'GTT': 234, 'TTA': 233, 'CAA': 232, 'TAC': 227, 'ACT': 220, 'AAC': 212, 'TTC': 210, 'ATT': 207, 'CTT': 207, 'AGT': 197, 'TCT': 190, 'GAA': 184, 'TTG': 179, 'TCA': 173, 'CAT': 172, 'GCT': 169, 'GAT': 167, 'CAC': 160, 'ACC': 150, 'GGT': 149, 'AGC': 141, 'TAG': 128, 'AGG': 123, 'GAC': 123, 'GTA': 121, 'ATG': 117, 'GCA': 116, 'ATA': 116, 'CCA': 115, 'ATC': 112, 'GGA': 111, 'AAG': 110, 'CTA': 109, 'CCT': 106, 'GTC': 101, 'GTG': 93, 'CAG': 92, 'GAG': 85, 'GGC': 84, 'CTC': 79, 'CTG': 79, 'TCC': 75, 'GCC': 68, 'ACG': 60, 'CGT': 53, 'GGG': 50, 'CCC': 42, 'CGC': 40, 'TCG': 34, 'CGG': 33, 'CGA': 31, 'CCG': 28, 'GCG': 22})

```

και για τη 2η:

```python
Counter({'TTT': 383, 'TGT': 368, 'TAA': 343, 'TGA': 304, 'AAA': 303, 'TAT': 278, 'AGA': 277, 'TGC': 268, 'TGG': 262, 'AAT': 260, 'ACA': 248, 'TTA': 235, 'CAA': 233, 'GTT': 233, 'TAC': 227, 'ACT': 219, 'AAC': 212, 'ATT': 210, 'TTC': 210, 'CTT': 209, 'AGT': 198, 'TCT': 191, 'GAA': 186, 'TTG': 178, 'CAT': 172, 'TCA': 170, 'GCT': 168, 'GAT': 167, 'CAC': 160, 'ACC': 150, 'GGT': 149, 'AGC': 140, 'TAG': 128, 'AGG': 123, 'GAC': 122, 'GTA': 120, 'ATA': 117, 'CCA': 117, 'GCA': 116, 'ATG': 116, 'ATC': 112, 'GGA': 111, 'AAG': 110, 'CTA': 109, 'CCT': 106, 'GTC': 101, 'GTG': 93, 'CAG': 92, 'GGC': 85, 'GAG': 84, 'CTG': 80, 'CTC': 78, 'TCC': 75, 'GCC': 68, 'ACG': 60, 'CGT': 53, 'GGG': 49, 'CCC': 42, 'CGC': 40, 'TCG': 34, 'CGG': 33, 'CGA': 31, 'CCG': 28, 'GCG': 23})
```

Παρατηρούμε ότι δεν διαφέρουν και πάρα πολύ! Πράγματικά μπορούμε να φτιάξουμε δύο πίνακες 1X64 (64 = 4\*4\*4) με τις διαφορετικές τιμές μεταξύ της 1ης και της 2ης ακολουθίας:



```python
a = np.array([304, 212, 110, 260, 249, 150,  60, 220, 277, 141, 123, 197, 116,
        112, 117, 207, 232, 160,  92, 172, 115,  42,  28, 106,  31,  40,
         33,  53, 109,  79,  79, 207, 184, 123,  85, 167, 116,  68,  22,
        169, 111,  84,  50, 149, 121, 101,  93, 234, 343, 227, 128, 278,
        173,  75,  34, 190, 305, 268, 261, 368, 233, 210, 179, 385])
b = np.array([303, 212, 110, 260, 248, 150,  60, 219, 277, 140, 123, 198, 117,
        112, 116, 210, 233, 160,  92, 172, 117,  42,  28, 106,  31,  40,
         33,  53, 109,  78,  80, 209, 186, 122,  84, 167, 116,  68,  23,
        168, 111,  85,  49, 149, 120, 101,  93, 233, 343, 227, 128, 278,
        170,  75,  34, 191, 304, 268, 262, 368, 235, 210, 178, 383])
```

Στη συνέχεια μπορούμε να υπολογίσουμε τη chi-square distance (κατάλληλη για διαφορές σε επίπεδο ιστογράμματος μεταξύ δύο δειγμάτων). Για αυτόν τον υπολογισμό μπορούμε να χρησιμοποιήσουμε είτε τη scipy:


```python
from scipy.stats import chi2_contingency

chi2, p, dof, ex = chi2_contingency(np.array([a,b]))
chi2

```




    0.20114259183383668



Είτε το κώδικα που μπορούμε να βρούμε.. στα Internets!


```python
# Function to calculate Chi-distace 
# Source: https://www.geeksforgeeks.org/chi-square-distance-in-python/
def chi2_distance(A, B): 
  
    # compute the chi-squared distance using above formula 
    chi =  np.sum([((a - b) ** 2) / (a + b)  
                      for (a, b) in zip(A, B)])
    
    return chi


chi2_distance(a,b)

```




    0.20114259183383668



Οπότε τώρα έχουμε μία (σχετικά..) γρήγορη μέθοδο για να συγκρίνουμε ακολουθίες. Το επόμενο στάδιο είναι να.. πετάξουμε έξω όσες ακουλουθίες "μοιάζουν" μέσα στο αρχείο. Για να το κάνουμε αυτό τρέχουμε τον εξής αλγόριθμο.

* Συγκρίνουμε τη 1η με τη 2η. Αν το ch-square distance είναι μικρότερο από 1 τότε πετάμε τη 1η ακολουθία και ξεκινάμε από την αρχή.
* Αν δεν είναι ίδιο συγκρίνουμε τη 1η με τη 3η, αν το distance είναι μικρότερο από 1.0 πετάμε τη 1η και ξεκινάμε από την αρχή, αλλιώς συγκρίνουμε τη 1η με τη 4η κτλ..
* Συνεχίζουμε συγκρίνοντας τη 2η με τη 3η, 2η με 4η, ...
* Συνεχίζουμε αυτή τη διαδικασία μέχρι να μην υπάρχει ζευγάρι από ακολουθίες με distance < 1.0

Αυτή η διαδικασία δεν πρέπει να παίρνει παραπάνω από 15 λεπτά υπολογισμών (η δική μου υλοποίηση έκανε 5 λεπτά). Μόλις τελειώσει θα έχουν μείνει 14 ακολουθίες (από τις 8728!) που διαφέρουν τελείως μεταξύ τους. Δηλαδή θα έχετε ανακαλύψει τα 14 βασικά strains του ιού. Ποιες είναι αυτές οι ακολουθίες (τυπώστε τις επικεφαλίδες τους);

## Μέρος 6
Φτιάξτε ένα δενδρόγραμμα με τις 14 ακολουθίες που βρήκατε από το μέρος 5. Χρησιμοποιήστε τη μεθοδολογία που έχουμε δείξει στις σημειώσεις για να φτιάξετε το δενδρόγραμμα. Ως μετρική για την απόσταση χρησιμοποιήστε το chi square distance. Αν θέλετε μπορείτε να χρησιμοποιήσετε όποια άλλη μετρική απόστασης θέλετε!


Σε αυτό το project θα πρέπει να φτιάξετε ένα πρόγραμμα το οποίο θα παίρνει τις εξής παραμέτρους. 
* ```--file PATH ``` όνομα αρχείου και διαδρομή (path) του αρχείου, το οποίο περιέχει τις ακολουθίες. (υποχρεωτική παράμετρο)
* ```--pca_plot FILENAME``` όνομα του αρχείου στο οποίο θα σώσει το PCA_plot  (προαιρετική παράμετρος)
* ```--dendrogram_plot FILENAME``` όνομα του αρχείου στο οποίο θα σώσει το dedrogram plot (προαιρετική παράμετρος)




